/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fqaneahmed%2FPregLife%2Fpreglife%2Fbaby-name-deathmatch%2Fapp%2Fglobals.css&modules=%2FUsers%2Fqaneahmed%2FPregLife%2Fpreglife%2Fbaby-name-deathmatch%2Fcomponents%2FConvexClientProvider.tsx&server=false!":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fqaneahmed%2FPregLife%2Fpreglife%2Fbaby-name-deathmatch%2Fapp%2Fglobals.css&modules=%2FUsers%2Fqaneahmed%2FPregLife%2Fpreglife%2Fbaby-name-deathmatch%2Fcomponents%2FConvexClientProvider.tsx&server=false! ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/globals.css */ \"(app-pages-browser)/./app/globals.css\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/ConvexClientProvider.tsx */ \"(app-pages-browser)/./components/ConvexClientProvider.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRnFhbmVhaG1lZCUyRlByZWdMaWZlJTJGcHJlZ2xpZmUlMkZiYWJ5LW5hbWUtZGVhdGhtYXRjaCUyRmFwcCUyRmdsb2JhbHMuY3NzJm1vZHVsZXM9JTJGVXNlcnMlMkZxYW5lYWhtZWQlMkZQcmVnTGlmZSUyRnByZWdsaWZlJTJGYmFieS1uYW1lLWRlYXRobWF0Y2glMkZjb21wb25lbnRzJTJGQ29udmV4Q2xpZW50UHJvdmlkZXIudHN4JnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsNEpBQTRHO0FBQzVHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/MTlmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9xYW5lYWhtZWQvUHJlZ0xpZmUvcHJlZ2xpZmUvYmFieS1uYW1lLWRlYXRobWF0Y2gvYXBwL2dsb2JhbHMuY3NzXCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvcWFuZWFobWVkL1ByZWdMaWZlL3ByZWdsaWZlL2JhYnktbmFtZS1kZWF0aG1hdGNoL2NvbXBvbmVudHMvQ29udmV4Q2xpZW50UHJvdmlkZXIudHN4XCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fqaneahmed%2FPregLife%2Fpreglife%2Fbaby-name-deathmatch%2Fapp%2Fglobals.css&modules=%2FUsers%2Fqaneahmed%2FPregLife%2Fpreglife%2Fbaby-name-deathmatch%2Fcomponents%2FConvexClientProvider.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"4f61bf175cef\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbHMuY3NzPzE1YmQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI0ZjYxYmYxNzVjZWZcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/ConvexClientProvider.tsx":
/*!*********************************************!*\
  !*** ./components/ConvexClientProvider.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ConvexClientProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var convex_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! convex/react */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/index.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nconst convex = new convex_react__WEBPACK_IMPORTED_MODULE_1__.ConvexReactClient(\"https://charming-basilisk-797.convex.cloud\");\nfunction ConvexClientProvider(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(convex_react__WEBPACK_IMPORTED_MODULE_1__.ConvexProvider, {\n        client: convex,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/qaneahmed/PregLife/preglife/baby-name-deathmatch/components/ConvexClientProvider.tsx\",\n        lineNumber: 13,\n        columnNumber: 12\n    }, this);\n}\n_c = ConvexClientProvider;\nvar _c;\n$RefreshReg$(_c, \"ConvexClientProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvQ29udmV4Q2xpZW50UHJvdmlkZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFHaUU7QUFFakUsTUFBTUUsU0FBUyxJQUFJRCwyREFBaUJBLENBQUNFLDRDQUFrQztBQUV4RCxTQUFTRyxxQkFBcUIsS0FJNUM7UUFKNEMsRUFDekNDLFFBQVEsRUFHWCxHQUo0QztJQUt6QyxxQkFBTyw4REFBQ1Asd0RBQWNBO1FBQUNRLFFBQVFOO2tCQUFTSzs7Ozs7O0FBQzVDO0tBTndCRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0NvbnZleENsaWVudFByb3ZpZGVyLnRzeD84OWU0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyBSZWFjdE5vZGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IENvbnZleFByb3ZpZGVyLCBDb252ZXhSZWFjdENsaWVudCB9IGZyb20gXCJjb252ZXgvcmVhY3RcIjtcblxuY29uc3QgY29udmV4ID0gbmV3IENvbnZleFJlYWN0Q2xpZW50KHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0NPTlZFWF9VUkwhKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29udmV4Q2xpZW50UHJvdmlkZXIoe1xuICAgIGNoaWxkcmVuLFxufToge1xuICAgIGNoaWxkcmVuOiBSZWFjdE5vZGU7XG59KSB7XG4gICAgcmV0dXJuIDxDb252ZXhQcm92aWRlciBjbGllbnQ9e2NvbnZleH0+e2NoaWxkcmVufTwvQ29udmV4UHJvdmlkZXI+O1xufVxuIl0sIm5hbWVzIjpbIkNvbnZleFByb3ZpZGVyIiwiQ29udmV4UmVhY3RDbGllbnQiLCJjb252ZXgiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQ09OVkVYX1VSTCIsIkNvbnZleENsaWVudFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJjbGllbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ConvexClientProvider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/browser/http_client.js":
/*!*************************************************************!*\
  !*** ./node_modules/convex/dist/esm/browser/http_client.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConvexHttpClient: function() { return /* binding */ ConvexHttpClient; },\n/* harmony export */   STATUS_CODE_BAD_REQUEST: function() { return /* binding */ STATUS_CODE_BAD_REQUEST; },\n/* harmony export */   STATUS_CODE_OK: function() { return /* binding */ STATUS_CODE_OK; },\n/* harmony export */   STATUS_CODE_UDF_FAILED: function() { return /* binding */ STATUS_CODE_UDF_FAILED; },\n/* harmony export */   setFetch: function() { return /* binding */ setFetch; }\n/* harmony export */ });\n/* harmony import */ var _server_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../server/api.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/server/api.js\");\n/* harmony import */ var _common_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/common/index.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/index.js\");\n/* harmony import */ var _values_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../values/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/index.js\");\n/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./logging.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/logging.js\");\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n\n\n\n\nconst STATUS_CODE_OK = 200;\nconst STATUS_CODE_BAD_REQUEST = 400;\nconst STATUS_CODE_UDF_FAILED = 560;\nlet specifiedFetch = void 0;\nfunction setFetch(f) {\n    specifiedFetch = f;\n}\nclass ConvexHttpClient {\n    /**\n   * Obtain the {@link ConvexHttpClient}'s URL to its backend.\n   * @deprecated Use url, which returns the url without /api at the end.\n   *\n   * @returns The URL to the Convex backend, including the client's API version.\n   */ backendUrl() {\n        return \"\".concat(this.address, \"/api\");\n    }\n    /**\n   * Return the address for this client, useful for creating a new client.\n   *\n   * Not guaranteed to match the address with which this client was constructed:\n   * it may be canonicalized.\n   */ get url() {\n        return this.address;\n    }\n    /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   *\n   * Should be called whenever the token changes (i.e. due to expiration and refresh).\n   *\n   * @param value - JWT-encoded OpenID Connect identity token.\n   */ setAuth(value) {\n        this.clearAuth();\n        this.auth = value;\n    }\n    /**\n   * Set admin auth token to allow calling internal queries, mutations, and actions\n   * and acting as an identity.\n   *\n   * @internal\n   */ setAdminAuth(token, actingAsIdentity) {\n        this.clearAuth();\n        if (actingAsIdentity !== void 0) {\n            const bytes = new TextEncoder().encode(JSON.stringify(actingAsIdentity));\n            const actingAsIdentityEncoded = btoa(String.fromCodePoint(...bytes));\n            this.adminAuth = \"\".concat(token, \":\").concat(actingAsIdentityEncoded);\n        } else {\n            this.adminAuth = token;\n        }\n    }\n    /**\n   * Clear the current authentication token if set.\n   */ clearAuth() {\n        this.auth = void 0;\n        this.adminAuth = void 0;\n    }\n    /**\n   * Sets whether the result log lines should be printed on the console or not.\n   *\n   * @internal\n   */ setDebug(debug) {\n        this.debug = debug;\n    }\n    /**\n   * Used to customize the fetch behavior in some runtimes.\n   *\n   * @internal\n   */ setFetchOptions(fetchOptions) {\n        this.fetchOptions = fetchOptions;\n    }\n    /**\n   * This API is experimental: it may change or disappear.\n   *\n   * Execute a Convex query function at the same timestamp as every other\n   * consistent query execution run by this HTTP client.\n   *\n   * This doesn't make sense for long-lived ConvexHttpClients as Convex\n   * backends can read a limited amount into the past: beyond 30 seconds\n   * in the past may not be available.\n   *\n   * Create a new client to use a consistent time.\n   *\n   * @param name - The name of the query.\n   * @param args - The arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the query's result.\n   *\n   * @deprecated This API is experimental: it may change or disappear.\n   */ async consistentQuery(query) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        const queryArgs = (0,_common_index_js__WEBPACK_IMPORTED_MODULE_1__.parseArgs)(args[0]);\n        const timestampPromise = this.getTimestamp();\n        return await this.queryInner(query, queryArgs, {\n            timestampPromise\n        });\n    }\n    async getTimestamp() {\n        if (this.encodedTsPromise) {\n            return this.encodedTsPromise;\n        }\n        return this.encodedTsPromise = this.getTimestampInner();\n    }\n    async getTimestampInner() {\n        const localFetch = specifiedFetch || fetch;\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"Convex-Client\": \"npm-\".concat(_index_js__WEBPACK_IMPORTED_MODULE_2__.version)\n        };\n        const response = await localFetch(\"\".concat(this.address, \"/api/query_ts\"), {\n            ...this.fetchOptions,\n            method: \"POST\",\n            headers\n        });\n        if (!response.ok) {\n            throw new Error(await response.text());\n        }\n        const { ts } = await response.json();\n        return ts;\n    }\n    /**\n   * Execute a Convex query function.\n   *\n   * @param name - The name of the query.\n   * @param args - The arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the query's result.\n   */ async query(query) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        const queryArgs = (0,_common_index_js__WEBPACK_IMPORTED_MODULE_1__.parseArgs)(args[0]);\n        return await this.queryInner(query, queryArgs, {});\n    }\n    async queryInner(query, queryArgs, options) {\n        const name = (0,_server_api_js__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(query);\n        const args = [\n            (0,_values_index_js__WEBPACK_IMPORTED_MODULE_3__.convexToJson)(queryArgs)\n        ];\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"Convex-Client\": \"npm-\".concat(_index_js__WEBPACK_IMPORTED_MODULE_2__.version)\n        };\n        if (this.adminAuth) {\n            headers[\"Authorization\"] = \"Convex \".concat(this.adminAuth);\n        } else if (this.auth) {\n            headers[\"Authorization\"] = \"Bearer \".concat(this.auth);\n        }\n        const localFetch = specifiedFetch || fetch;\n        const timestamp = options.timestampPromise ? await options.timestampPromise : void 0;\n        const body = JSON.stringify({\n            path: name,\n            format: \"convex_encoded_json\",\n            args,\n            ...timestamp ? {\n                ts: timestamp\n            } : {}\n        });\n        const endpoint = timestamp ? \"\".concat(this.address, \"/api/query_at_ts\") : \"\".concat(this.address, \"/api/query\");\n        const response = await localFetch(endpoint, {\n            ...this.fetchOptions,\n            body,\n            method: \"POST\",\n            headers\n        });\n        if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n            throw new Error(await response.text());\n        }\n        const respJSON = await response.json();\n        if (this.debug) {\n            var _respJSON_logLines;\n            for (const line of (_respJSON_logLines = respJSON.logLines) !== null && _respJSON_logLines !== void 0 ? _respJSON_logLines : []){\n                (0,_logging_js__WEBPACK_IMPORTED_MODULE_4__.logForFunction)(this.logger, \"info\", \"query\", name, line);\n            }\n        }\n        switch(respJSON.status){\n            case \"success\":\n                return (0,_values_index_js__WEBPACK_IMPORTED_MODULE_3__.jsonToConvex)(respJSON.value);\n            case \"error\":\n                if (respJSON.errorData !== void 0) {\n                    throw forwardErrorData(respJSON.errorData, new _values_index_js__WEBPACK_IMPORTED_MODULE_3__.ConvexError(respJSON.errorMessage));\n                }\n                throw new Error(respJSON.errorMessage);\n            default:\n                throw new Error(\"Invalid response: \".concat(JSON.stringify(respJSON)));\n        }\n    }\n    async mutationInner(mutation, mutationArgs) {\n        const name = (0,_server_api_js__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(mutation);\n        const body = JSON.stringify({\n            path: name,\n            format: \"convex_encoded_json\",\n            args: [\n                (0,_values_index_js__WEBPACK_IMPORTED_MODULE_3__.convexToJson)(mutationArgs)\n            ]\n        });\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"Convex-Client\": \"npm-\".concat(_index_js__WEBPACK_IMPORTED_MODULE_2__.version)\n        };\n        if (this.adminAuth) {\n            headers[\"Authorization\"] = \"Convex \".concat(this.adminAuth);\n        } else if (this.auth) {\n            headers[\"Authorization\"] = \"Bearer \".concat(this.auth);\n        }\n        const localFetch = specifiedFetch || fetch;\n        const response = await localFetch(\"\".concat(this.address, \"/api/mutation\"), {\n            ...this.fetchOptions,\n            body,\n            method: \"POST\",\n            headers\n        });\n        if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n            throw new Error(await response.text());\n        }\n        const respJSON = await response.json();\n        if (this.debug) {\n            var _respJSON_logLines;\n            for (const line of (_respJSON_logLines = respJSON.logLines) !== null && _respJSON_logLines !== void 0 ? _respJSON_logLines : []){\n                (0,_logging_js__WEBPACK_IMPORTED_MODULE_4__.logForFunction)(this.logger, \"info\", \"mutation\", name, line);\n            }\n        }\n        switch(respJSON.status){\n            case \"success\":\n                return (0,_values_index_js__WEBPACK_IMPORTED_MODULE_3__.jsonToConvex)(respJSON.value);\n            case \"error\":\n                if (respJSON.errorData !== void 0) {\n                    throw forwardErrorData(respJSON.errorData, new _values_index_js__WEBPACK_IMPORTED_MODULE_3__.ConvexError(respJSON.errorMessage));\n                }\n                throw new Error(respJSON.errorMessage);\n            default:\n                throw new Error(\"Invalid response: \".concat(JSON.stringify(respJSON)));\n        }\n    }\n    async processMutationQueue() {\n        if (this.isProcessingQueue) {\n            return;\n        }\n        this.isProcessingQueue = true;\n        while(this.mutationQueue.length > 0){\n            const { mutation, args, resolve, reject } = this.mutationQueue.shift();\n            try {\n                const result = await this.mutationInner(mutation, args);\n                resolve(result);\n            } catch (error) {\n                reject(error);\n            }\n        }\n        this.isProcessingQueue = false;\n    }\n    enqueueMutation(mutation, args) {\n        return new Promise((resolve, reject)=>{\n            this.mutationQueue.push({\n                mutation,\n                args,\n                resolve,\n                reject\n            });\n            void this.processMutationQueue();\n        });\n    }\n    /**\n   * Execute a Convex mutation function. Mutations are queued by default.\n   *\n   * @param name - The name of the mutation.\n   * @param args - The arguments object for the mutation. If this is omitted,\n   * the arguments will be `{}`.\n   * @param options - An optional object containing\n   * @returns A promise of the mutation's result.\n   */ async mutation(mutation) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        const [fnArgs, options] = args;\n        const mutationArgs = (0,_common_index_js__WEBPACK_IMPORTED_MODULE_1__.parseArgs)(fnArgs);\n        const queued = !(options === null || options === void 0 ? void 0 : options.skipQueue);\n        if (queued) {\n            return await this.enqueueMutation(mutation, mutationArgs);\n        } else {\n            return await this.mutationInner(mutation, mutationArgs);\n        }\n    }\n    /**\n   * Execute a Convex action function. Actions are not queued.\n   *\n   * @param name - The name of the action.\n   * @param args - The arguments object for the action. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the action's result.\n   */ async action(action) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        const actionArgs = (0,_common_index_js__WEBPACK_IMPORTED_MODULE_1__.parseArgs)(args[0]);\n        const name = (0,_server_api_js__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(action);\n        const body = JSON.stringify({\n            path: name,\n            format: \"convex_encoded_json\",\n            args: [\n                (0,_values_index_js__WEBPACK_IMPORTED_MODULE_3__.convexToJson)(actionArgs)\n            ]\n        });\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"Convex-Client\": \"npm-\".concat(_index_js__WEBPACK_IMPORTED_MODULE_2__.version)\n        };\n        if (this.adminAuth) {\n            headers[\"Authorization\"] = \"Convex \".concat(this.adminAuth);\n        } else if (this.auth) {\n            headers[\"Authorization\"] = \"Bearer \".concat(this.auth);\n        }\n        const localFetch = specifiedFetch || fetch;\n        const response = await localFetch(\"\".concat(this.address, \"/api/action\"), {\n            ...this.fetchOptions,\n            body,\n            method: \"POST\",\n            headers\n        });\n        if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n            throw new Error(await response.text());\n        }\n        const respJSON = await response.json();\n        if (this.debug) {\n            var _respJSON_logLines;\n            for (const line of (_respJSON_logLines = respJSON.logLines) !== null && _respJSON_logLines !== void 0 ? _respJSON_logLines : []){\n                (0,_logging_js__WEBPACK_IMPORTED_MODULE_4__.logForFunction)(this.logger, \"info\", \"action\", name, line);\n            }\n        }\n        switch(respJSON.status){\n            case \"success\":\n                return (0,_values_index_js__WEBPACK_IMPORTED_MODULE_3__.jsonToConvex)(respJSON.value);\n            case \"error\":\n                if (respJSON.errorData !== void 0) {\n                    throw forwardErrorData(respJSON.errorData, new _values_index_js__WEBPACK_IMPORTED_MODULE_3__.ConvexError(respJSON.errorMessage));\n                }\n                throw new Error(respJSON.errorMessage);\n            default:\n                throw new Error(\"Invalid response: \".concat(JSON.stringify(respJSON)));\n        }\n    }\n    /**\n   * Execute a Convex function of an unknown type. These function calls are not queued.\n   *\n   * @param name - The name of the function.\n   * @param args - The arguments object for the function. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the function's result.\n   *\n   * @internal\n   */ async function(anyFunction, componentPath) {\n        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n            args[_key - 2] = arguments[_key];\n        }\n        const functionArgs = (0,_common_index_js__WEBPACK_IMPORTED_MODULE_1__.parseArgs)(args[0]);\n        const name = typeof anyFunction === \"string\" ? anyFunction : (0,_server_api_js__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(anyFunction);\n        const body = JSON.stringify({\n            componentPath,\n            path: name,\n            format: \"convex_encoded_json\",\n            args: (0,_values_index_js__WEBPACK_IMPORTED_MODULE_3__.convexToJson)(functionArgs)\n        });\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"Convex-Client\": \"npm-\".concat(_index_js__WEBPACK_IMPORTED_MODULE_2__.version)\n        };\n        if (this.adminAuth) {\n            headers[\"Authorization\"] = \"Convex \".concat(this.adminAuth);\n        } else if (this.auth) {\n            headers[\"Authorization\"] = \"Bearer \".concat(this.auth);\n        }\n        const localFetch = specifiedFetch || fetch;\n        const response = await localFetch(\"\".concat(this.address, \"/api/function\"), {\n            ...this.fetchOptions,\n            body,\n            method: \"POST\",\n            headers\n        });\n        if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n            throw new Error(await response.text());\n        }\n        const respJSON = await response.json();\n        if (this.debug) {\n            var _respJSON_logLines;\n            for (const line of (_respJSON_logLines = respJSON.logLines) !== null && _respJSON_logLines !== void 0 ? _respJSON_logLines : []){\n                (0,_logging_js__WEBPACK_IMPORTED_MODULE_4__.logForFunction)(this.logger, \"info\", \"any\", name, line);\n            }\n        }\n        switch(respJSON.status){\n            case \"success\":\n                return (0,_values_index_js__WEBPACK_IMPORTED_MODULE_3__.jsonToConvex)(respJSON.value);\n            case \"error\":\n                if (respJSON.errorData !== void 0) {\n                    throw forwardErrorData(respJSON.errorData, new _values_index_js__WEBPACK_IMPORTED_MODULE_3__.ConvexError(respJSON.errorMessage));\n                }\n                throw new Error(respJSON.errorMessage);\n            default:\n                throw new Error(\"Invalid response: \".concat(JSON.stringify(respJSON)));\n        }\n    }\n    /**\n   * Create a new {@link ConvexHttpClient}.\n   *\n   * @param address - The url of your Convex deployment, often provided\n   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.\n   * @param options - An object of options.\n   * - `skipConvexDeploymentUrlCheck` - Skip validating that the Convex deployment URL looks like\n   * `https://happy-animal-123.convex.cloud` or localhost. This can be useful if running a self-hosted\n   * Convex backend that uses a different URL.\n   * - `logger` - A logger or a boolean. If not provided, logs to the console.\n   * You can construct your own logger to customize logging to log elsewhere\n   * or not log at all, or use `false` as a shorthand for a no-op logger.\n   * A logger is an object with 4 methods: log(), warn(), error(), and logVerbose().\n   * These methods can receive multiple arguments of any types, like console.log().\n   * - `auth` - A JWT containing identity claims accessible in Convex functions.\n   * This identity may expire so it may be necessary to call `setAuth()` later,\n   * but for short-lived clients it's convenient to specify this value here.\n   */ constructor(address, options){\n        __publicField(this, \"address\");\n        __publicField(this, \"auth\");\n        __publicField(this, \"adminAuth\");\n        __publicField(this, \"encodedTsPromise\");\n        __publicField(this, \"debug\");\n        __publicField(this, \"fetchOptions\");\n        __publicField(this, \"logger\");\n        __publicField(this, \"mutationQueue\", []);\n        __publicField(this, \"isProcessingQueue\", false);\n        if (typeof options === \"boolean\") {\n            throw new Error(\"skipConvexDeploymentUrlCheck as the second argument is no longer supported. Please pass an options object, `{ skipConvexDeploymentUrlCheck: true }`.\");\n        }\n        const opts = options !== null && options !== void 0 ? options : {};\n        if (opts.skipConvexDeploymentUrlCheck !== true) {\n            (0,_common_index_js__WEBPACK_IMPORTED_MODULE_1__.validateDeploymentUrl)(address);\n        }\n        this.logger = (options === null || options === void 0 ? void 0 : options.logger) === false ? (0,_logging_js__WEBPACK_IMPORTED_MODULE_4__.instantiateNoopLogger)({\n            verbose: false\n        }) : (options === null || options === void 0 ? void 0 : options.logger) !== true && (options === null || options === void 0 ? void 0 : options.logger) ? options.logger : (0,_logging_js__WEBPACK_IMPORTED_MODULE_4__.instantiateDefaultLogger)({\n            verbose: false\n        });\n        this.address = address;\n        this.debug = true;\n        this.auth = void 0;\n        this.adminAuth = void 0;\n        if (options === null || options === void 0 ? void 0 : options.auth) {\n            this.setAuth(options.auth);\n        }\n    }\n}\nfunction forwardErrorData(errorData, error) {\n    error.data = (0,_values_index_js__WEBPACK_IMPORTED_MODULE_3__.jsonToConvex)(errorData);\n    return error;\n} //# sourceMappingURL=http_client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9odHRwX2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYixJQUFJQSxZQUFZQyxPQUFPQyxjQUFjO0FBQ3JDLElBQUlDLGtCQUFrQixDQUFDQyxLQUFLQyxLQUFLQyxRQUFVRCxPQUFPRCxNQUFNSixVQUFVSSxLQUFLQyxLQUFLO1FBQUVFLFlBQVk7UUFBTUMsY0FBYztRQUFNQyxVQUFVO1FBQU1IO0lBQU0sS0FBS0YsR0FBRyxDQUFDQyxJQUFJLEdBQUdDO0FBQzFKLElBQUlJLGdCQUFnQixDQUFDTixLQUFLQyxLQUFLQyxRQUFVSCxnQkFBZ0JDLEtBQUssT0FBT0MsUUFBUSxXQUFXQSxNQUFNLEtBQUtBLEtBQUtDO0FBRzlFO0FBQzRDO0FBQ2hDO0FBS1Y7QUFLTjtBQUNmLE1BQU1lLGlCQUFpQixJQUFJO0FBQzNCLE1BQU1DLDBCQUEwQixJQUFJO0FBQ3BDLE1BQU1DLHlCQUF5QixJQUFJO0FBQzFDLElBQUlDLGlCQUFpQixLQUFLO0FBQ25CLFNBQVNDLFNBQVNDLENBQUM7SUFDeEJGLGlCQUFpQkU7QUFDbkI7QUFDTyxNQUFNQztJQStDWDs7Ozs7R0FLQyxHQUNEQyxhQUFhO1FBQ1gsT0FBTyxHQUFnQixPQUFiLElBQUksQ0FBQ0MsT0FBTyxFQUFDO0lBQ3pCO0lBQ0E7Ozs7O0dBS0MsR0FDRCxJQUFJQyxNQUFNO1FBQ1IsT0FBTyxJQUFJLENBQUNELE9BQU87SUFDckI7SUFDQTs7Ozs7O0dBTUMsR0FDREUsUUFBUXpCLEtBQUssRUFBRTtRQUNiLElBQUksQ0FBQzBCLFNBQVM7UUFDZCxJQUFJLENBQUNDLElBQUksR0FBRzNCO0lBQ2Q7SUFDQTs7Ozs7R0FLQyxHQUNENEIsYUFBYUMsS0FBSyxFQUFFQyxnQkFBZ0IsRUFBRTtRQUNwQyxJQUFJLENBQUNKLFNBQVM7UUFDZCxJQUFJSSxxQkFBcUIsS0FBSyxHQUFHO1lBQy9C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TSxNQUFLLFNBQVFYLG9CQUFBQSw4QkFBQUEsUUFBU1csTUFBTSxJQUFHWCxRQUFRVyxNQUFNLEdBQUcvRCxxRUFBd0JBLENBQUM7WUFBRThGLFNBQVM7UUFBTTtRQUMvTCxJQUFJLENBQUNuRixPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDbUIsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDZixJQUFJLEdBQUcsS0FBSztRQUNqQixJQUFJLENBQUNhLFNBQVMsR0FBRyxLQUFLO1FBQ3RCLElBQUl3QixvQkFBQUEsOEJBQUFBLFFBQVNyQyxJQUFJLEVBQUU7WUFDakIsSUFBSSxDQUFDRixPQUFPLENBQUN1QyxRQUFRckMsSUFBSTtRQUMzQjtJQUNGO0FBOFhGO0FBQ0EsU0FBU2tELGlCQUFpQkQsU0FBUyxFQUFFYyxLQUFLO0lBQ3hDQSxNQUFNaUIsSUFBSSxHQUFHaEcsOERBQVlBLENBQUNpRTtJQUMxQixPQUFPYztBQUNULEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9odHRwX2NsaWVudC5qcz82MTZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbmltcG9ydCB7XG4gIGdldEZ1bmN0aW9uTmFtZVxufSBmcm9tIFwiLi4vc2VydmVyL2FwaS5qc1wiO1xuaW1wb3J0IHsgcGFyc2VBcmdzLCB2YWxpZGF0ZURlcGxveW1lbnRVcmwgfSBmcm9tIFwiLi4vY29tbW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL2luZGV4LmpzXCI7XG5pbXBvcnQge1xuICBDb252ZXhFcnJvcixcbiAgY29udmV4VG9Kc29uLFxuICBqc29uVG9Db252ZXhcbn0gZnJvbSBcIi4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHtcbiAgaW5zdGFudGlhdGVEZWZhdWx0TG9nZ2VyLFxuICBpbnN0YW50aWF0ZU5vb3BMb2dnZXIsXG4gIGxvZ0ZvckZ1bmN0aW9uXG59IGZyb20gXCIuL2xvZ2dpbmcuanNcIjtcbmV4cG9ydCBjb25zdCBTVEFUVVNfQ09ERV9PSyA9IDIwMDtcbmV4cG9ydCBjb25zdCBTVEFUVVNfQ09ERV9CQURfUkVRVUVTVCA9IDQwMDtcbmV4cG9ydCBjb25zdCBTVEFUVVNfQ09ERV9VREZfRkFJTEVEID0gNTYwO1xubGV0IHNwZWNpZmllZEZldGNoID0gdm9pZCAwO1xuZXhwb3J0IGZ1bmN0aW9uIHNldEZldGNoKGYpIHtcbiAgc3BlY2lmaWVkRmV0Y2ggPSBmO1xufVxuZXhwb3J0IGNsYXNzIENvbnZleEh0dHBDbGllbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHtAbGluayBDb252ZXhIdHRwQ2xpZW50fS5cbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgLSBUaGUgdXJsIG9mIHlvdXIgQ29udmV4IGRlcGxveW1lbnQsIG9mdGVuIHByb3ZpZGVkXG4gICAqIGJ5IGFuIGVudmlyb25tZW50IHZhcmlhYmxlLiBFLmcuIGBodHRwczovL3NtYWxsLW1vdXNlLTEyMy5jb252ZXguY2xvdWRgLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCBvZiBvcHRpb25zLlxuICAgKiAtIGBza2lwQ29udmV4RGVwbG95bWVudFVybENoZWNrYCAtIFNraXAgdmFsaWRhdGluZyB0aGF0IHRoZSBDb252ZXggZGVwbG95bWVudCBVUkwgbG9va3MgbGlrZVxuICAgKiBgaHR0cHM6Ly9oYXBweS1hbmltYWwtMTIzLmNvbnZleC5jbG91ZGAgb3IgbG9jYWxob3N0LiBUaGlzIGNhbiBiZSB1c2VmdWwgaWYgcnVubmluZyBhIHNlbGYtaG9zdGVkXG4gICAqIENvbnZleCBiYWNrZW5kIHRoYXQgdXNlcyBhIGRpZmZlcmVudCBVUkwuXG4gICAqIC0gYGxvZ2dlcmAgLSBBIGxvZ2dlciBvciBhIGJvb2xlYW4uIElmIG5vdCBwcm92aWRlZCwgbG9ncyB0byB0aGUgY29uc29sZS5cbiAgICogWW91IGNhbiBjb25zdHJ1Y3QgeW91ciBvd24gbG9nZ2VyIHRvIGN1c3RvbWl6ZSBsb2dnaW5nIHRvIGxvZyBlbHNld2hlcmVcbiAgICogb3Igbm90IGxvZyBhdCBhbGwsIG9yIHVzZSBgZmFsc2VgIGFzIGEgc2hvcnRoYW5kIGZvciBhIG5vLW9wIGxvZ2dlci5cbiAgICogQSBsb2dnZXIgaXMgYW4gb2JqZWN0IHdpdGggNCBtZXRob2RzOiBsb2coKSwgd2FybigpLCBlcnJvcigpLCBhbmQgbG9nVmVyYm9zZSgpLlxuICAgKiBUaGVzZSBtZXRob2RzIGNhbiByZWNlaXZlIG11bHRpcGxlIGFyZ3VtZW50cyBvZiBhbnkgdHlwZXMsIGxpa2UgY29uc29sZS5sb2coKS5cbiAgICogLSBgYXV0aGAgLSBBIEpXVCBjb250YWluaW5nIGlkZW50aXR5IGNsYWltcyBhY2Nlc3NpYmxlIGluIENvbnZleCBmdW5jdGlvbnMuXG4gICAqIFRoaXMgaWRlbnRpdHkgbWF5IGV4cGlyZSBzbyBpdCBtYXkgYmUgbmVjZXNzYXJ5IHRvIGNhbGwgYHNldEF1dGgoKWAgbGF0ZXIsXG4gICAqIGJ1dCBmb3Igc2hvcnQtbGl2ZWQgY2xpZW50cyBpdCdzIGNvbnZlbmllbnQgdG8gc3BlY2lmeSB0aGlzIHZhbHVlIGhlcmUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBvcHRpb25zKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFkZHJlc3NcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImF1dGhcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFkbWluQXV0aFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZW5jb2RlZFRzUHJvbWlzZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGVidWdcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZldGNoT3B0aW9uc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibG9nZ2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtdXRhdGlvblF1ZXVlXCIsIFtdKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaXNQcm9jZXNzaW5nUXVldWVcIiwgZmFsc2UpO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJza2lwQ29udmV4RGVwbG95bWVudFVybENoZWNrIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gUGxlYXNlIHBhc3MgYW4gb3B0aW9ucyBvYmplY3QsIGB7IHNraXBDb252ZXhEZXBsb3ltZW50VXJsQ2hlY2s6IHRydWUgfWAuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zID8/IHt9O1xuICAgIGlmIChvcHRzLnNraXBDb252ZXhEZXBsb3ltZW50VXJsQ2hlY2sgIT09IHRydWUpIHtcbiAgICAgIHZhbGlkYXRlRGVwbG95bWVudFVybChhZGRyZXNzKTtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIgPSBvcHRpb25zPy5sb2dnZXIgPT09IGZhbHNlID8gaW5zdGFudGlhdGVOb29wTG9nZ2VyKHsgdmVyYm9zZTogZmFsc2UgfSkgOiBvcHRpb25zPy5sb2dnZXIgIT09IHRydWUgJiYgb3B0aW9ucz8ubG9nZ2VyID8gb3B0aW9ucy5sb2dnZXIgOiBpbnN0YW50aWF0ZURlZmF1bHRMb2dnZXIoeyB2ZXJib3NlOiBmYWxzZSB9KTtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgIHRoaXMuZGVidWcgPSB0cnVlO1xuICAgIHRoaXMuYXV0aCA9IHZvaWQgMDtcbiAgICB0aGlzLmFkbWluQXV0aCA9IHZvaWQgMDtcbiAgICBpZiAob3B0aW9ucz8uYXV0aCkge1xuICAgICAgdGhpcy5zZXRBdXRoKG9wdGlvbnMuYXV0aCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPYnRhaW4gdGhlIHtAbGluayBDb252ZXhIdHRwQ2xpZW50fSdzIFVSTCB0byBpdHMgYmFja2VuZC5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHVybCwgd2hpY2ggcmV0dXJucyB0aGUgdXJsIHdpdGhvdXQgL2FwaSBhdCB0aGUgZW5kLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgVVJMIHRvIHRoZSBDb252ZXggYmFja2VuZCwgaW5jbHVkaW5nIHRoZSBjbGllbnQncyBBUEkgdmVyc2lvbi5cbiAgICovXG4gIGJhY2tlbmRVcmwoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuYWRkcmVzc30vYXBpYDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBhZGRyZXNzIGZvciB0aGlzIGNsaWVudCwgdXNlZnVsIGZvciBjcmVhdGluZyBhIG5ldyBjbGllbnQuXG4gICAqXG4gICAqIE5vdCBndWFyYW50ZWVkIHRvIG1hdGNoIHRoZSBhZGRyZXNzIHdpdGggd2hpY2ggdGhpcyBjbGllbnQgd2FzIGNvbnN0cnVjdGVkOlxuICAgKiBpdCBtYXkgYmUgY2Fub25pY2FsaXplZC5cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkcmVzcztcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBhdXRoZW50aWNhdGlvbiB0b2tlbiB0byBiZSB1c2VkIGZvciBzdWJzZXF1ZW50IHF1ZXJpZXMgYW5kIG11dGF0aW9ucy5cbiAgICpcbiAgICogU2hvdWxkIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgdG9rZW4gY2hhbmdlcyAoaS5lLiBkdWUgdG8gZXhwaXJhdGlvbiBhbmQgcmVmcmVzaCkuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSAtIEpXVC1lbmNvZGVkIE9wZW5JRCBDb25uZWN0IGlkZW50aXR5IHRva2VuLlxuICAgKi9cbiAgc2V0QXV0aCh2YWx1ZSkge1xuICAgIHRoaXMuY2xlYXJBdXRoKCk7XG4gICAgdGhpcy5hdXRoID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhZG1pbiBhdXRoIHRva2VuIHRvIGFsbG93IGNhbGxpbmcgaW50ZXJuYWwgcXVlcmllcywgbXV0YXRpb25zLCBhbmQgYWN0aW9uc1xuICAgKiBhbmQgYWN0aW5nIGFzIGFuIGlkZW50aXR5LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldEFkbWluQXV0aCh0b2tlbiwgYWN0aW5nQXNJZGVudGl0eSkge1xuICAgIHRoaXMuY2xlYXJBdXRoKCk7XG4gICAgaWYgKGFjdGluZ0FzSWRlbnRpdHkgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoYWN0aW5nQXNJZGVudGl0eSkpO1xuICAgICAgY29uc3QgYWN0aW5nQXNJZGVudGl0eUVuY29kZWQgPSBidG9hKFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmJ5dGVzKSk7XG4gICAgICB0aGlzLmFkbWluQXV0aCA9IGAke3Rva2VufToke2FjdGluZ0FzSWRlbnRpdHlFbmNvZGVkfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRtaW5BdXRoID0gdG9rZW47XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDbGVhciB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiB0b2tlbiBpZiBzZXQuXG4gICAqL1xuICBjbGVhckF1dGgoKSB7XG4gICAgdGhpcy5hdXRoID0gdm9pZCAwO1xuICAgIHRoaXMuYWRtaW5BdXRoID0gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgdGhlIHJlc3VsdCBsb2cgbGluZXMgc2hvdWxkIGJlIHByaW50ZWQgb24gdGhlIGNvbnNvbGUgb3Igbm90LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldERlYnVnKGRlYnVnKSB7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIHRvIGN1c3RvbWl6ZSB0aGUgZmV0Y2ggYmVoYXZpb3IgaW4gc29tZSBydW50aW1lcy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRGZXRjaE9wdGlvbnMoZmV0Y2hPcHRpb25zKSB7XG4gICAgdGhpcy5mZXRjaE9wdGlvbnMgPSBmZXRjaE9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbDogaXQgbWF5IGNoYW5nZSBvciBkaXNhcHBlYXIuXG4gICAqXG4gICAqIEV4ZWN1dGUgYSBDb252ZXggcXVlcnkgZnVuY3Rpb24gYXQgdGhlIHNhbWUgdGltZXN0YW1wIGFzIGV2ZXJ5IG90aGVyXG4gICAqIGNvbnNpc3RlbnQgcXVlcnkgZXhlY3V0aW9uIHJ1biBieSB0aGlzIEhUVFAgY2xpZW50LlxuICAgKlxuICAgKiBUaGlzIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3IgbG9uZy1saXZlZCBDb252ZXhIdHRwQ2xpZW50cyBhcyBDb252ZXhcbiAgICogYmFja2VuZHMgY2FuIHJlYWQgYSBsaW1pdGVkIGFtb3VudCBpbnRvIHRoZSBwYXN0OiBiZXlvbmQgMzAgc2Vjb25kc1xuICAgKiBpbiB0aGUgcGFzdCBtYXkgbm90IGJlIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQ3JlYXRlIGEgbmV3IGNsaWVudCB0byB1c2UgYSBjb25zaXN0ZW50IHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHF1ZXJ5LlxuICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgb2JqZWN0IGZvciB0aGUgcXVlcnkuIElmIHRoaXMgaXMgb21pdHRlZCxcbiAgICogdGhlIGFyZ3VtZW50cyB3aWxsIGJlIGB7fWAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgcXVlcnkncyByZXN1bHQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbDogaXQgbWF5IGNoYW5nZSBvciBkaXNhcHBlYXIuXG4gICAqL1xuICBhc3luYyBjb25zaXN0ZW50UXVlcnkocXVlcnksIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBxdWVyeUFyZ3MgPSBwYXJzZUFyZ3MoYXJnc1swXSk7XG4gICAgY29uc3QgdGltZXN0YW1wUHJvbWlzZSA9IHRoaXMuZ2V0VGltZXN0YW1wKCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucXVlcnlJbm5lcihxdWVyeSwgcXVlcnlBcmdzLCB7IHRpbWVzdGFtcFByb21pc2UgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0VGltZXN0YW1wKCkge1xuICAgIGlmICh0aGlzLmVuY29kZWRUc1Byb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuY29kZWRUc1Byb21pc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVuY29kZWRUc1Byb21pc2UgPSB0aGlzLmdldFRpbWVzdGFtcElubmVyKCk7XG4gIH1cbiAgYXN5bmMgZ2V0VGltZXN0YW1wSW5uZXIoKSB7XG4gICAgY29uc3QgbG9jYWxGZXRjaCA9IHNwZWNpZmllZEZldGNoIHx8IGZldGNoO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIFwiQ29udmV4LUNsaWVudFwiOiBgbnBtLSR7dmVyc2lvbn1gXG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGxvY2FsRmV0Y2goYCR7dGhpcy5hZGRyZXNzfS9hcGkvcXVlcnlfdHNgLCB7XG4gICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGF3YWl0IHJlc3BvbnNlLnRleHQoKSk7XG4gICAgfVxuICAgIGNvbnN0IHsgdHMgfSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gdHM7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBDb252ZXggcXVlcnkgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHF1ZXJ5LlxuICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgb2JqZWN0IGZvciB0aGUgcXVlcnkuIElmIHRoaXMgaXMgb21pdHRlZCxcbiAgICogdGhlIGFyZ3VtZW50cyB3aWxsIGJlIGB7fWAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgcXVlcnkncyByZXN1bHQuXG4gICAqL1xuICBhc3luYyBxdWVyeShxdWVyeSwgLi4uYXJncykge1xuICAgIGNvbnN0IHF1ZXJ5QXJncyA9IHBhcnNlQXJncyhhcmdzWzBdKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5xdWVyeUlubmVyKHF1ZXJ5LCBxdWVyeUFyZ3MsIHt9KTtcbiAgfVxuICBhc3luYyBxdWVyeUlubmVyKHF1ZXJ5LCBxdWVyeUFyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBuYW1lID0gZ2V0RnVuY3Rpb25OYW1lKHF1ZXJ5KTtcbiAgICBjb25zdCBhcmdzID0gW2NvbnZleFRvSnNvbihxdWVyeUFyZ3MpXTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBcIkNvbnZleC1DbGllbnRcIjogYG5wbS0ke3ZlcnNpb259YFxuICAgIH07XG4gICAgaWYgKHRoaXMuYWRtaW5BdXRoKSB7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGBDb252ZXggJHt0aGlzLmFkbWluQXV0aH1gO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hdXRoKSB7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGBCZWFyZXIgJHt0aGlzLmF1dGh9YDtcbiAgICB9XG4gICAgY29uc3QgbG9jYWxGZXRjaCA9IHNwZWNpZmllZEZldGNoIHx8IGZldGNoO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG9wdGlvbnMudGltZXN0YW1wUHJvbWlzZSA/IGF3YWl0IG9wdGlvbnMudGltZXN0YW1wUHJvbWlzZSA6IHZvaWQgMDtcbiAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgcGF0aDogbmFtZSxcbiAgICAgIGZvcm1hdDogXCJjb252ZXhfZW5jb2RlZF9qc29uXCIsXG4gICAgICBhcmdzLFxuICAgICAgLi4udGltZXN0YW1wID8geyB0czogdGltZXN0YW1wIH0gOiB7fVxuICAgIH0pO1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGltZXN0YW1wID8gYCR7dGhpcy5hZGRyZXNzfS9hcGkvcXVlcnlfYXRfdHNgIDogYCR7dGhpcy5hZGRyZXNzfS9hcGkvcXVlcnlgO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbG9jYWxGZXRjaChlbmRwb2ludCwge1xuICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICBib2R5LFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rICYmIHJlc3BvbnNlLnN0YXR1cyAhPT0gU1RBVFVTX0NPREVfVURGX0ZBSUxFRCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGF3YWl0IHJlc3BvbnNlLnRleHQoKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BKU09OID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgcmVzcEpTT04ubG9nTGluZXMgPz8gW10pIHtcbiAgICAgICAgbG9nRm9yRnVuY3Rpb24odGhpcy5sb2dnZXIsIFwiaW5mb1wiLCBcInF1ZXJ5XCIsIG5hbWUsIGxpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHJlc3BKU09OLnN0YXR1cykge1xuICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgcmV0dXJuIGpzb25Ub0NvbnZleChyZXNwSlNPTi52YWx1ZSk7XG4gICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgaWYgKHJlc3BKU09OLmVycm9yRGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgZm9yd2FyZEVycm9yRGF0YShcbiAgICAgICAgICAgIHJlc3BKU09OLmVycm9yRGF0YSxcbiAgICAgICAgICAgIG5ldyBDb252ZXhFcnJvcihyZXNwSlNPTi5lcnJvck1lc3NhZ2UpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcEpTT04uZXJyb3JNZXNzYWdlKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZXNwb25zZTogJHtKU09OLnN0cmluZ2lmeShyZXNwSlNPTil9YCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIG11dGF0aW9uSW5uZXIobXV0YXRpb24sIG11dGF0aW9uQXJncykge1xuICAgIGNvbnN0IG5hbWUgPSBnZXRGdW5jdGlvbk5hbWUobXV0YXRpb24pO1xuICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBwYXRoOiBuYW1lLFxuICAgICAgZm9ybWF0OiBcImNvbnZleF9lbmNvZGVkX2pzb25cIixcbiAgICAgIGFyZ3M6IFtjb252ZXhUb0pzb24obXV0YXRpb25BcmdzKV1cbiAgICB9KTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBcIkNvbnZleC1DbGllbnRcIjogYG5wbS0ke3ZlcnNpb259YFxuICAgIH07XG4gICAgaWYgKHRoaXMuYWRtaW5BdXRoKSB7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGBDb252ZXggJHt0aGlzLmFkbWluQXV0aH1gO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hdXRoKSB7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGBCZWFyZXIgJHt0aGlzLmF1dGh9YDtcbiAgICB9XG4gICAgY29uc3QgbG9jYWxGZXRjaCA9IHNwZWNpZmllZEZldGNoIHx8IGZldGNoO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbG9jYWxGZXRjaChgJHt0aGlzLmFkZHJlc3N9L2FwaS9tdXRhdGlvbmAsIHtcbiAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgYm9keSxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vayAmJiByZXNwb25zZS5zdGF0dXMgIT09IFNUQVRVU19DT0RFX1VERl9GQUlMRUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihhd2FpdCByZXNwb25zZS50ZXh0KCkpO1xuICAgIH1cbiAgICBjb25zdCByZXNwSlNPTiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHJlc3BKU09OLmxvZ0xpbmVzID8/IFtdKSB7XG4gICAgICAgIGxvZ0ZvckZ1bmN0aW9uKHRoaXMubG9nZ2VyLCBcImluZm9cIiwgXCJtdXRhdGlvblwiLCBuYW1lLCBsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChyZXNwSlNPTi5zdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgIHJldHVybiBqc29uVG9Db252ZXgocmVzcEpTT04udmFsdWUpO1xuICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgIGlmIChyZXNwSlNPTi5lcnJvckRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IGZvcndhcmRFcnJvckRhdGEoXG4gICAgICAgICAgICByZXNwSlNPTi5lcnJvckRhdGEsXG4gICAgICAgICAgICBuZXcgQ29udmV4RXJyb3IocmVzcEpTT04uZXJyb3JNZXNzYWdlKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BKU09OLmVycm9yTWVzc2FnZSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVzcG9uc2U6ICR7SlNPTi5zdHJpbmdpZnkocmVzcEpTT04pfWApO1xuICAgIH1cbiAgfVxuICBhc3luYyBwcm9jZXNzTXV0YXRpb25RdWV1ZSgpIHtcbiAgICBpZiAodGhpcy5pc1Byb2Nlc3NpbmdRdWV1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzUHJvY2Vzc2luZ1F1ZXVlID0gdHJ1ZTtcbiAgICB3aGlsZSAodGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHsgbXV0YXRpb24sIGFyZ3MsIHJlc29sdmUsIHJlamVjdCB9ID0gdGhpcy5tdXRhdGlvblF1ZXVlLnNoaWZ0KCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLm11dGF0aW9uSW5uZXIobXV0YXRpb24sIGFyZ3MpO1xuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmlzUHJvY2Vzc2luZ1F1ZXVlID0gZmFsc2U7XG4gIH1cbiAgZW5xdWV1ZU11dGF0aW9uKG11dGF0aW9uLCBhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMubXV0YXRpb25RdWV1ZS5wdXNoKHsgbXV0YXRpb24sIGFyZ3MsIHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgIHZvaWQgdGhpcy5wcm9jZXNzTXV0YXRpb25RdWV1ZSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgQ29udmV4IG11dGF0aW9uIGZ1bmN0aW9uLiBNdXRhdGlvbnMgYXJlIHF1ZXVlZCBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBtdXRhdGlvbi5cbiAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIG11dGF0aW9uLiBJZiB0aGlzIGlzIG9taXR0ZWQsXG4gICAqIHRoZSBhcmd1bWVudHMgd2lsbCBiZSBge31gLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCBjb250YWluaW5nXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgbXV0YXRpb24ncyByZXN1bHQuXG4gICAqL1xuICBhc3luYyBtdXRhdGlvbihtdXRhdGlvbiwgLi4uYXJncykge1xuICAgIGNvbnN0IFtmbkFyZ3MsIG9wdGlvbnNdID0gYXJncztcbiAgICBjb25zdCBtdXRhdGlvbkFyZ3MgPSBwYXJzZUFyZ3MoZm5BcmdzKTtcbiAgICBjb25zdCBxdWV1ZWQgPSAhb3B0aW9ucz8uc2tpcFF1ZXVlO1xuICAgIGlmIChxdWV1ZWQpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVucXVldWVNdXRhdGlvbihtdXRhdGlvbiwgbXV0YXRpb25BcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubXV0YXRpb25Jbm5lcihtdXRhdGlvbiwgbXV0YXRpb25BcmdzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBDb252ZXggYWN0aW9uIGZ1bmN0aW9uLiBBY3Rpb25zIGFyZSBub3QgcXVldWVkLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBhY3Rpb24uXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBvYmplY3QgZm9yIHRoZSBhY3Rpb24uIElmIHRoaXMgaXMgb21pdHRlZCxcbiAgICogdGhlIGFyZ3VtZW50cyB3aWxsIGJlIGB7fWAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgYWN0aW9uJ3MgcmVzdWx0LlxuICAgKi9cbiAgYXN5bmMgYWN0aW9uKGFjdGlvbiwgLi4uYXJncykge1xuICAgIGNvbnN0IGFjdGlvbkFyZ3MgPSBwYXJzZUFyZ3MoYXJnc1swXSk7XG4gICAgY29uc3QgbmFtZSA9IGdldEZ1bmN0aW9uTmFtZShhY3Rpb24pO1xuICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBwYXRoOiBuYW1lLFxuICAgICAgZm9ybWF0OiBcImNvbnZleF9lbmNvZGVkX2pzb25cIixcbiAgICAgIGFyZ3M6IFtjb252ZXhUb0pzb24oYWN0aW9uQXJncyldXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgXCJDb252ZXgtQ2xpZW50XCI6IGBucG0tJHt2ZXJzaW9ufWBcbiAgICB9O1xuICAgIGlmICh0aGlzLmFkbWluQXV0aCkge1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBgQ29udmV4ICR7dGhpcy5hZG1pbkF1dGh9YDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYXV0aCkge1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBgQmVhcmVyICR7dGhpcy5hdXRofWA7XG4gICAgfVxuICAgIGNvbnN0IGxvY2FsRmV0Y2ggPSBzcGVjaWZpZWRGZXRjaCB8fCBmZXRjaDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGxvY2FsRmV0Y2goYCR7dGhpcy5hZGRyZXNzfS9hcGkvYWN0aW9uYCwge1xuICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICBib2R5LFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rICYmIHJlc3BvbnNlLnN0YXR1cyAhPT0gU1RBVFVTX0NPREVfVURGX0ZBSUxFRCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGF3YWl0IHJlc3BvbnNlLnRleHQoKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BKU09OID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgcmVzcEpTT04ubG9nTGluZXMgPz8gW10pIHtcbiAgICAgICAgbG9nRm9yRnVuY3Rpb24odGhpcy5sb2dnZXIsIFwiaW5mb1wiLCBcImFjdGlvblwiLCBuYW1lLCBsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChyZXNwSlNPTi5zdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgIHJldHVybiBqc29uVG9Db252ZXgocmVzcEpTT04udmFsdWUpO1xuICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgIGlmIChyZXNwSlNPTi5lcnJvckRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IGZvcndhcmRFcnJvckRhdGEoXG4gICAgICAgICAgICByZXNwSlNPTi5lcnJvckRhdGEsXG4gICAgICAgICAgICBuZXcgQ29udmV4RXJyb3IocmVzcEpTT04uZXJyb3JNZXNzYWdlKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BKU09OLmVycm9yTWVzc2FnZSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVzcG9uc2U6ICR7SlNPTi5zdHJpbmdpZnkocmVzcEpTT04pfWApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZSBhIENvbnZleCBmdW5jdGlvbiBvZiBhbiB1bmtub3duIHR5cGUuIFRoZXNlIGZ1bmN0aW9uIGNhbGxzIGFyZSBub3QgcXVldWVkLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIGZ1bmN0aW9uLiBJZiB0aGlzIGlzIG9taXR0ZWQsXG4gICAqIHRoZSBhcmd1bWVudHMgd2lsbCBiZSBge31gLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2Ugb2YgdGhlIGZ1bmN0aW9uJ3MgcmVzdWx0LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uKGFueUZ1bmN0aW9uLCBjb21wb25lbnRQYXRoLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgZnVuY3Rpb25BcmdzID0gcGFyc2VBcmdzKGFyZ3NbMF0pO1xuICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgYW55RnVuY3Rpb24gPT09IFwic3RyaW5nXCIgPyBhbnlGdW5jdGlvbiA6IGdldEZ1bmN0aW9uTmFtZShhbnlGdW5jdGlvbik7XG4gICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGNvbXBvbmVudFBhdGgsXG4gICAgICBwYXRoOiBuYW1lLFxuICAgICAgZm9ybWF0OiBcImNvbnZleF9lbmNvZGVkX2pzb25cIixcbiAgICAgIGFyZ3M6IGNvbnZleFRvSnNvbihmdW5jdGlvbkFyZ3MpXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgXCJDb252ZXgtQ2xpZW50XCI6IGBucG0tJHt2ZXJzaW9ufWBcbiAgICB9O1xuICAgIGlmICh0aGlzLmFkbWluQXV0aCkge1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBgQ29udmV4ICR7dGhpcy5hZG1pbkF1dGh9YDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYXV0aCkge1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBgQmVhcmVyICR7dGhpcy5hdXRofWA7XG4gICAgfVxuICAgIGNvbnN0IGxvY2FsRmV0Y2ggPSBzcGVjaWZpZWRGZXRjaCB8fCBmZXRjaDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGxvY2FsRmV0Y2goYCR7dGhpcy5hZGRyZXNzfS9hcGkvZnVuY3Rpb25gLCB7XG4gICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgIGJvZHksXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyc1xuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2sgJiYgcmVzcG9uc2Uuc3RhdHVzICE9PSBTVEFUVVNfQ09ERV9VREZfRkFJTEVEKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcEpTT04gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiByZXNwSlNPTi5sb2dMaW5lcyA/PyBbXSkge1xuICAgICAgICBsb2dGb3JGdW5jdGlvbih0aGlzLmxvZ2dlciwgXCJpbmZvXCIsIFwiYW55XCIsIG5hbWUsIGxpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHJlc3BKU09OLnN0YXR1cykge1xuICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgcmV0dXJuIGpzb25Ub0NvbnZleChyZXNwSlNPTi52YWx1ZSk7XG4gICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgaWYgKHJlc3BKU09OLmVycm9yRGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgZm9yd2FyZEVycm9yRGF0YShcbiAgICAgICAgICAgIHJlc3BKU09OLmVycm9yRGF0YSxcbiAgICAgICAgICAgIG5ldyBDb252ZXhFcnJvcihyZXNwSlNPTi5lcnJvck1lc3NhZ2UpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcEpTT04uZXJyb3JNZXNzYWdlKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZXNwb25zZTogJHtKU09OLnN0cmluZ2lmeShyZXNwSlNPTil9YCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmb3J3YXJkRXJyb3JEYXRhKGVycm9yRGF0YSwgZXJyb3IpIHtcbiAgZXJyb3IuZGF0YSA9IGpzb25Ub0NvbnZleChlcnJvckRhdGEpO1xuICByZXR1cm4gZXJyb3I7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odHRwX2NsaWVudC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX19wdWJsaWNGaWVsZCIsImdldEZ1bmN0aW9uTmFtZSIsInBhcnNlQXJncyIsInZhbGlkYXRlRGVwbG95bWVudFVybCIsInZlcnNpb24iLCJDb252ZXhFcnJvciIsImNvbnZleFRvSnNvbiIsImpzb25Ub0NvbnZleCIsImluc3RhbnRpYXRlRGVmYXVsdExvZ2dlciIsImluc3RhbnRpYXRlTm9vcExvZ2dlciIsImxvZ0ZvckZ1bmN0aW9uIiwiU1RBVFVTX0NPREVfT0siLCJTVEFUVVNfQ09ERV9CQURfUkVRVUVTVCIsIlNUQVRVU19DT0RFX1VERl9GQUlMRUQiLCJzcGVjaWZpZWRGZXRjaCIsInNldEZldGNoIiwiZiIsIkNvbnZleEh0dHBDbGllbnQiLCJiYWNrZW5kVXJsIiwiYWRkcmVzcyIsInVybCIsInNldEF1dGgiLCJjbGVhckF1dGgiLCJhdXRoIiwic2V0QWRtaW5BdXRoIiwidG9rZW4iLCJhY3RpbmdBc0lkZW50aXR5IiwiYnl0ZXMiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJhY3RpbmdBc0lkZW50aXR5RW5jb2RlZCIsImJ0b2EiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50IiwiYWRtaW5BdXRoIiwic2V0RGVidWciLCJkZWJ1ZyIsInNldEZldGNoT3B0aW9ucyIsImZldGNoT3B0aW9ucyIsImNvbnNpc3RlbnRRdWVyeSIsInF1ZXJ5IiwiYXJncyIsInF1ZXJ5QXJncyIsInRpbWVzdGFtcFByb21pc2UiLCJnZXRUaW1lc3RhbXAiLCJxdWVyeUlubmVyIiwiZW5jb2RlZFRzUHJvbWlzZSIsImdldFRpbWVzdGFtcElubmVyIiwibG9jYWxGZXRjaCIsImZldGNoIiwiaGVhZGVycyIsInJlc3BvbnNlIiwibWV0aG9kIiwib2siLCJFcnJvciIsInRleHQiLCJ0cyIsImpzb24iLCJvcHRpb25zIiwibmFtZSIsInRpbWVzdGFtcCIsImJvZHkiLCJwYXRoIiwiZm9ybWF0IiwiZW5kcG9pbnQiLCJzdGF0dXMiLCJyZXNwSlNPTiIsImxpbmUiLCJsb2dMaW5lcyIsImxvZ2dlciIsImVycm9yRGF0YSIsImZvcndhcmRFcnJvckRhdGEiLCJlcnJvck1lc3NhZ2UiLCJtdXRhdGlvbklubmVyIiwibXV0YXRpb24iLCJtdXRhdGlvbkFyZ3MiLCJwcm9jZXNzTXV0YXRpb25RdWV1ZSIsImlzUHJvY2Vzc2luZ1F1ZXVlIiwibXV0YXRpb25RdWV1ZSIsImxlbmd0aCIsInJlc29sdmUiLCJyZWplY3QiLCJzaGlmdCIsInJlc3VsdCIsImVycm9yIiwiZW5xdWV1ZU11dGF0aW9uIiwiUHJvbWlzZSIsInB1c2giLCJmbkFyZ3MiLCJxdWV1ZWQiLCJza2lwUXVldWUiLCJhY3Rpb24iLCJhY3Rpb25BcmdzIiwiZnVuY3Rpb24iLCJhbnlGdW5jdGlvbiIsImNvbXBvbmVudFBhdGgiLCJmdW5jdGlvbkFyZ3MiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJza2lwQ29udmV4RGVwbG95bWVudFVybENoZWNrIiwidmVyYm9zZSIsImRhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/browser/http_client.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/browser/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/convex/dist/esm/browser/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseConvexClient: function() { return /* reexport safe */ _sync_client_js__WEBPACK_IMPORTED_MODULE_0__.BaseConvexClient; },\n/* harmony export */   ConvexClient: function() { return /* reexport safe */ _simple_client_js__WEBPACK_IMPORTED_MODULE_1__.ConvexClient; },\n/* harmony export */   ConvexHttpClient: function() { return /* reexport safe */ _http_client_js__WEBPACK_IMPORTED_MODULE_2__.ConvexHttpClient; }\n/* harmony export */ });\n/* harmony import */ var _sync_client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sync/client.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/client.js\");\n/* harmony import */ var _simple_client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple_client.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/simple_client.js\");\n/* harmony import */ var _http_client_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./http_client.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/http_client.js\");\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUN1QztBQUNGO0FBQ0UsQ0FDcEQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9pbmRleC5qcz81ZjJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0IHsgQmFzZUNvbnZleENsaWVudCB9IGZyb20gXCIuL3N5bmMvY2xpZW50LmpzXCI7XG5leHBvcnQgeyBDb252ZXhDbGllbnQgfSBmcm9tIFwiLi9zaW1wbGVfY2xpZW50LmpzXCI7XG5leHBvcnQgeyBDb252ZXhIdHRwQ2xpZW50IH0gZnJvbSBcIi4vaHR0cF9jbGllbnQuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIkJhc2VDb252ZXhDbGllbnQiLCJDb252ZXhDbGllbnQiLCJDb252ZXhIdHRwQ2xpZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/browser/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/browser/logging.js":
/*!*********************************************************!*\
  !*** ./node_modules/convex/dist/esm/browser/logging.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultLogger: function() { return /* binding */ DefaultLogger; },\n/* harmony export */   createHybridErrorStacktrace: function() { return /* binding */ createHybridErrorStacktrace; },\n/* harmony export */   forwardData: function() { return /* binding */ forwardData; },\n/* harmony export */   instantiateDefaultLogger: function() { return /* binding */ instantiateDefaultLogger; },\n/* harmony export */   instantiateNoopLogger: function() { return /* binding */ instantiateNoopLogger; },\n/* harmony export */   logFatalError: function() { return /* binding */ logFatalError; },\n/* harmony export */   logForFunction: function() { return /* binding */ logForFunction; }\n/* harmony export */ });\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nconst INFO_COLOR = \"color:rgb(0, 145, 255)\";\nfunction prefix_for_source(source) {\n    switch(source){\n        case \"query\":\n            return \"Q\";\n        case \"mutation\":\n            return \"M\";\n        case \"action\":\n            return \"A\";\n        case \"any\":\n            return \"?\";\n    }\n}\nclass DefaultLogger {\n    addLogLineListener(func) {\n        let id = Math.random().toString(36).substring(2, 15);\n        for(let i = 0; i < 10; i++){\n            if (this._onLogLineFuncs[id] === void 0) {\n                break;\n            }\n            id = Math.random().toString(36).substring(2, 15);\n        }\n        this._onLogLineFuncs[id] = func;\n        return ()=>{\n            delete this._onLogLineFuncs[id];\n        };\n    }\n    logVerbose() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (this._verbose) {\n            for (const func of Object.values(this._onLogLineFuncs)){\n                func(\"debug\", \"\".concat(/* @__PURE__ */ new Date().toISOString()), ...args);\n            }\n        }\n    }\n    log() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        for (const func of Object.values(this._onLogLineFuncs)){\n            func(\"info\", ...args);\n        }\n    }\n    warn() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        for (const func of Object.values(this._onLogLineFuncs)){\n            func(\"warn\", ...args);\n        }\n    }\n    error() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        for (const func of Object.values(this._onLogLineFuncs)){\n            func(\"error\", ...args);\n        }\n    }\n    constructor(options){\n        __publicField(this, \"_onLogLineFuncs\");\n        __publicField(this, \"_verbose\");\n        this._onLogLineFuncs = {};\n        this._verbose = options.verbose;\n    }\n}\nfunction instantiateDefaultLogger(options) {\n    const logger = new DefaultLogger(options);\n    logger.addLogLineListener(function(level) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        switch(level){\n            case \"debug\":\n                console.debug(...args);\n                break;\n            case \"info\":\n                console.log(...args);\n                break;\n            case \"warn\":\n                console.warn(...args);\n                break;\n            case \"error\":\n                console.error(...args);\n                break;\n            default:\n                {\n                    level;\n                    console.log(...args);\n                }\n        }\n    });\n    return logger;\n}\nfunction instantiateNoopLogger(options) {\n    return new DefaultLogger(options);\n}\nfunction logForFunction(logger, type, source, udfPath, message) {\n    const prefix = prefix_for_source(source);\n    if (typeof message === \"object\") {\n        message = \"ConvexError \".concat(JSON.stringify(message.errorData, null, 2));\n    }\n    if (type === \"info\") {\n        const match = message.match(/^\\[.*?\\] /);\n        if (match === null) {\n            logger.error(\"[CONVEX \".concat(prefix, \"(\").concat(udfPath, \")] Could not parse console.log\"));\n            return;\n        }\n        const level = message.slice(1, match[0].length - 2);\n        const args = message.slice(match[0].length);\n        logger.log(\"%c[CONVEX \".concat(prefix, \"(\").concat(udfPath, \")] [\").concat(level, \"]\"), INFO_COLOR, args);\n    } else {\n        logger.error(\"[CONVEX \".concat(prefix, \"(\").concat(udfPath, \")] \").concat(message));\n    }\n}\nfunction logFatalError(logger, message) {\n    const errorMessage = \"[CONVEX FATAL ERROR] \".concat(message);\n    logger.error(errorMessage);\n    return new Error(errorMessage);\n}\nfunction createHybridErrorStacktrace(source, udfPath, result) {\n    const prefix = prefix_for_source(source);\n    return \"[CONVEX \".concat(prefix, \"(\").concat(udfPath, \")] \").concat(result.errorMessage, \"\\n  Called by client\");\n}\nfunction forwardData(result, error) {\n    error.data = result.errorData;\n    return error;\n} //# sourceMappingURL=logging.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9sb2dnaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBYTtBQUNiLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsa0JBQWtCLENBQUNDLEtBQUtDLEtBQUtDLFFBQVVELE9BQU9ELE1BQU1KLFVBQVVJLEtBQUtDLEtBQUs7UUFBRUUsWUFBWTtRQUFNQyxjQUFjO1FBQU1DLFVBQVU7UUFBTUg7SUFBTSxLQUFLRixHQUFHLENBQUNDLElBQUksR0FBR0M7QUFDMUosSUFBSUksZ0JBQWdCLENBQUNOLEtBQUtDLEtBQUtDLFFBQVVILGdCQUFnQkMsS0FBSyxPQUFPQyxRQUFRLFdBQVdBLE1BQU0sS0FBS0EsS0FBS0M7QUFDeEcsTUFBTUssYUFBYTtBQUNuQixTQUFTQyxrQkFBa0JDLE1BQU07SUFDL0IsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztJQUNYO0FBQ0Y7QUFDTyxNQUFNQztJQU9YQyxtQkFBbUJDLElBQUksRUFBRTtRQUN2QixJQUFJQyxLQUFLQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxTQUFTLENBQUMsR0FBRztRQUNqRCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO1lBQzNCLElBQUksSUFBSSxDQUFDQyxlQUFlLENBQUNOLEdBQUcsS0FBSyxLQUFLLEdBQUc7Z0JBQ3ZDO1lBQ0Y7WUFDQUEsS0FBS0MsS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDLEdBQUc7UUFDL0M7UUFDQSxJQUFJLENBQUNFLGVBQWUsQ0FBQ04sR0FBRyxHQUFHRDtRQUMzQixPQUFPO1lBQ0wsT0FBTyxJQUFJLENBQUNPLGVBQWUsQ0FBQ04sR0FBRztRQUNqQztJQUNGO0lB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QUFNLEVBQUVRLE9BQU87SUFDM0MsTUFBTVMsZUFBZSx3QkFBZ0MsT0FBUlQ7SUFDN0NSLE9BQU9MLEtBQUssQ0FBQ3NCO0lBQ2IsT0FBTyxJQUFJQyxNQUFNRDtBQUNuQjtBQUNPLFNBQVNFLDRCQUE0QjNDLE1BQU0sRUFBRStCLE9BQU8sRUFBRWEsTUFBTTtJQUNqRSxNQUFNWCxTQUFTbEMsa0JBQWtCQztJQUNqQyxPQUFPLFdBQXFCK0IsT0FBVkUsUUFBTyxLQUFnQlcsT0FBYmIsU0FBUSxPQUF5QixPQUFwQmEsT0FBT0gsWUFBWSxFQUFDO0FBRS9EO0FBQ08sU0FBU0ksWUFBWUQsTUFBTSxFQUFFekIsS0FBSztJQUN2Q0EsTUFBTTJCLElBQUksR0FBR0YsT0FBT1IsU0FBUztJQUM3QixPQUFPakI7QUFDVCxFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL2Jyb3dzZXIvbG9nZ2luZy5qcz81YmUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbmNvbnN0IElORk9fQ09MT1IgPSBcImNvbG9yOnJnYigwLCAxNDUsIDI1NSlcIjtcbmZ1bmN0aW9uIHByZWZpeF9mb3Jfc291cmNlKHNvdXJjZSkge1xuICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgIGNhc2UgXCJxdWVyeVwiOlxuICAgICAgcmV0dXJuIFwiUVwiO1xuICAgIGNhc2UgXCJtdXRhdGlvblwiOlxuICAgICAgcmV0dXJuIFwiTVwiO1xuICAgIGNhc2UgXCJhY3Rpb25cIjpcbiAgICAgIHJldHVybiBcIkFcIjtcbiAgICBjYXNlIFwiYW55XCI6XG4gICAgICByZXR1cm4gXCI/XCI7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBEZWZhdWx0TG9nZ2VyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfb25Mb2dMaW5lRnVuY3NcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl92ZXJib3NlXCIpO1xuICAgIHRoaXMuX29uTG9nTGluZUZ1bmNzID0ge307XG4gICAgdGhpcy5fdmVyYm9zZSA9IG9wdGlvbnMudmVyYm9zZTtcbiAgfVxuICBhZGRMb2dMaW5lTGlzdGVuZXIoZnVuYykge1xuICAgIGxldCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5fb25Mb2dMaW5lRnVuY3NbaWRdID09PSB2b2lkIDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSk7XG4gICAgfVxuICAgIHRoaXMuX29uTG9nTGluZUZ1bmNzW2lkXSA9IGZ1bmM7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9vbkxvZ0xpbmVGdW5jc1tpZF07XG4gICAgfTtcbiAgfVxuICBsb2dWZXJib3NlKC4uLmFyZ3MpIHtcbiAgICBpZiAodGhpcy5fdmVyYm9zZSkge1xuICAgICAgZm9yIChjb25zdCBmdW5jIG9mIE9iamVjdC52YWx1ZXModGhpcy5fb25Mb2dMaW5lRnVuY3MpKSB7XG4gICAgICAgIGZ1bmMoXCJkZWJ1Z1wiLCBgJHsoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCl9YCwgLi4uYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvZyguLi5hcmdzKSB7XG4gICAgZm9yIChjb25zdCBmdW5jIG9mIE9iamVjdC52YWx1ZXModGhpcy5fb25Mb2dMaW5lRnVuY3MpKSB7XG4gICAgICBmdW5jKFwiaW5mb1wiLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cbiAgd2FybiguLi5hcmdzKSB7XG4gICAgZm9yIChjb25zdCBmdW5jIG9mIE9iamVjdC52YWx1ZXModGhpcy5fb25Mb2dMaW5lRnVuY3MpKSB7XG4gICAgICBmdW5jKFwid2FyblwiLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cbiAgZXJyb3IoLi4uYXJncykge1xuICAgIGZvciAoY29uc3QgZnVuYyBvZiBPYmplY3QudmFsdWVzKHRoaXMuX29uTG9nTGluZUZ1bmNzKSkge1xuICAgICAgZnVuYyhcImVycm9yXCIsIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbnRpYXRlRGVmYXVsdExvZ2dlcihvcHRpb25zKSB7XG4gIGNvbnN0IGxvZ2dlciA9IG5ldyBEZWZhdWx0TG9nZ2VyKG9wdGlvbnMpO1xuICBsb2dnZXIuYWRkTG9nTGluZUxpc3RlbmVyKChsZXZlbCwgLi4uYXJncykgPT4ge1xuICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxuICAgICAgICBjb25zb2xlLmRlYnVnKC4uLmFyZ3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbmZvXCI6XG4gICAgICAgIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ3YXJuXCI6XG4gICAgICAgIGNvbnNvbGUud2FybiguLi5hcmdzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgY29uc29sZS5lcnJvciguLi5hcmdzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGxldmVsO1xuICAgICAgICBjb25zb2xlLmxvZyguLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbG9nZ2VyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbnRpYXRlTm9vcExvZ2dlcihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgRGVmYXVsdExvZ2dlcihvcHRpb25zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsb2dGb3JGdW5jdGlvbihsb2dnZXIsIHR5cGUsIHNvdXJjZSwgdWRmUGF0aCwgbWVzc2FnZSkge1xuICBjb25zdCBwcmVmaXggPSBwcmVmaXhfZm9yX3NvdXJjZShzb3VyY2UpO1xuICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICBtZXNzYWdlID0gYENvbnZleEVycm9yICR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZS5lcnJvckRhdGEsIG51bGwsIDIpfWA7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiaW5mb1wiKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBtZXNzYWdlLm1hdGNoKC9eXFxbLio/XFxdIC8pO1xuICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICBgW0NPTlZFWCAke3ByZWZpeH0oJHt1ZGZQYXRofSldIENvdWxkIG5vdCBwYXJzZSBjb25zb2xlLmxvZ2BcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxldmVsID0gbWVzc2FnZS5zbGljZSgxLCBtYXRjaFswXS5sZW5ndGggLSAyKTtcbiAgICBjb25zdCBhcmdzID0gbWVzc2FnZS5zbGljZShtYXRjaFswXS5sZW5ndGgpO1xuICAgIGxvZ2dlci5sb2coYCVjW0NPTlZFWCAke3ByZWZpeH0oJHt1ZGZQYXRofSldIFske2xldmVsfV1gLCBJTkZPX0NPTE9SLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBsb2dnZXIuZXJyb3IoYFtDT05WRVggJHtwcmVmaXh9KCR7dWRmUGF0aH0pXSAke21lc3NhZ2V9YCk7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBsb2dGYXRhbEVycm9yKGxvZ2dlciwgbWVzc2FnZSkge1xuICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgW0NPTlZFWCBGQVRBTCBFUlJPUl0gJHttZXNzYWdlfWA7XG4gIGxvZ2dlci5lcnJvcihlcnJvck1lc3NhZ2UpO1xuICByZXR1cm4gbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSHlicmlkRXJyb3JTdGFja3RyYWNlKHNvdXJjZSwgdWRmUGF0aCwgcmVzdWx0KSB7XG4gIGNvbnN0IHByZWZpeCA9IHByZWZpeF9mb3Jfc291cmNlKHNvdXJjZSk7XG4gIHJldHVybiBgW0NPTlZFWCAke3ByZWZpeH0oJHt1ZGZQYXRofSldICR7cmVzdWx0LmVycm9yTWVzc2FnZX1cbiAgQ2FsbGVkIGJ5IGNsaWVudGA7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZERhdGEocmVzdWx0LCBlcnJvcikge1xuICBlcnJvci5kYXRhID0gcmVzdWx0LmVycm9yRGF0YTtcbiAgcmV0dXJuIGVycm9yO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX19wdWJsaWNGaWVsZCIsIklORk9fQ09MT1IiLCJwcmVmaXhfZm9yX3NvdXJjZSIsInNvdXJjZSIsIkRlZmF1bHRMb2dnZXIiLCJhZGRMb2dMaW5lTGlzdGVuZXIiLCJmdW5jIiwiaWQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJpIiwiX29uTG9nTGluZUZ1bmNzIiwibG9nVmVyYm9zZSIsImFyZ3MiLCJfdmVyYm9zZSIsInZhbHVlcyIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImxvZyIsIndhcm4iLCJlcnJvciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsInZlcmJvc2UiLCJpbnN0YW50aWF0ZURlZmF1bHRMb2dnZXIiLCJsb2dnZXIiLCJsZXZlbCIsImNvbnNvbGUiLCJkZWJ1ZyIsImluc3RhbnRpYXRlTm9vcExvZ2dlciIsImxvZ0ZvckZ1bmN0aW9uIiwidHlwZSIsInVkZlBhdGgiLCJtZXNzYWdlIiwicHJlZml4IiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yRGF0YSIsIm1hdGNoIiwic2xpY2UiLCJsZW5ndGgiLCJsb2dGYXRhbEVycm9yIiwiZXJyb3JNZXNzYWdlIiwiRXJyb3IiLCJjcmVhdGVIeWJyaWRFcnJvclN0YWNrdHJhY2UiLCJyZXN1bHQiLCJmb3J3YXJkRGF0YSIsImRhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/browser/logging.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/browser/simple_client.js":
/*!***************************************************************!*\
  !*** ./node_modules/convex/dist/esm/browser/simple_client.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConvexClient: function() { return /* binding */ ConvexClient; },\n/* harmony export */   setDefaultWebSocketConstructor: function() { return /* binding */ setDefaultWebSocketConstructor; }\n/* harmony export */ });\n/* harmony import */ var _common_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/common/index.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/index.js\");\n/* harmony import */ var _server_api_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../server/api.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/server/api.js\");\n/* harmony import */ var _sync_paginated_query_client_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sync/paginated_query_client.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/paginated_query_client.js\");\n/* harmony import */ var _sync_udf_path_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sync/udf_path_utils.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/udf_path_utils.js\");\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n\n\n\n\nlet defaultWebSocketConstructor;\nfunction setDefaultWebSocketConstructor(ws) {\n    defaultWebSocketConstructor = ws;\n}\nclass ConvexClient {\n    /**\n   * Once closed no registered callbacks will fire again.\n   */ get closed() {\n        return this._closed;\n    }\n    get client() {\n        if (this._client) return this._client;\n        throw new Error(\"ConvexClient is disabled\");\n    }\n    /**\n   * @internal\n   */ get paginatedClient() {\n        if (this._paginatedClient) return this._paginatedClient;\n        throw new Error(\"ConvexClient is disabled\");\n    }\n    get disabled() {\n        return this._disabled;\n    }\n    /**\n   * Call a callback whenever a new result for a query is received. The callback\n   * will run soon after being registered if a result for the query is already\n   * in memory.\n   *\n   * The return value is an {@link Unsubscribe} object which is both a function\n   * an an object with properties. Both of the patterns below work with this object:\n   *\n   *```ts\n   * // call the return value as a function\n   * const unsubscribe = client.onUpdate(api.messages.list, {}, (messages) => {\n   *   console.log(messages);\n   * });\n   * unsubscribe();\n   *\n   * // unpack the return value into its properties\n   * const {\n   *   getCurrentValue,\n   *   unsubscribe,\n   * } = client.onUpdate(api.messages.list, {}, (messages) => {\n   *   console.log(messages);\n   * });\n   *```\n   *\n   * @param query - A {@link server.FunctionReference} for the public query to run.\n   * @param args - The arguments to run the query with.\n   * @param callback - Function to call when the query result updates.\n   * @param onError - Function to call when the query result updates with an error.\n   * If not provided, errors will be thrown instead of calling the callback.\n   *\n   * @return an {@link Unsubscribe} function to stop calling the onUpdate function.\n   */ onUpdate(query, args, callback, onError) {\n        if (this.disabled) {\n            return this.createDisabledUnsubscribe();\n        }\n        const { queryToken, unsubscribe } = this.client.subscribe((0,_server_api_js__WEBPACK_IMPORTED_MODULE_2__.getFunctionName)(query), args);\n        const queryInfo = {\n            queryToken,\n            callback,\n            onError,\n            unsubscribe,\n            hasEverRun: false,\n            query,\n            args,\n            paginationOptions: void 0\n        };\n        this.listeners.add(queryInfo);\n        if (this.queryResultReady(queryToken) && this.callNewListenersWithCurrentValuesTimer === void 0) {\n            this.callNewListenersWithCurrentValuesTimer = setTimeout(()=>this.callNewListenersWithCurrentValues(), 0);\n        }\n        const unsubscribeProps = {\n            unsubscribe: ()=>{\n                if (this.closed) {\n                    return;\n                }\n                this.listeners.delete(queryInfo);\n                unsubscribe();\n            },\n            getCurrentValue: ()=>this.client.localQueryResultByToken(queryToken),\n            getQueryLogs: ()=>this.client.localQueryLogs(queryToken)\n        };\n        const ret = unsubscribeProps.unsubscribe;\n        Object.assign(ret, unsubscribeProps);\n        return ret;\n    }\n    /**\n   * Call a callback whenever a new result for a paginated query is received.\n   *\n   * This is an experimental preview: the final API may change.\n   * In particular, caching behavior, page splitting, and required paginated query options\n   * may change.\n   *\n   * @param query - A {@link server.FunctionReference} for the public query to run.\n   * @param args - The arguments to run the query with.\n   * @param options - Options for the paginated query including initialNumItems and id.\n   * @param callback - Function to call when the query result updates.\n   * @param onError - Function to call when the query result updates with an error.\n   *\n   * @return an {@link Unsubscribe} function to stop calling the callback.\n   */ onPaginatedUpdate_experimental(query, args, options, callback, onError) {\n        if (this.disabled) {\n            return this.createDisabledUnsubscribe();\n        }\n        const paginationOptions = {\n            initialNumItems: options.initialNumItems,\n            id: -1\n        };\n        const { paginatedQueryToken, unsubscribe } = this.paginatedClient.subscribe((0,_server_api_js__WEBPACK_IMPORTED_MODULE_2__.getFunctionName)(query), args, // Simple client doesn't use IDs, there's no expectation that these queries remain separate.\n        paginationOptions);\n        const queryInfo = {\n            queryToken: paginatedQueryToken,\n            callback,\n            onError,\n            unsubscribe,\n            hasEverRun: false,\n            query,\n            args,\n            paginationOptions\n        };\n        this.listeners.add(queryInfo);\n        if (!!this.paginatedClient.localQueryResultByToken(paginatedQueryToken) && this.callNewListenersWithCurrentValuesTimer === void 0) {\n            this.callNewListenersWithCurrentValuesTimer = setTimeout(()=>this.callNewListenersWithCurrentValues(), 0);\n        }\n        const unsubscribeProps = {\n            unsubscribe: ()=>{\n                if (this.closed) {\n                    return;\n                }\n                this.listeners.delete(queryInfo);\n                unsubscribe();\n            },\n            getCurrentValue: ()=>{\n                const result = this.paginatedClient.localQueryResult((0,_server_api_js__WEBPACK_IMPORTED_MODULE_2__.getFunctionName)(query), args, paginationOptions);\n                return result;\n            },\n            getQueryLogs: ()=>[]\n        };\n        const ret = unsubscribeProps.unsubscribe;\n        Object.assign(ret, unsubscribeProps);\n        return ret;\n    }\n    // Run all callbacks that have never been run before if they have a query\n    // result available now.\n    callNewListenersWithCurrentValues() {\n        this.callNewListenersWithCurrentValuesTimer = void 0;\n        this._transition({\n            queries: [],\n            paginatedQueries: []\n        }, true);\n    }\n    queryResultReady(queryToken) {\n        return this.client.hasLocalQueryResultByToken(queryToken);\n    }\n    createDisabledUnsubscribe() {\n        const disabledUnsubscribe = ()=>{};\n        const unsubscribeProps = {\n            unsubscribe: disabledUnsubscribe,\n            getCurrentValue: ()=>void 0,\n            getQueryLogs: ()=>void 0\n        };\n        Object.assign(disabledUnsubscribe, unsubscribeProps);\n        return disabledUnsubscribe;\n    }\n    async close() {\n        if (this.disabled) return;\n        this.listeners.clear();\n        this._closed = true;\n        if (this._paginatedClient) {\n            this._paginatedClient = void 0;\n        }\n        return this.client.close();\n    }\n    /**\n   * Get the current JWT auth token and decoded claims.\n   */ getAuth() {\n        if (this.disabled) return;\n        return this.client.getCurrentAuthClaims();\n    }\n    /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   * `fetchToken` will be called automatically again if a token expires.\n   * `fetchToken` should return `null` if the token cannot be retrieved, for example\n   * when the user's rights were permanently revoked.\n   * @param fetchToken - an async function returning the JWT (typically an OpenID Connect Identity Token)\n   * @param onChange - a callback that will be called when the authentication status changes\n   */ setAuth(fetchToken, onChange) {\n        if (this.disabled) return;\n        this.client.setAuth(fetchToken, onChange !== null && onChange !== void 0 ? onChange : ()=>{});\n    }\n    /**\n   * @internal\n   */ setAdminAuth(token, identity) {\n        if (this.closed) {\n            throw new Error(\"ConvexClient has already been closed.\");\n        }\n        if (this.disabled) return;\n        this.client.setAdminAuth(token, identity);\n    }\n    /**\n   * @internal\n   */ _transition(param) {\n        let { queries, paginatedQueries } = param, callNewListeners = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        const updatedQueries = [\n            ...queries.map((q)=>q.token),\n            ...paginatedQueries.map((q)=>q.token)\n        ];\n        for (const queryInfo of this.listeners){\n            const { callback, queryToken, onError, hasEverRun } = queryInfo;\n            const isPaginatedQuery = (0,_sync_udf_path_utils_js__WEBPACK_IMPORTED_MODULE_4__.serializedQueryTokenIsPaginated)(queryToken);\n            const hasResultReady = isPaginatedQuery ? !!this.paginatedClient.localQueryResultByToken(queryToken) : this.client.hasLocalQueryResultByToken(queryToken);\n            if (updatedQueries.includes(queryToken) || callNewListeners && !hasEverRun && hasResultReady) {\n                queryInfo.hasEverRun = true;\n                let newValue;\n                try {\n                    if (isPaginatedQuery) {\n                        newValue = this.paginatedClient.localQueryResultByToken(queryToken);\n                    } else {\n                        newValue = this.client.localQueryResultByToken(queryToken);\n                    }\n                } catch (error) {\n                    if (!(error instanceof Error)) throw error;\n                    if (onError) {\n                        onError(error, \"Second argument to onUpdate onError is reserved for later use\");\n                    } else {\n                        void Promise.reject(error);\n                    }\n                    continue;\n                }\n                callback(newValue, \"Second argument to onUpdate callback is reserved for later use\");\n            }\n        }\n    }\n    /**\n   * Execute a mutation function.\n   *\n   * @param mutation - A {@link server.FunctionReference} for the public mutation\n   * to run.\n   * @param args - An arguments object for the mutation.\n   * @param options - A {@link MutationOptions} options object for the mutation.\n   * @returns A promise of the mutation's result.\n   */ async mutation(mutation, args, options) {\n        if (this.disabled) throw new Error(\"ConvexClient is disabled\");\n        return await this.client.mutation((0,_server_api_js__WEBPACK_IMPORTED_MODULE_2__.getFunctionName)(mutation), args, options);\n    }\n    /**\n   * Execute an action function.\n   *\n   * @param action - A {@link server.FunctionReference} for the public action\n   * to run.\n   * @param args - An arguments object for the action.\n   * @returns A promise of the action's result.\n   */ async action(action, args) {\n        if (this.disabled) throw new Error(\"ConvexClient is disabled\");\n        return await this.client.action((0,_server_api_js__WEBPACK_IMPORTED_MODULE_2__.getFunctionName)(action), args);\n    }\n    /**\n   * Fetch a query result once.\n   *\n   * @param query - A {@link server.FunctionReference} for the public query\n   * to run.\n   * @param args - An arguments object for the query.\n   * @returns A promise of the query's result.\n   */ async query(query, args) {\n        if (this.disabled) throw new Error(\"ConvexClient is disabled\");\n        const value = this.client.localQueryResult((0,_server_api_js__WEBPACK_IMPORTED_MODULE_2__.getFunctionName)(query), args);\n        if (value !== void 0) return Promise.resolve(value);\n        return new Promise((resolve, reject)=>{\n            const { unsubscribe } = this.onUpdate(query, args, (value2)=>{\n                unsubscribe();\n                resolve(value2);\n            }, (e)=>{\n                unsubscribe();\n                reject(e);\n            });\n        });\n    }\n    /**\n   * Get the current {@link ConnectionState} between the client and the Convex\n   * backend.\n   *\n   * @returns The {@link ConnectionState} with the Convex backend.\n   */ connectionState() {\n        if (this.disabled) throw new Error(\"ConvexClient is disabled\");\n        return this.client.connectionState();\n    }\n    /**\n   * Subscribe to the {@link ConnectionState} between the client and the Convex\n   * backend, calling a callback each time it changes.\n   *\n   * Subscribed callbacks will be called when any part of ConnectionState changes.\n   * ConnectionState may grow in future versions (e.g. to provide a array of\n   * inflight requests) in which case callbacks would be called more frequently.\n   *\n   * @returns An unsubscribe function to stop listening.\n   */ subscribeToConnectionState(cb) {\n        if (this.disabled) return ()=>{};\n        return this.client.subscribeToConnectionState(cb);\n    }\n    /**\n   * Construct a client and immediately initiate a WebSocket connection to the passed address.\n   *\n   * @public\n   */ constructor(address, options = {}){\n        __publicField(this, \"listeners\");\n        __publicField(this, \"_client\");\n        __publicField(this, \"_paginatedClient\");\n        // A synthetic server event to run callbacks the first time\n        __publicField(this, \"callNewListenersWithCurrentValuesTimer\");\n        __publicField(this, \"_closed\");\n        __publicField(this, \"_disabled\");\n        if (options.skipConvexDeploymentUrlCheck !== true) {\n            (0,_common_index_js__WEBPACK_IMPORTED_MODULE_0__.validateDeploymentUrl)(address);\n        }\n        const { disabled, ...baseOptions } = options;\n        this._closed = false;\n        this._disabled = !!disabled;\n        if (defaultWebSocketConstructor && !(\"webSocketConstructor\" in baseOptions) && typeof WebSocket === \"undefined\") {\n            baseOptions.webSocketConstructor = defaultWebSocketConstructor;\n        }\n        if (false) {}\n        if (!this.disabled) {\n            this._client = new _index_js__WEBPACK_IMPORTED_MODULE_1__.BaseConvexClient(address, ()=>{}, // NOP, let the paginated query client do it all\n            baseOptions);\n            this._paginatedClient = new _sync_paginated_query_client_js__WEBPACK_IMPORTED_MODULE_3__.PaginatedQueryClient(this._client, (transition)=>this._transition(transition));\n        }\n        this.listeners = /* @__PURE__ */ new Set();\n    }\n} //# sourceMappingURL=simple_client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zaW1wbGVfY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBYTtBQUNiLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsa0JBQWtCLENBQUNDLEtBQUtDLEtBQUtDLFFBQVVELE9BQU9ELE1BQU1KLFVBQVVJLEtBQUtDLEtBQUs7UUFBRUUsWUFBWTtRQUFNQyxjQUFjO1FBQU1DLFVBQVU7UUFBTUg7SUFBTSxLQUFLRixHQUFHLENBQUNDLElBQUksR0FBR0M7QUFDMUosSUFBSUksZ0JBQWdCLENBQUNOLEtBQUtDLEtBQUtDLFFBQVVILGdCQUFnQkMsS0FBSyxPQUFPQyxRQUFRLFdBQVdBLE1BQU0sS0FBS0EsS0FBS0M7QUFDN0M7QUFHdkM7QUFDK0I7QUFHVDtBQUNpQztBQUMzRSxJQUFJVTtBQUNHLFNBQVNDLCtCQUErQkMsRUFBRTtJQUMvQ0YsOEJBQThCRTtBQUNoQztBQUNPLE1BQU1DO0lBeUNYOztHQUVDLEdBQ0QsSUFBSUMsU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDQyxPQUFPO0lBQ3JCO0lBQ0EsSUFBSUMsU0FBUztRQUNYLElBQUksSUFBSSxDQUFDQyxPQUFPLEVBQUUsT0FBTyxJQUFJLENBQUNBLE9BQU87UUFDckMsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBQ0E7O0dBRUMsR0FDRCxJQUFJQyxrQkFBa0I7UUFDcEIsSUFBSSxJQUFJLENBQUNDLGdCQUFnQixFQUFFLE9BQU8sSUFBSSxDQUFDQSxnQkFBZ0I7UUFDdkQsTUFBTSxJQUFJRixNQUFNO0lBQ2xCO0lBQ0EsSUFBSUcsV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDQyxTQUFTO0lBQ3ZCO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErQkMsR0FDREMsU0FBU0MsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFO1FB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LEtBQ0EsR0FDQSxnREFBZ0Q7WUFDaERFO1lBRUYsSUFBSSxDQUFDekUsZ0JBQWdCLEdBQUcsSUFBSVosaUZBQW9CQSxDQUM5QyxJQUFJLENBQUNTLE9BQU8sRUFDWixDQUFDZ0YsYUFBZSxJQUFJLENBQUN6QyxXQUFXLENBQUN5QztRQUVyQztRQUNBLElBQUksQ0FBQzlELFNBQVMsR0FBRyxhQUFhLEdBQUcsSUFBSStEO0lBQ3ZDO0FBd1ZGLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zaW1wbGVfY2xpZW50LmpzPzMyM2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuaW1wb3J0IHsgdmFsaWRhdGVEZXBsb3ltZW50VXJsIH0gZnJvbSBcIi4uL2NvbW1vbi9pbmRleC5qc1wiO1xuaW1wb3J0IHtcbiAgQmFzZUNvbnZleENsaWVudFxufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0RnVuY3Rpb25OYW1lIH0gZnJvbSBcIi4uL3NlcnZlci9hcGkuanNcIjtcbmltcG9ydCB7XG4gIFBhZ2luYXRlZFF1ZXJ5Q2xpZW50XG59IGZyb20gXCIuL3N5bmMvcGFnaW5hdGVkX3F1ZXJ5X2NsaWVudC5qc1wiO1xuaW1wb3J0IHsgc2VyaWFsaXplZFF1ZXJ5VG9rZW5Jc1BhZ2luYXRlZCB9IGZyb20gXCIuL3N5bmMvdWRmX3BhdGhfdXRpbHMuanNcIjtcbmxldCBkZWZhdWx0V2ViU29ja2V0Q29uc3RydWN0b3I7XG5leHBvcnQgZnVuY3Rpb24gc2V0RGVmYXVsdFdlYlNvY2tldENvbnN0cnVjdG9yKHdzKSB7XG4gIGRlZmF1bHRXZWJTb2NrZXRDb25zdHJ1Y3RvciA9IHdzO1xufVxuZXhwb3J0IGNsYXNzIENvbnZleENsaWVudCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBjbGllbnQgYW5kIGltbWVkaWF0ZWx5IGluaXRpYXRlIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIHBhc3NlZCBhZGRyZXNzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBvcHRpb25zID0ge30pIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibGlzdGVuZXJzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfY2xpZW50XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcGFnaW5hdGVkQ2xpZW50XCIpO1xuICAgIC8vIEEgc3ludGhldGljIHNlcnZlciBldmVudCB0byBydW4gY2FsbGJhY2tzIHRoZSBmaXJzdCB0aW1lXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNhbGxOZXdMaXN0ZW5lcnNXaXRoQ3VycmVudFZhbHVlc1RpbWVyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfY2xvc2VkXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZGlzYWJsZWRcIik7XG4gICAgaWYgKG9wdGlvbnMuc2tpcENvbnZleERlcGxveW1lbnRVcmxDaGVjayAhPT0gdHJ1ZSkge1xuICAgICAgdmFsaWRhdGVEZXBsb3ltZW50VXJsKGFkZHJlc3MpO1xuICAgIH1cbiAgICBjb25zdCB7IGRpc2FibGVkLCAuLi5iYXNlT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kaXNhYmxlZCA9ICEhZGlzYWJsZWQ7XG4gICAgaWYgKGRlZmF1bHRXZWJTb2NrZXRDb25zdHJ1Y3RvciAmJiAhKFwid2ViU29ja2V0Q29uc3RydWN0b3JcIiBpbiBiYXNlT3B0aW9ucykgJiYgdHlwZW9mIFdlYlNvY2tldCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgYmFzZU9wdGlvbnMud2ViU29ja2V0Q29uc3RydWN0b3IgPSBkZWZhdWx0V2ViU29ja2V0Q29uc3RydWN0b3I7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiICYmICEoXCJ1bnNhdmVkQ2hhbmdlc1dhcm5pbmdcIiBpbiBiYXNlT3B0aW9ucykpIHtcbiAgICAgIGJhc2VPcHRpb25zLnVuc2F2ZWRDaGFuZ2VzV2FybmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuX2NsaWVudCA9IG5ldyBCYXNlQ29udmV4Q2xpZW50KFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE5PUCwgbGV0IHRoZSBwYWdpbmF0ZWQgcXVlcnkgY2xpZW50IGRvIGl0IGFsbFxuICAgICAgICBiYXNlT3B0aW9uc1xuICAgICAgKTtcbiAgICAgIHRoaXMuX3BhZ2luYXRlZENsaWVudCA9IG5ldyBQYWdpbmF0ZWRRdWVyeUNsaWVudChcbiAgICAgICAgdGhpcy5fY2xpZW50LFxuICAgICAgICAodHJhbnNpdGlvbikgPT4gdGhpcy5fdHJhbnNpdGlvbih0cmFuc2l0aW9uKVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG4gIC8qKlxuICAgKiBPbmNlIGNsb3NlZCBubyByZWdpc3RlcmVkIGNhbGxiYWNrcyB3aWxsIGZpcmUgYWdhaW4uXG4gICAqL1xuICBnZXQgY2xvc2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9jbG9zZWQ7XG4gIH1cbiAgZ2V0IGNsaWVudCgpIHtcbiAgICBpZiAodGhpcy5fY2xpZW50KSByZXR1cm4gdGhpcy5fY2xpZW50O1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnZleENsaWVudCBpcyBkaXNhYmxlZFwiKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgcGFnaW5hdGVkQ2xpZW50KCkge1xuICAgIGlmICh0aGlzLl9wYWdpbmF0ZWRDbGllbnQpIHJldHVybiB0aGlzLl9wYWdpbmF0ZWRDbGllbnQ7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udmV4Q2xpZW50IGlzIGRpc2FibGVkXCIpO1xuICB9XG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYSBjYWxsYmFjayB3aGVuZXZlciBhIG5ldyByZXN1bHQgZm9yIGEgcXVlcnkgaXMgcmVjZWl2ZWQuIFRoZSBjYWxsYmFja1xuICAgKiB3aWxsIHJ1biBzb29uIGFmdGVyIGJlaW5nIHJlZ2lzdGVyZWQgaWYgYSByZXN1bHQgZm9yIHRoZSBxdWVyeSBpcyBhbHJlYWR5XG4gICAqIGluIG1lbW9yeS5cbiAgICpcbiAgICogVGhlIHJldHVybiB2YWx1ZSBpcyBhbiB7QGxpbmsgVW5zdWJzY3JpYmV9IG9iamVjdCB3aGljaCBpcyBib3RoIGEgZnVuY3Rpb25cbiAgICogYW4gYW4gb2JqZWN0IHdpdGggcHJvcGVydGllcy4gQm90aCBvZiB0aGUgcGF0dGVybnMgYmVsb3cgd29yayB3aXRoIHRoaXMgb2JqZWN0OlxuICAgKlxuICAgKmBgYHRzXG4gICAqIC8vIGNhbGwgdGhlIHJldHVybiB2YWx1ZSBhcyBhIGZ1bmN0aW9uXG4gICAqIGNvbnN0IHVuc3Vic2NyaWJlID0gY2xpZW50Lm9uVXBkYXRlKGFwaS5tZXNzYWdlcy5saXN0LCB7fSwgKG1lc3NhZ2VzKSA9PiB7XG4gICAqICAgY29uc29sZS5sb2cobWVzc2FnZXMpO1xuICAgKiB9KTtcbiAgICogdW5zdWJzY3JpYmUoKTtcbiAgICpcbiAgICogLy8gdW5wYWNrIHRoZSByZXR1cm4gdmFsdWUgaW50byBpdHMgcHJvcGVydGllc1xuICAgKiBjb25zdCB7XG4gICAqICAgZ2V0Q3VycmVudFZhbHVlLFxuICAgKiAgIHVuc3Vic2NyaWJlLFxuICAgKiB9ID0gY2xpZW50Lm9uVXBkYXRlKGFwaS5tZXNzYWdlcy5saXN0LCB7fSwgKG1lc3NhZ2VzKSA9PiB7XG4gICAqICAgY29uc29sZS5sb2cobWVzc2FnZXMpO1xuICAgKiB9KTtcbiAgICpgYGBcbiAgICpcbiAgICogQHBhcmFtIHF1ZXJ5IC0gQSB7QGxpbmsgc2VydmVyLkZ1bmN0aW9uUmVmZXJlbmNlfSBmb3IgdGhlIHB1YmxpYyBxdWVyeSB0byBydW4uXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBydW4gdGhlIHF1ZXJ5IHdpdGguXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgcXVlcnkgcmVzdWx0IHVwZGF0ZXMuXG4gICAqIEBwYXJhbSBvbkVycm9yIC0gRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBxdWVyeSByZXN1bHQgdXBkYXRlcyB3aXRoIGFuIGVycm9yLlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIGVycm9ycyB3aWxsIGJlIHRocm93biBpbnN0ZWFkIG9mIGNhbGxpbmcgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIGFuIHtAbGluayBVbnN1YnNjcmliZX0gZnVuY3Rpb24gdG8gc3RvcCBjYWxsaW5nIHRoZSBvblVwZGF0ZSBmdW5jdGlvbi5cbiAgICovXG4gIG9uVXBkYXRlKHF1ZXJ5LCBhcmdzLCBjYWxsYmFjaywgb25FcnJvcikge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVEaXNhYmxlZFVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGNvbnN0IHsgcXVlcnlUb2tlbiwgdW5zdWJzY3JpYmUgfSA9IHRoaXMuY2xpZW50LnN1YnNjcmliZShcbiAgICAgIGdldEZ1bmN0aW9uTmFtZShxdWVyeSksXG4gICAgICBhcmdzXG4gICAgKTtcbiAgICBjb25zdCBxdWVyeUluZm8gPSB7XG4gICAgICBxdWVyeVRva2VuLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBvbkVycm9yLFxuICAgICAgdW5zdWJzY3JpYmUsXG4gICAgICBoYXNFdmVyUnVuOiBmYWxzZSxcbiAgICAgIHF1ZXJ5LFxuICAgICAgYXJncyxcbiAgICAgIHBhZ2luYXRpb25PcHRpb25zOiB2b2lkIDBcbiAgICB9O1xuICAgIHRoaXMubGlzdGVuZXJzLmFkZChxdWVyeUluZm8pO1xuICAgIGlmICh0aGlzLnF1ZXJ5UmVzdWx0UmVhZHkocXVlcnlUb2tlbikgJiYgdGhpcy5jYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXNUaW1lciA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmNhbGxOZXdMaXN0ZW5lcnNXaXRoQ3VycmVudFZhbHVlc1RpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgKCkgPT4gdGhpcy5jYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXMoKSxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdW5zdWJzY3JpYmVQcm9wcyA9IHtcbiAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUocXVlcnlJbmZvKTtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIH0sXG4gICAgICBnZXRDdXJyZW50VmFsdWU6ICgpID0+IHRoaXMuY2xpZW50LmxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHF1ZXJ5VG9rZW4pLFxuICAgICAgZ2V0UXVlcnlMb2dzOiAoKSA9PiB0aGlzLmNsaWVudC5sb2NhbFF1ZXJ5TG9ncyhxdWVyeVRva2VuKVxuICAgIH07XG4gICAgY29uc3QgcmV0ID0gdW5zdWJzY3JpYmVQcm9wcy51bnN1YnNjcmliZTtcbiAgICBPYmplY3QuYXNzaWduKHJldCwgdW5zdWJzY3JpYmVQcm9wcyk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBhIGNhbGxiYWNrIHdoZW5ldmVyIGEgbmV3IHJlc3VsdCBmb3IgYSBwYWdpbmF0ZWQgcXVlcnkgaXMgcmVjZWl2ZWQuXG4gICAqXG4gICAqIFRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIHByZXZpZXc6IHRoZSBmaW5hbCBBUEkgbWF5IGNoYW5nZS5cbiAgICogSW4gcGFydGljdWxhciwgY2FjaGluZyBiZWhhdmlvciwgcGFnZSBzcGxpdHRpbmcsIGFuZCByZXF1aXJlZCBwYWdpbmF0ZWQgcXVlcnkgb3B0aW9uc1xuICAgKiBtYXkgY2hhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0gcXVlcnkgLSBBIHtAbGluayBzZXJ2ZXIuRnVuY3Rpb25SZWZlcmVuY2V9IGZvciB0aGUgcHVibGljIHF1ZXJ5IHRvIHJ1bi5cbiAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHJ1biB0aGUgcXVlcnkgd2l0aC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgcGFnaW5hdGVkIHF1ZXJ5IGluY2x1ZGluZyBpbml0aWFsTnVtSXRlbXMgYW5kIGlkLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHF1ZXJ5IHJlc3VsdCB1cGRhdGVzLlxuICAgKiBAcGFyYW0gb25FcnJvciAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgcXVlcnkgcmVzdWx0IHVwZGF0ZXMgd2l0aCBhbiBlcnJvci5cbiAgICpcbiAgICogQHJldHVybiBhbiB7QGxpbmsgVW5zdWJzY3JpYmV9IGZ1bmN0aW9uIHRvIHN0b3AgY2FsbGluZyB0aGUgY2FsbGJhY2suXG4gICAqL1xuICBvblBhZ2luYXRlZFVwZGF0ZV9leHBlcmltZW50YWwocXVlcnksIGFyZ3MsIG9wdGlvbnMsIGNhbGxiYWNrLCBvbkVycm9yKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURpc2FibGVkVW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGFnaW5hdGlvbk9wdGlvbnMgPSB7XG4gICAgICBpbml0aWFsTnVtSXRlbXM6IG9wdGlvbnMuaW5pdGlhbE51bUl0ZW1zLFxuICAgICAgaWQ6IC0xXG4gICAgfTtcbiAgICBjb25zdCB7IHBhZ2luYXRlZFF1ZXJ5VG9rZW4sIHVuc3Vic2NyaWJlIH0gPSB0aGlzLnBhZ2luYXRlZENsaWVudC5zdWJzY3JpYmUoXG4gICAgICBnZXRGdW5jdGlvbk5hbWUocXVlcnkpLFxuICAgICAgYXJncyxcbiAgICAgIC8vIFNpbXBsZSBjbGllbnQgZG9lc24ndCB1c2UgSURzLCB0aGVyZSdzIG5vIGV4cGVjdGF0aW9uIHRoYXQgdGhlc2UgcXVlcmllcyByZW1haW4gc2VwYXJhdGUuXG4gICAgICBwYWdpbmF0aW9uT3B0aW9uc1xuICAgICk7XG4gICAgY29uc3QgcXVlcnlJbmZvID0ge1xuICAgICAgcXVlcnlUb2tlbjogcGFnaW5hdGVkUXVlcnlUb2tlbixcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgb25FcnJvcixcbiAgICAgIHVuc3Vic2NyaWJlLFxuICAgICAgaGFzRXZlclJ1bjogZmFsc2UsXG4gICAgICBxdWVyeSxcbiAgICAgIGFyZ3MsXG4gICAgICBwYWdpbmF0aW9uT3B0aW9uc1xuICAgIH07XG4gICAgdGhpcy5saXN0ZW5lcnMuYWRkKHF1ZXJ5SW5mbyk7XG4gICAgaWYgKCEhdGhpcy5wYWdpbmF0ZWRDbGllbnQubG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4ocGFnaW5hdGVkUXVlcnlUb2tlbikgJiYgdGhpcy5jYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXNUaW1lciA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmNhbGxOZXdMaXN0ZW5lcnNXaXRoQ3VycmVudFZhbHVlc1RpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgKCkgPT4gdGhpcy5jYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXMoKSxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdW5zdWJzY3JpYmVQcm9wcyA9IHtcbiAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUocXVlcnlJbmZvKTtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIH0sXG4gICAgICBnZXRDdXJyZW50VmFsdWU6ICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wYWdpbmF0ZWRDbGllbnQubG9jYWxRdWVyeVJlc3VsdChcbiAgICAgICAgICBnZXRGdW5jdGlvbk5hbWUocXVlcnkpLFxuICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgcGFnaW5hdGlvbk9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBnZXRRdWVyeUxvZ3M6ICgpID0+IFtdXG4gICAgICAvLyBQYWdpbmF0ZWQgcXVlcmllcyBkb24ndCBhZ2dyZWdhdGUgdGhlaXIgbG9nc1xuICAgIH07XG4gICAgY29uc3QgcmV0ID0gdW5zdWJzY3JpYmVQcm9wcy51bnN1YnNjcmliZTtcbiAgICBPYmplY3QuYXNzaWduKHJldCwgdW5zdWJzY3JpYmVQcm9wcyk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAvLyBSdW4gYWxsIGNhbGxiYWNrcyB0aGF0IGhhdmUgbmV2ZXIgYmVlbiBydW4gYmVmb3JlIGlmIHRoZXkgaGF2ZSBhIHF1ZXJ5XG4gIC8vIHJlc3VsdCBhdmFpbGFibGUgbm93LlxuICBjYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXMoKSB7XG4gICAgdGhpcy5jYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXNUaW1lciA9IHZvaWQgMDtcbiAgICB0aGlzLl90cmFuc2l0aW9uKHsgcXVlcmllczogW10sIHBhZ2luYXRlZFF1ZXJpZXM6IFtdIH0sIHRydWUpO1xuICB9XG4gIHF1ZXJ5UmVzdWx0UmVhZHkocXVlcnlUb2tlbikge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5oYXNMb2NhbFF1ZXJ5UmVzdWx0QnlUb2tlbihxdWVyeVRva2VuKTtcbiAgfVxuICBjcmVhdGVEaXNhYmxlZFVuc3Vic2NyaWJlKCkge1xuICAgIGNvbnN0IGRpc2FibGVkVW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgfTtcbiAgICBjb25zdCB1bnN1YnNjcmliZVByb3BzID0ge1xuICAgICAgdW5zdWJzY3JpYmU6IGRpc2FibGVkVW5zdWJzY3JpYmUsXG4gICAgICBnZXRDdXJyZW50VmFsdWU6ICgpID0+IHZvaWQgMCxcbiAgICAgIGdldFF1ZXJ5TG9nczogKCkgPT4gdm9pZCAwXG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKGRpc2FibGVkVW5zdWJzY3JpYmUsIHVuc3Vic2NyaWJlUHJvcHMpO1xuICAgIHJldHVybiBkaXNhYmxlZFVuc3Vic2NyaWJlO1xuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSByZXR1cm47XG4gICAgdGhpcy5saXN0ZW5lcnMuY2xlYXIoKTtcbiAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9wYWdpbmF0ZWRDbGllbnQpIHtcbiAgICAgIHRoaXMuX3BhZ2luYXRlZENsaWVudCA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBKV1QgYXV0aCB0b2tlbiBhbmQgZGVjb2RlZCBjbGFpbXMuXG4gICAqL1xuICBnZXRBdXRoKCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSByZXR1cm47XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmdldEN1cnJlbnRBdXRoQ2xhaW1zKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgYXV0aGVudGljYXRpb24gdG9rZW4gdG8gYmUgdXNlZCBmb3Igc3Vic2VxdWVudCBxdWVyaWVzIGFuZCBtdXRhdGlvbnMuXG4gICAqIGBmZXRjaFRva2VuYCB3aWxsIGJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGFnYWluIGlmIGEgdG9rZW4gZXhwaXJlcy5cbiAgICogYGZldGNoVG9rZW5gIHNob3VsZCByZXR1cm4gYG51bGxgIGlmIHRoZSB0b2tlbiBjYW5ub3QgYmUgcmV0cmlldmVkLCBmb3IgZXhhbXBsZVxuICAgKiB3aGVuIHRoZSB1c2VyJ3MgcmlnaHRzIHdlcmUgcGVybWFuZW50bHkgcmV2b2tlZC5cbiAgICogQHBhcmFtIGZldGNoVG9rZW4gLSBhbiBhc3luYyBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIEpXVCAodHlwaWNhbGx5IGFuIE9wZW5JRCBDb25uZWN0IElkZW50aXR5IFRva2VuKVxuICAgKiBAcGFyYW0gb25DaGFuZ2UgLSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYXV0aGVudGljYXRpb24gc3RhdHVzIGNoYW5nZXNcbiAgICovXG4gIHNldEF1dGgoZmV0Y2hUb2tlbiwgb25DaGFuZ2UpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgcmV0dXJuO1xuICAgIHRoaXMuY2xpZW50LnNldEF1dGgoXG4gICAgICBmZXRjaFRva2VuLFxuICAgICAgb25DaGFuZ2UgPz8gKCgpID0+IHtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRBZG1pbkF1dGgodG9rZW4sIGlkZW50aXR5KSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb252ZXhDbGllbnQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgcmV0dXJuO1xuICAgIHRoaXMuY2xpZW50LnNldEFkbWluQXV0aCh0b2tlbiwgaWRlbnRpdHkpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF90cmFuc2l0aW9uKHtcbiAgICBxdWVyaWVzLFxuICAgIHBhZ2luYXRlZFF1ZXJpZXNcbiAgfSwgY2FsbE5ld0xpc3RlbmVycyA9IGZhbHNlKSB7XG4gICAgY29uc3QgdXBkYXRlZFF1ZXJpZXMgPSBbXG4gICAgICAuLi5xdWVyaWVzLm1hcCgocSkgPT4gcS50b2tlbiksXG4gICAgICAuLi5wYWdpbmF0ZWRRdWVyaWVzLm1hcCgocSkgPT4gcS50b2tlbilcbiAgICBdO1xuICAgIGZvciAoY29uc3QgcXVlcnlJbmZvIG9mIHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICBjb25zdCB7IGNhbGxiYWNrLCBxdWVyeVRva2VuLCBvbkVycm9yLCBoYXNFdmVyUnVuIH0gPSBxdWVyeUluZm87XG4gICAgICBjb25zdCBpc1BhZ2luYXRlZFF1ZXJ5ID0gc2VyaWFsaXplZFF1ZXJ5VG9rZW5Jc1BhZ2luYXRlZChxdWVyeVRva2VuKTtcbiAgICAgIGNvbnN0IGhhc1Jlc3VsdFJlYWR5ID0gaXNQYWdpbmF0ZWRRdWVyeSA/ICEhdGhpcy5wYWdpbmF0ZWRDbGllbnQubG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4ocXVlcnlUb2tlbikgOiB0aGlzLmNsaWVudC5oYXNMb2NhbFF1ZXJ5UmVzdWx0QnlUb2tlbihxdWVyeVRva2VuKTtcbiAgICAgIGlmICh1cGRhdGVkUXVlcmllcy5pbmNsdWRlcyhxdWVyeVRva2VuKSB8fCBjYWxsTmV3TGlzdGVuZXJzICYmICFoYXNFdmVyUnVuICYmIGhhc1Jlc3VsdFJlYWR5KSB7XG4gICAgICAgIHF1ZXJ5SW5mby5oYXNFdmVyUnVuID0gdHJ1ZTtcbiAgICAgICAgbGV0IG5ld1ZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChpc1BhZ2luYXRlZFF1ZXJ5KSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMucGFnaW5hdGVkQ2xpZW50LmxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHF1ZXJ5VG9rZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuY2xpZW50LmxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHF1ZXJ5VG9rZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICBcIlNlY29uZCBhcmd1bWVudCB0byBvblVwZGF0ZSBvbkVycm9yIGlzIHJlc2VydmVkIGZvciBsYXRlciB1c2VcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdm9pZCBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgIFwiU2Vjb25kIGFyZ3VtZW50IHRvIG9uVXBkYXRlIGNhbGxiYWNrIGlzIHJlc2VydmVkIGZvciBsYXRlciB1c2VcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZSBhIG11dGF0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gbXV0YXRpb24gLSBBIHtAbGluayBzZXJ2ZXIuRnVuY3Rpb25SZWZlcmVuY2V9IGZvciB0aGUgcHVibGljIG11dGF0aW9uXG4gICAqIHRvIHJ1bi5cbiAgICogQHBhcmFtIGFyZ3MgLSBBbiBhcmd1bWVudHMgb2JqZWN0IGZvciB0aGUgbXV0YXRpb24uXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQSB7QGxpbmsgTXV0YXRpb25PcHRpb25zfSBvcHRpb25zIG9iamVjdCBmb3IgdGhlIG11dGF0aW9uLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2Ugb2YgdGhlIG11dGF0aW9uJ3MgcmVzdWx0LlxuICAgKi9cbiAgYXN5bmMgbXV0YXRpb24obXV0YXRpb24sIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgdGhyb3cgbmV3IEVycm9yKFwiQ29udmV4Q2xpZW50IGlzIGRpc2FibGVkXCIpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5tdXRhdGlvbihnZXRGdW5jdGlvbk5hbWUobXV0YXRpb24pLCBhcmdzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZSBhbiBhY3Rpb24gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhY3Rpb24gLSBBIHtAbGluayBzZXJ2ZXIuRnVuY3Rpb25SZWZlcmVuY2V9IGZvciB0aGUgcHVibGljIGFjdGlvblxuICAgKiB0byBydW4uXG4gICAqIEBwYXJhbSBhcmdzIC0gQW4gYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIGFjdGlvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIG9mIHRoZSBhY3Rpb24ncyByZXN1bHQuXG4gICAqL1xuICBhc3luYyBhY3Rpb24oYWN0aW9uLCBhcmdzKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHRocm93IG5ldyBFcnJvcihcIkNvbnZleENsaWVudCBpcyBkaXNhYmxlZFwiKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuYWN0aW9uKGdldEZ1bmN0aW9uTmFtZShhY3Rpb24pLCBhcmdzKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBxdWVyeSByZXN1bHQgb25jZS5cbiAgICpcbiAgICogQHBhcmFtIHF1ZXJ5IC0gQSB7QGxpbmsgc2VydmVyLkZ1bmN0aW9uUmVmZXJlbmNlfSBmb3IgdGhlIHB1YmxpYyBxdWVyeVxuICAgKiB0byBydW4uXG4gICAqIEBwYXJhbSBhcmdzIC0gQW4gYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyBBIHByb21pc2Ugb2YgdGhlIHF1ZXJ5J3MgcmVzdWx0LlxuICAgKi9cbiAgYXN5bmMgcXVlcnkocXVlcnksIGFyZ3MpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgdGhyb3cgbmV3IEVycm9yKFwiQ29udmV4Q2xpZW50IGlzIGRpc2FibGVkXCIpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jbGllbnQubG9jYWxRdWVyeVJlc3VsdChnZXRGdW5jdGlvbk5hbWUocXVlcnkpLCBhcmdzKTtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHsgdW5zdWJzY3JpYmUgfSA9IHRoaXMub25VcGRhdGUoXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBhcmdzLFxuICAgICAgICAodmFsdWUyKSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlMik7XG4gICAgICAgIH0sXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB7QGxpbmsgQ29ubmVjdGlvblN0YXRlfSBiZXR3ZWVuIHRoZSBjbGllbnQgYW5kIHRoZSBDb252ZXhcbiAgICogYmFja2VuZC5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHtAbGluayBDb25uZWN0aW9uU3RhdGV9IHdpdGggdGhlIENvbnZleCBiYWNrZW5kLlxuICAgKi9cbiAgY29ubmVjdGlvblN0YXRlKCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJDb252ZXhDbGllbnQgaXMgZGlzYWJsZWRcIik7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmNvbm5lY3Rpb25TdGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gdGhlIHtAbGluayBDb25uZWN0aW9uU3RhdGV9IGJldHdlZW4gdGhlIGNsaWVudCBhbmQgdGhlIENvbnZleFxuICAgKiBiYWNrZW5kLCBjYWxsaW5nIGEgY2FsbGJhY2sgZWFjaCB0aW1lIGl0IGNoYW5nZXMuXG4gICAqXG4gICAqIFN1YnNjcmliZWQgY2FsbGJhY2tzIHdpbGwgYmUgY2FsbGVkIHdoZW4gYW55IHBhcnQgb2YgQ29ubmVjdGlvblN0YXRlIGNoYW5nZXMuXG4gICAqIENvbm5lY3Rpb25TdGF0ZSBtYXkgZ3JvdyBpbiBmdXR1cmUgdmVyc2lvbnMgKGUuZy4gdG8gcHJvdmlkZSBhIGFycmF5IG9mXG4gICAqIGluZmxpZ2h0IHJlcXVlc3RzKSBpbiB3aGljaCBjYXNlIGNhbGxiYWNrcyB3b3VsZCBiZSBjYWxsZWQgbW9yZSBmcmVxdWVudGx5LlxuICAgKlxuICAgKiBAcmV0dXJucyBBbiB1bnN1YnNjcmliZSBmdW5jdGlvbiB0byBzdG9wIGxpc3RlbmluZy5cbiAgICovXG4gIHN1YnNjcmliZVRvQ29ubmVjdGlvblN0YXRlKGNiKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuc3Vic2NyaWJlVG9Db25uZWN0aW9uU3RhdGUoY2IpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW1wbGVfY2xpZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19kZWZOb3JtYWxQcm9wIiwib2JqIiwia2V5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX3B1YmxpY0ZpZWxkIiwidmFsaWRhdGVEZXBsb3ltZW50VXJsIiwiQmFzZUNvbnZleENsaWVudCIsImdldEZ1bmN0aW9uTmFtZSIsIlBhZ2luYXRlZFF1ZXJ5Q2xpZW50Iiwic2VyaWFsaXplZFF1ZXJ5VG9rZW5Jc1BhZ2luYXRlZCIsImRlZmF1bHRXZWJTb2NrZXRDb25zdHJ1Y3RvciIsInNldERlZmF1bHRXZWJTb2NrZXRDb25zdHJ1Y3RvciIsIndzIiwiQ29udmV4Q2xpZW50IiwiY2xvc2VkIiwiX2Nsb3NlZCIsImNsaWVudCIsIl9jbGllbnQiLCJFcnJvciIsInBhZ2luYXRlZENsaWVudCIsIl9wYWdpbmF0ZWRDbGllbnQiLCJkaXNhYmxlZCIsIl9kaXNhYmxlZCIsIm9uVXBkYXRlIiwicXVlcnkiLCJhcmdzIiwiY2FsbGJhY2siLCJvbkVycm9yIiwiY3JlYXRlRGlzYWJsZWRVbnN1YnNjcmliZSIsInF1ZXJ5VG9rZW4iLCJ1bnN1YnNjcmliZSIsInN1YnNjcmliZSIsInF1ZXJ5SW5mbyIsImhhc0V2ZXJSdW4iLCJwYWdpbmF0aW9uT3B0aW9ucyIsImxpc3RlbmVycyIsImFkZCIsInF1ZXJ5UmVzdWx0UmVhZHkiLCJjYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXNUaW1lciIsInNldFRpbWVvdXQiLCJjYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXMiLCJ1bnN1YnNjcmliZVByb3BzIiwiZGVsZXRlIiwiZ2V0Q3VycmVudFZhbHVlIiwibG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4iLCJnZXRRdWVyeUxvZ3MiLCJsb2NhbFF1ZXJ5TG9ncyIsInJldCIsImFzc2lnbiIsIm9uUGFnaW5hdGVkVXBkYXRlX2V4cGVyaW1lbnRhbCIsIm9wdGlvbnMiLCJpbml0aWFsTnVtSXRlbXMiLCJpZCIsInBhZ2luYXRlZFF1ZXJ5VG9rZW4iLCJyZXN1bHQiLCJsb2NhbFF1ZXJ5UmVzdWx0IiwiX3RyYW5zaXRpb24iLCJxdWVyaWVzIiwicGFnaW5hdGVkUXVlcmllcyIsImhhc0xvY2FsUXVlcnlSZXN1bHRCeVRva2VuIiwiZGlzYWJsZWRVbnN1YnNjcmliZSIsImNsb3NlIiwiY2xlYXIiLCJnZXRBdXRoIiwiZ2V0Q3VycmVudEF1dGhDbGFpbXMiLCJzZXRBdXRoIiwiZmV0Y2hUb2tlbiIsIm9uQ2hhbmdlIiwic2V0QWRtaW5BdXRoIiwidG9rZW4iLCJpZGVudGl0eSIsImNhbGxOZXdMaXN0ZW5lcnMiLCJ1cGRhdGVkUXVlcmllcyIsIm1hcCIsInEiLCJpc1BhZ2luYXRlZFF1ZXJ5IiwiaGFzUmVzdWx0UmVhZHkiLCJpbmNsdWRlcyIsIm5ld1ZhbHVlIiwiZXJyb3IiLCJQcm9taXNlIiwicmVqZWN0IiwibXV0YXRpb24iLCJhY3Rpb24iLCJyZXNvbHZlIiwidmFsdWUyIiwiZSIsImNvbm5lY3Rpb25TdGF0ZSIsInN1YnNjcmliZVRvQ29ubmVjdGlvblN0YXRlIiwiY2IiLCJjb25zdHJ1Y3RvciIsImFkZHJlc3MiLCJza2lwQ29udmV4RGVwbG95bWVudFVybENoZWNrIiwiYmFzZU9wdGlvbnMiLCJXZWJTb2NrZXQiLCJ3ZWJTb2NrZXRDb25zdHJ1Y3RvciIsInVuc2F2ZWRDaGFuZ2VzV2FybmluZyIsInRyYW5zaXRpb24iLCJTZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/browser/simple_client.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/authentication_manager.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/convex/dist/esm/browser/sync/authentication_manager.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthenticationManager: function() { return /* binding */ AuthenticationManager; }\n/* harmony export */ });\n/* harmony import */ var _vendor_jwt_decode_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../vendor/jwt-decode/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/vendor/jwt-decode/index.js\");\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\nconst MAXIMUM_REFRESH_DELAY = 20 * 24 * 60 * 60 * 1e3;\nconst MAX_TOKEN_CONFIRMATION_ATTEMPTS = 2;\nclass AuthenticationManager {\n    async setConfig(fetchToken, onChange) {\n        this.resetAuthState();\n        this._logVerbose(\"pausing WS for auth token fetch\");\n        this.pauseSocket();\n        const token = await this.fetchTokenAndGuardAgainstRace(fetchToken, {\n            forceRefreshToken: false\n        });\n        if (token.isFromOutdatedConfig) {\n            return;\n        }\n        if (token.value) {\n            this.setAuthState({\n                state: \"waitingForServerConfirmationOfCachedToken\",\n                config: {\n                    fetchToken,\n                    onAuthChange: onChange\n                },\n                hasRetried: false\n            });\n            this.authenticate(token.value);\n        } else {\n            this.setAuthState({\n                state: \"initialRefetch\",\n                config: {\n                    fetchToken,\n                    onAuthChange: onChange\n                }\n            });\n            await this.refetchToken();\n        }\n        this._logVerbose(\"resuming WS after auth token fetch\");\n        this.resumeSocket();\n    }\n    onTransition(serverMessage) {\n        if (!this.syncState.isCurrentOrNewerAuthVersion(serverMessage.endVersion.identity)) {\n            return;\n        }\n        if (serverMessage.endVersion.identity <= serverMessage.startVersion.identity) {\n            return;\n        }\n        if (this.authState.state === \"waitingForServerConfirmationOfCachedToken\") {\n            this._logVerbose(\"server confirmed auth token is valid\");\n            void this.refetchToken();\n            this.authState.config.onAuthChange(true);\n            return;\n        }\n        if (this.authState.state === \"waitingForServerConfirmationOfFreshToken\") {\n            this._logVerbose(\"server confirmed new auth token is valid\");\n            this.scheduleTokenRefetch(this.authState.token);\n            this.tokenConfirmationAttempts = 0;\n            if (!this.authState.hadAuth) {\n                this.authState.config.onAuthChange(true);\n            }\n        }\n    }\n    onAuthError(serverMessage) {\n        if (serverMessage.authUpdateAttempted === false && (this.authState.state === \"waitingForServerConfirmationOfFreshToken\" || this.authState.state === \"waitingForServerConfirmationOfCachedToken\")) {\n            this._logVerbose(\"ignoring non-auth token expired error\");\n            return;\n        }\n        const { baseVersion } = serverMessage;\n        if (!this.syncState.isCurrentOrNewerAuthVersion(baseVersion + 1)) {\n            this._logVerbose(\"ignoring auth error for previous auth attempt\");\n            return;\n        }\n        void this.tryToReauthenticate(serverMessage);\n        return;\n    }\n    // This is similar to `refetchToken` defined below, in fact we\n    // don't represent them as different states, but it is different\n    // in that we pause the WebSocket so that mutations\n    // don't retry with bad auth.\n    async tryToReauthenticate(serverMessage) {\n        this._logVerbose(\"attempting to reauthenticate: \".concat(serverMessage.error));\n        if (// No way to fetch another token, kaboom\n        this.authState.state === \"noAuth\" || // We failed on a fresh token. After a small number of retries, we give up\n        // and clear the auth state to avoid infinite retries.\n        this.authState.state === \"waitingForServerConfirmationOfFreshToken\" && this.tokenConfirmationAttempts >= MAX_TOKEN_CONFIRMATION_ATTEMPTS) {\n            this.logger.error('Failed to authenticate: \"'.concat(serverMessage.error, '\", check your server auth config'));\n            if (this.syncState.hasAuth()) {\n                this.syncState.clearAuth();\n            }\n            if (this.authState.state !== \"noAuth\") {\n                this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n            }\n            return;\n        }\n        if (this.authState.state === \"waitingForServerConfirmationOfFreshToken\") {\n            this.tokenConfirmationAttempts++;\n            this._logVerbose(\"retrying reauthentication, \".concat(MAX_TOKEN_CONFIRMATION_ATTEMPTS - this.tokenConfirmationAttempts, \" attempts remaining\"));\n        }\n        await this.stopSocket();\n        const token = await this.fetchTokenAndGuardAgainstRace(this.authState.config.fetchToken, {\n            forceRefreshToken: true\n        });\n        if (token.isFromOutdatedConfig) {\n            return;\n        }\n        if (token.value && this.syncState.isNewAuth(token.value)) {\n            this.authenticate(token.value);\n            this.setAuthState({\n                state: \"waitingForServerConfirmationOfFreshToken\",\n                config: this.authState.config,\n                token: token.value,\n                hadAuth: this.authState.state === \"notRefetching\" || this.authState.state === \"waitingForScheduledRefetch\"\n            });\n        } else {\n            this._logVerbose(\"reauthentication failed, could not fetch a new token\");\n            if (this.syncState.hasAuth()) {\n                this.syncState.clearAuth();\n            }\n            this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n        }\n        this.tryRestartSocket();\n    }\n    // Force refetch the token and schedule another refetch\n    // before the token expires - an active client should never\n    // need to reauthenticate.\n    async refetchToken() {\n        if (this.authState.state === \"noAuth\") {\n            return;\n        }\n        this._logVerbose(\"refetching auth token\");\n        const token = await this.fetchTokenAndGuardAgainstRace(this.authState.config.fetchToken, {\n            forceRefreshToken: true\n        });\n        if (token.isFromOutdatedConfig) {\n            return;\n        }\n        if (token.value) {\n            if (this.syncState.isNewAuth(token.value)) {\n                this.setAuthState({\n                    state: \"waitingForServerConfirmationOfFreshToken\",\n                    hadAuth: this.syncState.hasAuth(),\n                    token: token.value,\n                    config: this.authState.config\n                });\n                this.authenticate(token.value);\n            } else {\n                this.setAuthState({\n                    state: \"notRefetching\",\n                    config: this.authState.config\n                });\n            }\n        } else {\n            this._logVerbose(\"refetching token failed\");\n            if (this.syncState.hasAuth()) {\n                this.clearAuth();\n            }\n            this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n        }\n        this._logVerbose(\"restarting WS after auth token fetch (if currently stopped)\");\n        this.tryRestartSocket();\n    }\n    scheduleTokenRefetch(token) {\n        if (this.authState.state === \"noAuth\") {\n            return;\n        }\n        const decodedToken = this.decodeToken(token);\n        if (!decodedToken) {\n            this.logger.error(\"Auth token is not a valid JWT, cannot refetch the token\");\n            return;\n        }\n        const { iat, exp } = decodedToken;\n        if (!iat || !exp) {\n            this.logger.error(\"Auth token does not have required fields, cannot refetch the token\");\n            return;\n        }\n        const tokenValiditySeconds = exp - iat;\n        if (tokenValiditySeconds <= 2) {\n            this.logger.error(\"Auth token does not live long enough, cannot refetch the token\");\n            return;\n        }\n        let delay = Math.min(MAXIMUM_REFRESH_DELAY, (tokenValiditySeconds - this.refreshTokenLeewaySeconds) * 1e3);\n        if (delay <= 0) {\n            this.logger.warn(\"Refetching auth token immediately, configured leeway \".concat(this.refreshTokenLeewaySeconds, \"s is larger than the token's lifetime \").concat(tokenValiditySeconds, \"s\"));\n            delay = 0;\n        }\n        const refetchTokenTimeoutId = setTimeout(()=>{\n            this._logVerbose(\"running scheduled token refetch\");\n            void this.refetchToken();\n        }, delay);\n        this.setAuthState({\n            state: \"waitingForScheduledRefetch\",\n            refetchTokenTimeoutId,\n            config: this.authState.config\n        });\n        this._logVerbose(\"scheduled preemptive auth token refetching in \".concat(delay, \"ms\"));\n    }\n    // Protects against simultaneous calls to `setConfig`\n    // while we're fetching a token\n    async fetchTokenAndGuardAgainstRace(fetchToken, fetchArgs) {\n        const originalConfigVersion = ++this.configVersion;\n        this._logVerbose(\"fetching token with config version \".concat(originalConfigVersion));\n        const token = await fetchToken(fetchArgs);\n        if (this.configVersion !== originalConfigVersion) {\n            this._logVerbose(\"stale config version, expected \".concat(originalConfigVersion, \", got \").concat(this.configVersion));\n            return {\n                isFromOutdatedConfig: true\n            };\n        }\n        return {\n            isFromOutdatedConfig: false,\n            value: token\n        };\n    }\n    stop() {\n        this.resetAuthState();\n        this.configVersion++;\n        this._logVerbose(\"config version bumped to \".concat(this.configVersion));\n    }\n    setAndReportAuthFailed(onAuthChange) {\n        onAuthChange(false);\n        this.resetAuthState();\n    }\n    resetAuthState() {\n        this.setAuthState({\n            state: \"noAuth\"\n        });\n    }\n    setAuthState(newAuth) {\n        const authStateForLog = newAuth.state === \"waitingForServerConfirmationOfFreshToken\" ? {\n            hadAuth: newAuth.hadAuth,\n            state: newAuth.state,\n            token: \"...\".concat(newAuth.token.slice(-7))\n        } : {\n            state: newAuth.state\n        };\n        this._logVerbose(\"setting auth state to \".concat(JSON.stringify(authStateForLog)));\n        switch(newAuth.state){\n            case \"waitingForScheduledRefetch\":\n            case \"notRefetching\":\n            case \"noAuth\":\n                this.tokenConfirmationAttempts = 0;\n                break;\n            case \"waitingForServerConfirmationOfFreshToken\":\n            case \"waitingForServerConfirmationOfCachedToken\":\n            case \"initialRefetch\":\n                break;\n            default:\n                {\n                    newAuth;\n                }\n        }\n        if (this.authState.state === \"waitingForScheduledRefetch\") {\n            clearTimeout(this.authState.refetchTokenTimeoutId);\n            this.syncState.markAuthCompletion();\n        }\n        this.authState = newAuth;\n    }\n    decodeToken(token) {\n        try {\n            return (0,_vendor_jwt_decode_index_js__WEBPACK_IMPORTED_MODULE_0__.jwtDecode)(token);\n        } catch (e) {\n            this._logVerbose(\"Error decoding token: \".concat(e instanceof Error ? e.message : \"Unknown error\"));\n            return null;\n        }\n    }\n    _logVerbose(message) {\n        this.logger.logVerbose(\"\".concat(message, \" [v\").concat(this.configVersion, \"]\"));\n    }\n    constructor(syncState, callbacks, config){\n        __publicField(this, \"authState\", {\n            state: \"noAuth\"\n        });\n        // Used to detect races involving `setConfig` calls\n        // while a token is being fetched.\n        __publicField(this, \"configVersion\", 0);\n        // Shared by the BaseClient so that the auth manager can easily inspect it\n        __publicField(this, \"syncState\");\n        // Passed down by BaseClient, sends a message to the server\n        __publicField(this, \"authenticate\");\n        __publicField(this, \"stopSocket\");\n        __publicField(this, \"tryRestartSocket\");\n        __publicField(this, \"pauseSocket\");\n        __publicField(this, \"resumeSocket\");\n        // Passed down by BaseClient, sends a message to the server\n        __publicField(this, \"clearAuth\");\n        __publicField(this, \"logger\");\n        __publicField(this, \"refreshTokenLeewaySeconds\");\n        // Number of times we have attempted to confirm the latest token. We retry up\n        // to `MAX_TOKEN_CONFIRMATION_ATTEMPTS` times.\n        __publicField(this, \"tokenConfirmationAttempts\", 0);\n        this.syncState = syncState;\n        this.authenticate = callbacks.authenticate;\n        this.stopSocket = callbacks.stopSocket;\n        this.tryRestartSocket = callbacks.tryRestartSocket;\n        this.pauseSocket = callbacks.pauseSocket;\n        this.resumeSocket = callbacks.resumeSocket;\n        this.clearAuth = callbacks.clearAuth;\n        this.logger = config.logger;\n        this.refreshTokenLeewaySeconds = config.refreshTokenLeewaySeconds;\n    }\n} //# sourceMappingURL=authentication_manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL2F1dGhlbnRpY2F0aW9uX21hbmFnZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBYTtBQUNiLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsa0JBQWtCLENBQUNDLEtBQUtDLEtBQUtDLFFBQVVELE9BQU9ELE1BQU1KLFVBQVVJLEtBQUtDLEtBQUs7UUFBRUUsWUFBWTtRQUFNQyxjQUFjO1FBQU1DLFVBQVU7UUFBTUg7SUFBTSxLQUFLRixHQUFHLENBQUNDLElBQUksR0FBR0M7QUFDMUosSUFBSUksZ0JBQWdCLENBQUNOLEtBQUtDLEtBQUtDLFFBQVVILGdCQUFnQkMsS0FBSyxPQUFPQyxRQUFRLFdBQVdBLE1BQU0sS0FBS0EsS0FBS0M7QUFDM0M7QUFDN0QsTUFBTU0sd0JBQXdCLEtBQUssS0FBSyxLQUFLLEtBQUs7QUFDbEQsTUFBTUMsa0NBQWtDO0FBQ2pDLE1BQU1DO0lBK0JYLE1BQU1DLFVBQVVDLFVBQVUsRUFBRUMsUUFBUSxFQUFFO1FBQ3BDLElBQUksQ0FBQ0MsY0FBYztRQUNuQixJQUFJLENBQUNDLFdBQVcsQ0FBQztRQUNqQixJQUFJLENBQUNDLFdBQVc7UUFDaEIsTUFBTUMsUUFBUSxNQUFNLElBQUksQ0FBQ0MsNkJBQTZCLENBQUNOLFlBQVk7WUFDakVPLG1CQUFtQjtRQUNyQjtRQUNBLElBQUlGLE1BQU1HLG9CQUFvQixFQUFFO1lBQzlCO1FBQ0Y7UUFDQSxJQUFJSCxNQUFNZixLQUFLLEVBQUU7WUFDZixJQUFJLENBQUNtQixZQUFZLENBQUM7Z0JBQ2hCQyxPQUFPO2dCQUNQQyxRQUFRO29CQUFFWDtvQkFBWVksY0FBY1g7Z0JBQVM7Z0JBQzdDWSxZQUFZO1lBQ2Q7WUFDQSxJQUFJLENBQUNDLFlBQVksQ0FBQ1QsTUFBTWYsS0FBSztRQUMvQixPQUFPO1lBQ0wsSUFBSSxDQUFDbUIsWUFBWSxDQUFDO2dCQUNoQkMs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LGNBQWMsSUFBSSxFQUFFLDZCQUE2QjtRQUNqRCxJQUFJLENBQUN5QixTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0wsWUFBWSxHQUFHc0QsVUFBVXRELFlBQVk7UUFDMUMsSUFBSSxDQUFDdUIsVUFBVSxHQUFHK0IsVUFBVS9CLFVBQVU7UUFDdEMsSUFBSSxDQUFDRSxnQkFBZ0IsR0FBRzZCLFVBQVU3QixnQkFBZ0I7UUFDbEQsSUFBSSxDQUFDbkMsV0FBVyxHQUFHZ0UsVUFBVWhFLFdBQVc7UUFDeEMsSUFBSSxDQUFDWSxZQUFZLEdBQUdvRCxVQUFVcEQsWUFBWTtRQUMxQyxJQUFJLENBQUNtQixTQUFTLEdBQUdpQyxVQUFVakMsU0FBUztRQUNwQyxJQUFJLENBQUNGLE1BQU0sR0FBR3RCLE9BQU9zQixNQUFNO1FBQzNCLElBQUksQ0FBQ2UseUJBQXlCLEdBQUdyQyxPQUFPcUMseUJBQXlCO0lBQ25FO0FBMlJGLEVBQ0Esa0RBQWtEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL2F1dGhlbnRpY2F0aW9uX21hbmFnZXIuanM/NTFiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5pbXBvcnQgeyBqd3REZWNvZGUgfSBmcm9tIFwiLi4vLi4vdmVuZG9yL2p3dC1kZWNvZGUvaW5kZXguanNcIjtcbmNvbnN0IE1BWElNVU1fUkVGUkVTSF9ERUxBWSA9IDIwICogMjQgKiA2MCAqIDYwICogMWUzO1xuY29uc3QgTUFYX1RPS0VOX0NPTkZJUk1BVElPTl9BVFRFTVBUUyA9IDI7XG5leHBvcnQgY2xhc3MgQXV0aGVudGljYXRpb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Ioc3luY1N0YXRlLCBjYWxsYmFja3MsIGNvbmZpZykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhdXRoU3RhdGVcIiwgeyBzdGF0ZTogXCJub0F1dGhcIiB9KTtcbiAgICAvLyBVc2VkIHRvIGRldGVjdCByYWNlcyBpbnZvbHZpbmcgYHNldENvbmZpZ2AgY2FsbHNcbiAgICAvLyB3aGlsZSBhIHRva2VuIGlzIGJlaW5nIGZldGNoZWQuXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbmZpZ1ZlcnNpb25cIiwgMCk7XG4gICAgLy8gU2hhcmVkIGJ5IHRoZSBCYXNlQ2xpZW50IHNvIHRoYXQgdGhlIGF1dGggbWFuYWdlciBjYW4gZWFzaWx5IGluc3BlY3QgaXRcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3luY1N0YXRlXCIpO1xuICAgIC8vIFBhc3NlZCBkb3duIGJ5IEJhc2VDbGllbnQsIHNlbmRzIGEgbWVzc2FnZSB0byB0aGUgc2VydmVyXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImF1dGhlbnRpY2F0ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RvcFNvY2tldFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidHJ5UmVzdGFydFNvY2tldFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGF1c2VTb2NrZXRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlc3VtZVNvY2tldFwiKTtcbiAgICAvLyBQYXNzZWQgZG93biBieSBCYXNlQ2xpZW50LCBzZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIHNlcnZlclxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjbGVhckF1dGhcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxvZ2dlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVmcmVzaFRva2VuTGVld2F5U2Vjb25kc1wiKTtcbiAgICAvLyBOdW1iZXIgb2YgdGltZXMgd2UgaGF2ZSBhdHRlbXB0ZWQgdG8gY29uZmlybSB0aGUgbGF0ZXN0IHRva2VuLiBXZSByZXRyeSB1cFxuICAgIC8vIHRvIGBNQVhfVE9LRU5fQ09ORklSTUFUSU9OX0FUVEVNUFRTYCB0aW1lcy5cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidG9rZW5Db25maXJtYXRpb25BdHRlbXB0c1wiLCAwKTtcbiAgICB0aGlzLnN5bmNTdGF0ZSA9IHN5bmNTdGF0ZTtcbiAgICB0aGlzLmF1dGhlbnRpY2F0ZSA9IGNhbGxiYWNrcy5hdXRoZW50aWNhdGU7XG4gICAgdGhpcy5zdG9wU29ja2V0ID0gY2FsbGJhY2tzLnN0b3BTb2NrZXQ7XG4gICAgdGhpcy50cnlSZXN0YXJ0U29ja2V0ID0gY2FsbGJhY2tzLnRyeVJlc3RhcnRTb2NrZXQ7XG4gICAgdGhpcy5wYXVzZVNvY2tldCA9IGNhbGxiYWNrcy5wYXVzZVNvY2tldDtcbiAgICB0aGlzLnJlc3VtZVNvY2tldCA9IGNhbGxiYWNrcy5yZXN1bWVTb2NrZXQ7XG4gICAgdGhpcy5jbGVhckF1dGggPSBjYWxsYmFja3MuY2xlYXJBdXRoO1xuICAgIHRoaXMubG9nZ2VyID0gY29uZmlnLmxvZ2dlcjtcbiAgICB0aGlzLnJlZnJlc2hUb2tlbkxlZXdheVNlY29uZHMgPSBjb25maWcucmVmcmVzaFRva2VuTGVld2F5U2Vjb25kcztcbiAgfVxuICBhc3luYyBzZXRDb25maWcoZmV0Y2hUb2tlbiwgb25DaGFuZ2UpIHtcbiAgICB0aGlzLnJlc2V0QXV0aFN0YXRlKCk7XG4gICAgdGhpcy5fbG9nVmVyYm9zZShcInBhdXNpbmcgV1MgZm9yIGF1dGggdG9rZW4gZmV0Y2hcIik7XG4gICAgdGhpcy5wYXVzZVNvY2tldCgpO1xuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdGhpcy5mZXRjaFRva2VuQW5kR3VhcmRBZ2FpbnN0UmFjZShmZXRjaFRva2VuLCB7XG4gICAgICBmb3JjZVJlZnJlc2hUb2tlbjogZmFsc2VcbiAgICB9KTtcbiAgICBpZiAodG9rZW4uaXNGcm9tT3V0ZGF0ZWRDb25maWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRva2VuLnZhbHVlKSB7XG4gICAgICB0aGlzLnNldEF1dGhTdGF0ZSh7XG4gICAgICAgIHN0YXRlOiBcIndhaXRpbmdGb3JTZXJ2ZXJDb25maXJtYXRpb25PZkNhY2hlZFRva2VuXCIsXG4gICAgICAgIGNvbmZpZzogeyBmZXRjaFRva2VuLCBvbkF1dGhDaGFuZ2U6IG9uQ2hhbmdlIH0sXG4gICAgICAgIGhhc1JldHJpZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYXV0aGVudGljYXRlKHRva2VuLnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRBdXRoU3RhdGUoe1xuICAgICAgICBzdGF0ZTogXCJpbml0aWFsUmVmZXRjaFwiLFxuICAgICAgICBjb25maWc6IHsgZmV0Y2hUb2tlbiwgb25BdXRoQ2hhbmdlOiBvbkNoYW5nZSB9XG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHRoaXMucmVmZXRjaFRva2VuKCk7XG4gICAgfVxuICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXCJyZXN1bWluZyBXUyBhZnRlciBhdXRoIHRva2VuIGZldGNoXCIpO1xuICAgIHRoaXMucmVzdW1lU29ja2V0KCk7XG4gIH1cbiAgb25UcmFuc2l0aW9uKHNlcnZlck1lc3NhZ2UpIHtcbiAgICBpZiAoIXRoaXMuc3luY1N0YXRlLmlzQ3VycmVudE9yTmV3ZXJBdXRoVmVyc2lvbihcbiAgICAgIHNlcnZlck1lc3NhZ2UuZW5kVmVyc2lvbi5pZGVudGl0eVxuICAgICkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlcnZlck1lc3NhZ2UuZW5kVmVyc2lvbi5pZGVudGl0eSA8PSBzZXJ2ZXJNZXNzYWdlLnN0YXJ0VmVyc2lvbi5pZGVudGl0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5hdXRoU3RhdGUuc3RhdGUgPT09IFwid2FpdGluZ0ZvclNlcnZlckNvbmZpcm1hdGlvbk9mQ2FjaGVkVG9rZW5cIikge1xuICAgICAgdGhpcy5fbG9nVmVyYm9zZShcInNlcnZlciBjb25maXJtZWQgYXV0aCB0b2tlbiBpcyB2YWxpZFwiKTtcbiAgICAgIHZvaWQgdGhpcy5yZWZldGNoVG9rZW4oKTtcbiAgICAgIHRoaXMuYXV0aFN0YXRlLmNvbmZpZy5vbkF1dGhDaGFuZ2UodHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmF1dGhTdGF0ZS5zdGF0ZSA9PT0gXCJ3YWl0aW5nRm9yU2VydmVyQ29uZmlybWF0aW9uT2ZGcmVzaFRva2VuXCIpIHtcbiAgICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXCJzZXJ2ZXIgY29uZmlybWVkIG5ldyBhdXRoIHRva2VuIGlzIHZhbGlkXCIpO1xuICAgICAgdGhpcy5zY2hlZHVsZVRva2VuUmVmZXRjaCh0aGlzLmF1dGhTdGF0ZS50b2tlbik7XG4gICAgICB0aGlzLnRva2VuQ29uZmlybWF0aW9uQXR0ZW1wdHMgPSAwO1xuICAgICAgaWYgKCF0aGlzLmF1dGhTdGF0ZS5oYWRBdXRoKSB7XG4gICAgICAgIHRoaXMuYXV0aFN0YXRlLmNvbmZpZy5vbkF1dGhDaGFuZ2UodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uQXV0aEVycm9yKHNlcnZlck1lc3NhZ2UpIHtcbiAgICBpZiAoc2VydmVyTWVzc2FnZS5hdXRoVXBkYXRlQXR0ZW1wdGVkID09PSBmYWxzZSAmJiAodGhpcy5hdXRoU3RhdGUuc3RhdGUgPT09IFwid2FpdGluZ0ZvclNlcnZlckNvbmZpcm1hdGlvbk9mRnJlc2hUb2tlblwiIHx8IHRoaXMuYXV0aFN0YXRlLnN0YXRlID09PSBcIndhaXRpbmdGb3JTZXJ2ZXJDb25maXJtYXRpb25PZkNhY2hlZFRva2VuXCIpKSB7XG4gICAgICB0aGlzLl9sb2dWZXJib3NlKFwiaWdub3Jpbmcgbm9uLWF1dGggdG9rZW4gZXhwaXJlZCBlcnJvclwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBiYXNlVmVyc2lvbiB9ID0gc2VydmVyTWVzc2FnZTtcbiAgICBpZiAoIXRoaXMuc3luY1N0YXRlLmlzQ3VycmVudE9yTmV3ZXJBdXRoVmVyc2lvbihiYXNlVmVyc2lvbiArIDEpKSB7XG4gICAgICB0aGlzLl9sb2dWZXJib3NlKFwiaWdub3JpbmcgYXV0aCBlcnJvciBmb3IgcHJldmlvdXMgYXV0aCBhdHRlbXB0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2b2lkIHRoaXMudHJ5VG9SZWF1dGhlbnRpY2F0ZShzZXJ2ZXJNZXNzYWdlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gVGhpcyBpcyBzaW1pbGFyIHRvIGByZWZldGNoVG9rZW5gIGRlZmluZWQgYmVsb3csIGluIGZhY3Qgd2VcbiAgLy8gZG9uJ3QgcmVwcmVzZW50IHRoZW0gYXMgZGlmZmVyZW50IHN0YXRlcywgYnV0IGl0IGlzIGRpZmZlcmVudFxuICAvLyBpbiB0aGF0IHdlIHBhdXNlIHRoZSBXZWJTb2NrZXQgc28gdGhhdCBtdXRhdGlvbnNcbiAgLy8gZG9uJ3QgcmV0cnkgd2l0aCBiYWQgYXV0aC5cbiAgYXN5bmMgdHJ5VG9SZWF1dGhlbnRpY2F0ZShzZXJ2ZXJNZXNzYWdlKSB7XG4gICAgdGhpcy5fbG9nVmVyYm9zZShgYXR0ZW1wdGluZyB0byByZWF1dGhlbnRpY2F0ZTogJHtzZXJ2ZXJNZXNzYWdlLmVycm9yfWApO1xuICAgIGlmIChcbiAgICAgIC8vIE5vIHdheSB0byBmZXRjaCBhbm90aGVyIHRva2VuLCBrYWJvb21cbiAgICAgIHRoaXMuYXV0aFN0YXRlLnN0YXRlID09PSBcIm5vQXV0aFwiIHx8IC8vIFdlIGZhaWxlZCBvbiBhIGZyZXNoIHRva2VuLiBBZnRlciBhIHNtYWxsIG51bWJlciBvZiByZXRyaWVzLCB3ZSBnaXZlIHVwXG4gICAgICAvLyBhbmQgY2xlYXIgdGhlIGF1dGggc3RhdGUgdG8gYXZvaWQgaW5maW5pdGUgcmV0cmllcy5cbiAgICAgIHRoaXMuYXV0aFN0YXRlLnN0YXRlID09PSBcIndhaXRpbmdGb3JTZXJ2ZXJDb25maXJtYXRpb25PZkZyZXNoVG9rZW5cIiAmJiB0aGlzLnRva2VuQ29uZmlybWF0aW9uQXR0ZW1wdHMgPj0gTUFYX1RPS0VOX0NPTkZJUk1BVElPTl9BVFRFTVBUU1xuICAgICkge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gYXV0aGVudGljYXRlOiBcIiR7c2VydmVyTWVzc2FnZS5lcnJvcn1cIiwgY2hlY2sgeW91ciBzZXJ2ZXIgYXV0aCBjb25maWdgXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuc3luY1N0YXRlLmhhc0F1dGgoKSkge1xuICAgICAgICB0aGlzLnN5bmNTdGF0ZS5jbGVhckF1dGgoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmF1dGhTdGF0ZS5zdGF0ZSAhPT0gXCJub0F1dGhcIikge1xuICAgICAgICB0aGlzLnNldEFuZFJlcG9ydEF1dGhGYWlsZWQodGhpcy5hdXRoU3RhdGUuY29uZmlnLm9uQXV0aENoYW5nZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmF1dGhTdGF0ZS5zdGF0ZSA9PT0gXCJ3YWl0aW5nRm9yU2VydmVyQ29uZmlybWF0aW9uT2ZGcmVzaFRva2VuXCIpIHtcbiAgICAgIHRoaXMudG9rZW5Db25maXJtYXRpb25BdHRlbXB0cysrO1xuICAgICAgdGhpcy5fbG9nVmVyYm9zZShcbiAgICAgICAgYHJldHJ5aW5nIHJlYXV0aGVudGljYXRpb24sICR7TUFYX1RPS0VOX0NPTkZJUk1BVElPTl9BVFRFTVBUUyAtIHRoaXMudG9rZW5Db25maXJtYXRpb25BdHRlbXB0c30gYXR0ZW1wdHMgcmVtYWluaW5nYFxuICAgICAgKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5zdG9wU29ja2V0KCk7XG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmZldGNoVG9rZW5BbmRHdWFyZEFnYWluc3RSYWNlKFxuICAgICAgdGhpcy5hdXRoU3RhdGUuY29uZmlnLmZldGNoVG9rZW4sXG4gICAgICB7XG4gICAgICAgIGZvcmNlUmVmcmVzaFRva2VuOiB0cnVlXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAodG9rZW4uaXNGcm9tT3V0ZGF0ZWRDb25maWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRva2VuLnZhbHVlICYmIHRoaXMuc3luY1N0YXRlLmlzTmV3QXV0aCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgIHRoaXMuYXV0aGVudGljYXRlKHRva2VuLnZhbHVlKTtcbiAgICAgIHRoaXMuc2V0QXV0aFN0YXRlKHtcbiAgICAgICAgc3RhdGU6IFwid2FpdGluZ0ZvclNlcnZlckNvbmZpcm1hdGlvbk9mRnJlc2hUb2tlblwiLFxuICAgICAgICBjb25maWc6IHRoaXMuYXV0aFN0YXRlLmNvbmZpZyxcbiAgICAgICAgdG9rZW46IHRva2VuLnZhbHVlLFxuICAgICAgICBoYWRBdXRoOiB0aGlzLmF1dGhTdGF0ZS5zdGF0ZSA9PT0gXCJub3RSZWZldGNoaW5nXCIgfHwgdGhpcy5hdXRoU3RhdGUuc3RhdGUgPT09IFwid2FpdGluZ0ZvclNjaGVkdWxlZFJlZmV0Y2hcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXCJyZWF1dGhlbnRpY2F0aW9uIGZhaWxlZCwgY291bGQgbm90IGZldGNoIGEgbmV3IHRva2VuXCIpO1xuICAgICAgaWYgKHRoaXMuc3luY1N0YXRlLmhhc0F1dGgoKSkge1xuICAgICAgICB0aGlzLnN5bmNTdGF0ZS5jbGVhckF1dGgoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0QW5kUmVwb3J0QXV0aEZhaWxlZCh0aGlzLmF1dGhTdGF0ZS5jb25maWcub25BdXRoQ2hhbmdlKTtcbiAgICB9XG4gICAgdGhpcy50cnlSZXN0YXJ0U29ja2V0KCk7XG4gIH1cbiAgLy8gRm9yY2UgcmVmZXRjaCB0aGUgdG9rZW4gYW5kIHNjaGVkdWxlIGFub3RoZXIgcmVmZXRjaFxuICAvLyBiZWZvcmUgdGhlIHRva2VuIGV4cGlyZXMgLSBhbiBhY3RpdmUgY2xpZW50IHNob3VsZCBuZXZlclxuICAvLyBuZWVkIHRvIHJlYXV0aGVudGljYXRlLlxuICBhc3luYyByZWZldGNoVG9rZW4oKSB7XG4gICAgaWYgKHRoaXMuYXV0aFN0YXRlLnN0YXRlID09PSBcIm5vQXV0aFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXCJyZWZldGNoaW5nIGF1dGggdG9rZW5cIik7XG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmZldGNoVG9rZW5BbmRHdWFyZEFnYWluc3RSYWNlKFxuICAgICAgdGhpcy5hdXRoU3RhdGUuY29uZmlnLmZldGNoVG9rZW4sXG4gICAgICB7XG4gICAgICAgIGZvcmNlUmVmcmVzaFRva2VuOiB0cnVlXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAodG9rZW4uaXNGcm9tT3V0ZGF0ZWRDb25maWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRva2VuLnZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5zeW5jU3RhdGUuaXNOZXdBdXRoKHRva2VuLnZhbHVlKSkge1xuICAgICAgICB0aGlzLnNldEF1dGhTdGF0ZSh7XG4gICAgICAgICAgc3RhdGU6IFwid2FpdGluZ0ZvclNlcnZlckNvbmZpcm1hdGlvbk9mRnJlc2hUb2tlblwiLFxuICAgICAgICAgIGhhZEF1dGg6IHRoaXMuc3luY1N0YXRlLmhhc0F1dGgoKSxcbiAgICAgICAgICB0b2tlbjogdG9rZW4udmFsdWUsXG4gICAgICAgICAgY29uZmlnOiB0aGlzLmF1dGhTdGF0ZS5jb25maWdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXV0aGVudGljYXRlKHRva2VuLnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0QXV0aFN0YXRlKHtcbiAgICAgICAgICBzdGF0ZTogXCJub3RSZWZldGNoaW5nXCIsXG4gICAgICAgICAgY29uZmlnOiB0aGlzLmF1dGhTdGF0ZS5jb25maWdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXCJyZWZldGNoaW5nIHRva2VuIGZhaWxlZFwiKTtcbiAgICAgIGlmICh0aGlzLnN5bmNTdGF0ZS5oYXNBdXRoKCkpIHtcbiAgICAgICAgdGhpcy5jbGVhckF1dGgoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0QW5kUmVwb3J0QXV0aEZhaWxlZCh0aGlzLmF1dGhTdGF0ZS5jb25maWcub25BdXRoQ2hhbmdlKTtcbiAgICB9XG4gICAgdGhpcy5fbG9nVmVyYm9zZShcbiAgICAgIFwicmVzdGFydGluZyBXUyBhZnRlciBhdXRoIHRva2VuIGZldGNoIChpZiBjdXJyZW50bHkgc3RvcHBlZClcIlxuICAgICk7XG4gICAgdGhpcy50cnlSZXN0YXJ0U29ja2V0KCk7XG4gIH1cbiAgc2NoZWR1bGVUb2tlblJlZmV0Y2godG9rZW4pIHtcbiAgICBpZiAodGhpcy5hdXRoU3RhdGUuc3RhdGUgPT09IFwibm9BdXRoXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlZFRva2VuID0gdGhpcy5kZWNvZGVUb2tlbih0b2tlbik7XG4gICAgaWYgKCFkZWNvZGVkVG9rZW4pIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICBcIkF1dGggdG9rZW4gaXMgbm90IGEgdmFsaWQgSldULCBjYW5ub3QgcmVmZXRjaCB0aGUgdG9rZW5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBpYXQsIGV4cCB9ID0gZGVjb2RlZFRva2VuO1xuICAgIGlmICghaWF0IHx8ICFleHApIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICBcIkF1dGggdG9rZW4gZG9lcyBub3QgaGF2ZSByZXF1aXJlZCBmaWVsZHMsIGNhbm5vdCByZWZldGNoIHRoZSB0b2tlblwiXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0b2tlblZhbGlkaXR5U2Vjb25kcyA9IGV4cCAtIGlhdDtcbiAgICBpZiAodG9rZW5WYWxpZGl0eVNlY29uZHMgPD0gMikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgIFwiQXV0aCB0b2tlbiBkb2VzIG5vdCBsaXZlIGxvbmcgZW5vdWdoLCBjYW5ub3QgcmVmZXRjaCB0aGUgdG9rZW5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGRlbGF5ID0gTWF0aC5taW4oXG4gICAgICBNQVhJTVVNX1JFRlJFU0hfREVMQVksXG4gICAgICAodG9rZW5WYWxpZGl0eVNlY29uZHMgLSB0aGlzLnJlZnJlc2hUb2tlbkxlZXdheVNlY29uZHMpICogMWUzXG4gICAgKTtcbiAgICBpZiAoZGVsYXkgPD0gMCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgYFJlZmV0Y2hpbmcgYXV0aCB0b2tlbiBpbW1lZGlhdGVseSwgY29uZmlndXJlZCBsZWV3YXkgJHt0aGlzLnJlZnJlc2hUb2tlbkxlZXdheVNlY29uZHN9cyBpcyBsYXJnZXIgdGhhbiB0aGUgdG9rZW4ncyBsaWZldGltZSAke3Rva2VuVmFsaWRpdHlTZWNvbmRzfXNgXG4gICAgICApO1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH1cbiAgICBjb25zdCByZWZldGNoVG9rZW5UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXCJydW5uaW5nIHNjaGVkdWxlZCB0b2tlbiByZWZldGNoXCIpO1xuICAgICAgdm9pZCB0aGlzLnJlZmV0Y2hUb2tlbigpO1xuICAgIH0sIGRlbGF5KTtcbiAgICB0aGlzLnNldEF1dGhTdGF0ZSh7XG4gICAgICBzdGF0ZTogXCJ3YWl0aW5nRm9yU2NoZWR1bGVkUmVmZXRjaFwiLFxuICAgICAgcmVmZXRjaFRva2VuVGltZW91dElkLFxuICAgICAgY29uZmlnOiB0aGlzLmF1dGhTdGF0ZS5jb25maWdcbiAgICB9KTtcbiAgICB0aGlzLl9sb2dWZXJib3NlKFxuICAgICAgYHNjaGVkdWxlZCBwcmVlbXB0aXZlIGF1dGggdG9rZW4gcmVmZXRjaGluZyBpbiAke2RlbGF5fW1zYFxuICAgICk7XG4gIH1cbiAgLy8gUHJvdGVjdHMgYWdhaW5zdCBzaW11bHRhbmVvdXMgY2FsbHMgdG8gYHNldENvbmZpZ2BcbiAgLy8gd2hpbGUgd2UncmUgZmV0Y2hpbmcgYSB0b2tlblxuICBhc3luYyBmZXRjaFRva2VuQW5kR3VhcmRBZ2FpbnN0UmFjZShmZXRjaFRva2VuLCBmZXRjaEFyZ3MpIHtcbiAgICBjb25zdCBvcmlnaW5hbENvbmZpZ1ZlcnNpb24gPSArK3RoaXMuY29uZmlnVmVyc2lvbjtcbiAgICB0aGlzLl9sb2dWZXJib3NlKFxuICAgICAgYGZldGNoaW5nIHRva2VuIHdpdGggY29uZmlnIHZlcnNpb24gJHtvcmlnaW5hbENvbmZpZ1ZlcnNpb259YFxuICAgICk7XG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCBmZXRjaFRva2VuKGZldGNoQXJncyk7XG4gICAgaWYgKHRoaXMuY29uZmlnVmVyc2lvbiAhPT0gb3JpZ2luYWxDb25maWdWZXJzaW9uKSB7XG4gICAgICB0aGlzLl9sb2dWZXJib3NlKFxuICAgICAgICBgc3RhbGUgY29uZmlnIHZlcnNpb24sIGV4cGVjdGVkICR7b3JpZ2luYWxDb25maWdWZXJzaW9ufSwgZ290ICR7dGhpcy5jb25maWdWZXJzaW9ufWBcbiAgICAgICk7XG4gICAgICByZXR1cm4geyBpc0Zyb21PdXRkYXRlZENvbmZpZzogdHJ1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBpc0Zyb21PdXRkYXRlZENvbmZpZzogZmFsc2UsIHZhbHVlOiB0b2tlbiB9O1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5yZXNldEF1dGhTdGF0ZSgpO1xuICAgIHRoaXMuY29uZmlnVmVyc2lvbisrO1xuICAgIHRoaXMuX2xvZ1ZlcmJvc2UoYGNvbmZpZyB2ZXJzaW9uIGJ1bXBlZCB0byAke3RoaXMuY29uZmlnVmVyc2lvbn1gKTtcbiAgfVxuICBzZXRBbmRSZXBvcnRBdXRoRmFpbGVkKG9uQXV0aENoYW5nZSkge1xuICAgIG9uQXV0aENoYW5nZShmYWxzZSk7XG4gICAgdGhpcy5yZXNldEF1dGhTdGF0ZSgpO1xuICB9XG4gIHJlc2V0QXV0aFN0YXRlKCkge1xuICAgIHRoaXMuc2V0QXV0aFN0YXRlKHsgc3RhdGU6IFwibm9BdXRoXCIgfSk7XG4gIH1cbiAgc2V0QXV0aFN0YXRlKG5ld0F1dGgpIHtcbiAgICBjb25zdCBhdXRoU3RhdGVGb3JMb2cgPSBuZXdBdXRoLnN0YXRlID09PSBcIndhaXRpbmdGb3JTZXJ2ZXJDb25maXJtYXRpb25PZkZyZXNoVG9rZW5cIiA/IHtcbiAgICAgIGhhZEF1dGg6IG5ld0F1dGguaGFkQXV0aCxcbiAgICAgIHN0YXRlOiBuZXdBdXRoLnN0YXRlLFxuICAgICAgdG9rZW46IGAuLi4ke25ld0F1dGgudG9rZW4uc2xpY2UoLTcpfWBcbiAgICB9IDogeyBzdGF0ZTogbmV3QXV0aC5zdGF0ZSB9O1xuICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXG4gICAgICBgc2V0dGluZyBhdXRoIHN0YXRlIHRvICR7SlNPTi5zdHJpbmdpZnkoYXV0aFN0YXRlRm9yTG9nKX1gXG4gICAgKTtcbiAgICBzd2l0Y2ggKG5ld0F1dGguc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJ3YWl0aW5nRm9yU2NoZWR1bGVkUmVmZXRjaFwiOlxuICAgICAgY2FzZSBcIm5vdFJlZmV0Y2hpbmdcIjpcbiAgICAgIGNhc2UgXCJub0F1dGhcIjpcbiAgICAgICAgdGhpcy50b2tlbkNvbmZpcm1hdGlvbkF0dGVtcHRzID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwid2FpdGluZ0ZvclNlcnZlckNvbmZpcm1hdGlvbk9mRnJlc2hUb2tlblwiOlxuICAgICAgY2FzZSBcIndhaXRpbmdGb3JTZXJ2ZXJDb25maXJtYXRpb25PZkNhY2hlZFRva2VuXCI6XG4gICAgICBjYXNlIFwiaW5pdGlhbFJlZmV0Y2hcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIG5ld0F1dGg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmF1dGhTdGF0ZS5zdGF0ZSA9PT0gXCJ3YWl0aW5nRm9yU2NoZWR1bGVkUmVmZXRjaFwiKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5hdXRoU3RhdGUucmVmZXRjaFRva2VuVGltZW91dElkKTtcbiAgICAgIHRoaXMuc3luY1N0YXRlLm1hcmtBdXRoQ29tcGxldGlvbigpO1xuICAgIH1cbiAgICB0aGlzLmF1dGhTdGF0ZSA9IG5ld0F1dGg7XG4gIH1cbiAgZGVjb2RlVG9rZW4odG9rZW4pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGp3dERlY29kZSh0b2tlbik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5fbG9nVmVyYm9zZShcbiAgICAgICAgYEVycm9yIGRlY29kaW5nIHRva2VuOiAke2UgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWBcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgX2xvZ1ZlcmJvc2UobWVzc2FnZSkge1xuICAgIHRoaXMubG9nZ2VyLmxvZ1ZlcmJvc2UoYCR7bWVzc2FnZX0gW3Yke3RoaXMuY29uZmlnVmVyc2lvbn1dYCk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhlbnRpY2F0aW9uX21hbmFnZXIuanMubWFwXG4iXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2RlZk5vcm1hbFByb3AiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fcHVibGljRmllbGQiLCJqd3REZWNvZGUiLCJNQVhJTVVNX1JFRlJFU0hfREVMQVkiLCJNQVhfVE9LRU5fQ09ORklSTUFUSU9OX0FUVEVNUFRTIiwiQXV0aGVudGljYXRpb25NYW5hZ2VyIiwic2V0Q29uZmlnIiwiZmV0Y2hUb2tlbiIsIm9uQ2hhbmdlIiwicmVzZXRBdXRoU3RhdGUiLCJfbG9nVmVyYm9zZSIsInBhdXNlU29ja2V0IiwidG9rZW4iLCJmZXRjaFRva2VuQW5kR3VhcmRBZ2FpbnN0UmFjZSIsImZvcmNlUmVmcmVzaFRva2VuIiwiaXNGcm9tT3V0ZGF0ZWRDb25maWciLCJzZXRBdXRoU3RhdGUiLCJzdGF0ZSIsImNvbmZpZyIsIm9uQXV0aENoYW5nZSIsImhhc1JldHJpZWQiLCJhdXRoZW50aWNhdGUiLCJyZWZldGNoVG9rZW4iLCJyZXN1bWVTb2NrZXQiLCJvblRyYW5zaXRpb24iLCJzZXJ2ZXJNZXNzYWdlIiwic3luY1N0YXRlIiwiaXNDdXJyZW50T3JOZXdlckF1dGhWZXJzaW9uIiwiZW5kVmVyc2lvbiIsImlkZW50aXR5Iiwic3RhcnRWZXJzaW9uIiwiYXV0aFN0YXRlIiwic2NoZWR1bGVUb2tlblJlZmV0Y2giLCJ0b2tlbkNvbmZpcm1hdGlvbkF0dGVtcHRzIiwiaGFkQXV0aCIsIm9uQXV0aEVycm9yIiwiYXV0aFVwZGF0ZUF0dGVtcHRlZCIsImJhc2VWZXJzaW9uIiwidHJ5VG9SZWF1dGhlbnRpY2F0ZSIsImVycm9yIiwibG9nZ2VyIiwiaGFzQXV0aCIsImNsZWFyQXV0aCIsInNldEFuZFJlcG9ydEF1dGhGYWlsZWQiLCJzdG9wU29ja2V0IiwiaXNOZXdBdXRoIiwidHJ5UmVzdGFydFNvY2tldCIsImRlY29kZWRUb2tlbiIsImRlY29kZVRva2VuIiwiaWF0IiwiZXhwIiwidG9rZW5WYWxpZGl0eVNlY29uZHMiLCJkZWxheSIsIk1hdGgiLCJtaW4iLCJyZWZyZXNoVG9rZW5MZWV3YXlTZWNvbmRzIiwid2FybiIsInJlZmV0Y2hUb2tlblRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJmZXRjaEFyZ3MiLCJvcmlnaW5hbENvbmZpZ1ZlcnNpb24iLCJjb25maWdWZXJzaW9uIiwic3RvcCIsIm5ld0F1dGgiLCJhdXRoU3RhdGVGb3JMb2ciLCJzbGljZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjbGVhclRpbWVvdXQiLCJtYXJrQXV0aENvbXBsZXRpb24iLCJlIiwiRXJyb3IiLCJtZXNzYWdlIiwibG9nVmVyYm9zZSIsImNvbnN0cnVjdG9yIiwiY2FsbGJhY2tzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/authentication_manager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/client.js":
/*!*************************************************************!*\
  !*** ./node_modules/convex/dist/esm/browser/sync/client.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseConvexClient: function() { return /* binding */ BaseConvexClient; }\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/index.js\");\n/* harmony import */ var _values_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/index.js\");\n/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../logging.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/logging.js\");\n/* harmony import */ var _local_state_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./local_state.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/local_state.js\");\n/* harmony import */ var _request_manager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./request_manager.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/request_manager.js\");\n/* harmony import */ var _optimistic_updates_impl_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./optimistic_updates_impl.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/optimistic_updates_impl.js\");\n/* harmony import */ var _remote_query_set_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./remote_query_set.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/remote_query_set.js\");\n/* harmony import */ var _udf_path_utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./udf_path_utils.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/udf_path_utils.js\");\n/* harmony import */ var _web_socket_manager_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./web_socket_manager.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/web_socket_manager.js\");\n/* harmony import */ var _session_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./session.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/session.js\");\n/* harmony import */ var _authentication_manager_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./authentication_manager.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/authentication_manager.js\");\n/* harmony import */ var _metrics_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./metrics.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/metrics.js\");\n/* harmony import */ var _common_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../common/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/common/index.js\");\n/* harmony import */ var _values_errors_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../values/errors.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/errors.js\");\n/* harmony import */ var _vendor_jwt_decode_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../vendor/jwt-decode/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/vendor/jwt-decode/index.js\");\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass BaseConvexClient {\n    /**\n   * Return true if there is outstanding work from prior to the time of the most recent restart.\n   * This indicates that the client has not proven itself to have gotten past the issue that\n   * potentially led to the restart. Use this to influence when to reset backoff after a failure.\n   */ hasSyncedPastLastReconnect() {\n        const hasSyncedPastLastReconnect = this.requestManager.hasSyncedPastLastReconnect() || this.state.hasSyncedPastLastReconnect();\n        return hasSyncedPastLastReconnect;\n    }\n    observedTimestamp(observedTs) {\n        if (this.maxObservedTimestamp === void 0 || this.maxObservedTimestamp.lessThanOrEqual(observedTs)) {\n            this.maxObservedTimestamp = observedTs;\n        }\n    }\n    getMaxObservedTimestamp() {\n        return this.maxObservedTimestamp;\n    }\n    /**\n   * Compute the current query results based on the remoteQuerySet and the\n   * current optimistic updates and call `onTransition` for all the changed\n   * queries.\n   *\n   * @param completedMutations - A set of mutation IDs whose optimistic updates\n   * are no longer needed.\n   */ notifyOnQueryResultChanges(completedRequests) {\n        const remoteQueryResults = this.remoteQuerySet.remoteQueryResults();\n        const queryTokenToValue = /* @__PURE__ */ new Map();\n        for (const [queryId, result] of remoteQueryResults){\n            const queryToken = this.state.queryToken(queryId);\n            if (queryToken !== null) {\n                const query = {\n                    result,\n                    udfPath: this.state.queryPath(queryId),\n                    args: this.state.queryArgs(queryId)\n                };\n                queryTokenToValue.set(queryToken, query);\n            }\n        }\n        const changedQueryTokens = this.optimisticQueryResults.ingestQueryResultsFromServer(queryTokenToValue, new Set(completedRequests.keys()));\n        this.handleTransition({\n            queries: changedQueryTokens.map((token)=>{\n                const optimisticResult = this.optimisticQueryResults.rawQueryResult(token);\n                return {\n                    token,\n                    modification: {\n                        kind: \"Updated\",\n                        result: optimisticResult\n                    }\n                };\n            }),\n            reflectedMutations: Array.from(completedRequests).map((param)=>{\n                let [requestId, result] = param;\n                return {\n                    requestId,\n                    result\n                };\n            }),\n            timestamp: this.remoteQuerySet.timestamp()\n        });\n    }\n    handleTransition(transition) {\n        for (const fn of this._onTransitionFns.values()){\n            fn(transition);\n        }\n    }\n    /**\n   * Add a handler that will be called on a transition.\n   *\n   * Any external side effects (e.g. setting React state) should be handled here.\n   *\n   * @param fn\n   *\n   * @returns\n   */ addOnTransitionHandler(fn) {\n        const id = this._transitionHandlerCounter++;\n        this._onTransitionFns.set(id, fn);\n        return ()=>this._onTransitionFns.delete(id);\n    }\n    /**\n   * Get the current JWT auth token and decoded claims.\n   */ getCurrentAuthClaims() {\n        const authToken = this.state.getAuth();\n        let decoded = {};\n        if (authToken && authToken.tokenType === \"User\") {\n            try {\n                decoded = authToken ? (0,_vendor_jwt_decode_index_js__WEBPACK_IMPORTED_MODULE_14__.jwtDecode)(authToken.value) : {};\n            } catch (e) {\n                decoded = {};\n            }\n        } else {\n            return void 0;\n        }\n        return {\n            token: authToken.value,\n            decoded\n        };\n    }\n    /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   * `fetchToken` will be called automatically again if a token expires.\n   * `fetchToken` should return `null` if the token cannot be retrieved, for example\n   * when the user's rights were permanently revoked.\n   * @param fetchToken - an async function returning the JWT-encoded OpenID Connect Identity Token\n   * @param onChange - a callback that will be called when the authentication status changes\n   */ setAuth(fetchToken, onChange) {\n        void this.authenticationManager.setConfig(fetchToken, onChange);\n    }\n    hasAuth() {\n        return this.state.hasAuth();\n    }\n    /** @internal */ setAdminAuth(value, fakeUserIdentity) {\n        const message = this.state.setAdminAuth(value, fakeUserIdentity);\n        this.webSocketManager.sendMessage(message);\n    }\n    clearAuth() {\n        const message = this.state.clearAuth();\n        this.webSocketManager.sendMessage(message);\n    }\n    /**\n     * Subscribe to a query function.\n     *\n     * Whenever this query's result changes, the `onTransition` callback\n     * passed into the constructor will be called.\n     *\n     * @param name - The name of the query.\n     * @param args - An arguments object for the query. If this is omitted, the\n     * arguments will be `{}`.\n     * @param options - A {@link SubscribeOptions} options object for this query.\n  \n     * @returns An object containing a {@link QueryToken} corresponding to this\n     * query and an `unsubscribe` callback.\n     */ subscribe(name, args, options) {\n        const argsObject = (0,_common_index_js__WEBPACK_IMPORTED_MODULE_12__.parseArgs)(args);\n        const { modification, queryToken, unsubscribe } = this.state.subscribe(name, argsObject, options === null || options === void 0 ? void 0 : options.journal, options === null || options === void 0 ? void 0 : options.componentPath);\n        if (modification !== null) {\n            this.webSocketManager.sendMessage(modification);\n        }\n        return {\n            queryToken,\n            unsubscribe: ()=>{\n                const modification2 = unsubscribe();\n                if (modification2) {\n                    this.webSocketManager.sendMessage(modification2);\n                }\n            }\n        };\n    }\n    /**\n   * A query result based only on the current, local state.\n   *\n   * The only way this will return a value is if we're already subscribed to the\n   * query or its value has been set optimistically.\n   */ localQueryResult(udfPath, args) {\n        const argsObject = (0,_common_index_js__WEBPACK_IMPORTED_MODULE_12__.parseArgs)(args);\n        const queryToken = (0,_udf_path_utils_js__WEBPACK_IMPORTED_MODULE_7__.serializePathAndArgs)(udfPath, argsObject);\n        return this.optimisticQueryResults.queryResult(queryToken);\n    }\n    /**\n   * Get query result by query token based on current, local state\n   *\n   * The only way this will return a value is if we're already subscribed to the\n   * query or its value has been set optimistically.\n   *\n   * @internal\n   */ localQueryResultByToken(queryToken) {\n        return this.optimisticQueryResults.queryResult(queryToken);\n    }\n    /**\n   * Whether local query result is available for a token.\n   *\n   * This method does not throw if the result is an error.\n   *\n   * @internal\n   */ hasLocalQueryResultByToken(queryToken) {\n        return this.optimisticQueryResults.hasQueryResult(queryToken);\n    }\n    /**\n   * @internal\n   */ localQueryLogs(udfPath, args) {\n        const argsObject = (0,_common_index_js__WEBPACK_IMPORTED_MODULE_12__.parseArgs)(args);\n        const queryToken = (0,_udf_path_utils_js__WEBPACK_IMPORTED_MODULE_7__.serializePathAndArgs)(udfPath, argsObject);\n        return this.optimisticQueryResults.queryLogs(queryToken);\n    }\n    /**\n   * Retrieve the current {@link QueryJournal} for this query function.\n   *\n   * If we have not yet received a result for this query, this will be `undefined`.\n   *\n   * @param name - The name of the query.\n   * @param args - The arguments object for this query.\n   * @returns The query's {@link QueryJournal} or `undefined`.\n   */ queryJournal(name, args) {\n        const argsObject = (0,_common_index_js__WEBPACK_IMPORTED_MODULE_12__.parseArgs)(args);\n        const queryToken = (0,_udf_path_utils_js__WEBPACK_IMPORTED_MODULE_7__.serializePathAndArgs)(name, argsObject);\n        return this.state.queryJournal(queryToken);\n    }\n    /**\n   * Get the current {@link ConnectionState} between the client and the Convex\n   * backend.\n   *\n   * @returns The {@link ConnectionState} with the Convex backend.\n   */ connectionState() {\n        const wsConnectionState = this.webSocketManager.connectionState();\n        return {\n            hasInflightRequests: this.requestManager.hasInflightRequests(),\n            isWebSocketConnected: wsConnectionState.isConnected,\n            hasEverConnected: wsConnectionState.hasEverConnected,\n            connectionCount: wsConnectionState.connectionCount,\n            connectionRetries: wsConnectionState.connectionRetries,\n            timeOfOldestInflightRequest: this.requestManager.timeOfOldestInflightRequest(),\n            inflightMutations: this.requestManager.inflightMutations(),\n            inflightActions: this.requestManager.inflightActions()\n        };\n    }\n    /**\n   * Subscribe to the {@link ConnectionState} between the client and the Convex\n   * backend, calling a callback each time it changes.\n   *\n   * Subscribed callbacks will be called when any part of ConnectionState changes.\n   * ConnectionState may grow in future versions (e.g. to provide a array of\n   * inflight requests) in which case callbacks would be called more frequently.\n   *\n   * @returns An unsubscribe function to stop listening.\n   */ subscribeToConnectionState(cb) {\n        const id = this.nextConnectionStateSubscriberId++;\n        this.connectionStateSubscribers.set(id, cb);\n        return ()=>{\n            this.connectionStateSubscribers.delete(id);\n        };\n    }\n    /**\n     * Execute a mutation function.\n     *\n     * @param name - The name of the mutation.\n     * @param args - An arguments object for the mutation. If this is omitted,\n     * the arguments will be `{}`.\n     * @param options - A {@link MutationOptions} options object for this mutation.\n  \n     * @returns - A promise of the mutation's result.\n     */ async mutation(name, args, options) {\n        const result = await this.mutationInternal(name, args, options);\n        if (!result.success) {\n            if (result.errorData !== void 0) {\n                throw (0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.forwardData)(result, new _values_errors_js__WEBPACK_IMPORTED_MODULE_13__.ConvexError((0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.createHybridErrorStacktrace)(\"mutation\", name, result)));\n            }\n            throw new Error((0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.createHybridErrorStacktrace)(\"mutation\", name, result));\n        }\n        return result.value;\n    }\n    /**\n   * @internal\n   */ async mutationInternal(udfPath, args, options, componentPath) {\n        const { mutationPromise } = this.enqueueMutation(udfPath, args, options, componentPath);\n        return mutationPromise;\n    }\n    /**\n   * @internal\n   */ enqueueMutation(udfPath, args, options, componentPath) {\n        const mutationArgs = (0,_common_index_js__WEBPACK_IMPORTED_MODULE_12__.parseArgs)(args);\n        this.tryReportLongDisconnect();\n        const requestId = this.nextRequestId;\n        this._nextRequestId++;\n        if (options !== void 0) {\n            const optimisticUpdate = options.optimisticUpdate;\n            if (optimisticUpdate !== void 0) {\n                const wrappedUpdate = (localQueryStore)=>{\n                    const result = optimisticUpdate(localQueryStore, mutationArgs);\n                    if (result instanceof Promise) {\n                        this.logger.warn(\"Optimistic update handler returned a Promise. Optimistic updates should be synchronous.\");\n                    }\n                };\n                const changedQueryTokens = this.optimisticQueryResults.applyOptimisticUpdate(wrappedUpdate, requestId);\n                const changedQueries = changedQueryTokens.map((token)=>{\n                    const localResult = this.localQueryResultByToken(token);\n                    return {\n                        token,\n                        modification: {\n                            kind: \"Updated\",\n                            result: localResult === void 0 ? void 0 : {\n                                success: true,\n                                value: localResult,\n                                logLines: []\n                            }\n                        }\n                    };\n                });\n                this.handleTransition({\n                    queries: changedQueries,\n                    reflectedMutations: [],\n                    timestamp: this.remoteQuerySet.timestamp()\n                });\n            }\n        }\n        const message = {\n            type: \"Mutation\",\n            requestId,\n            udfPath,\n            componentPath,\n            args: [\n                (0,_values_index_js__WEBPACK_IMPORTED_MODULE_1__.convexToJson)(mutationArgs)\n            ]\n        };\n        const mightBeSent = this.webSocketManager.sendMessage(message);\n        const mutationPromise = this.requestManager.request(message, mightBeSent);\n        return {\n            requestId,\n            mutationPromise\n        };\n    }\n    /**\n   * Execute an action function.\n   *\n   * @param name - The name of the action.\n   * @param args - An arguments object for the action. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the action's result.\n   */ async action(name, args) {\n        const result = await this.actionInternal(name, args);\n        if (!result.success) {\n            if (result.errorData !== void 0) {\n                throw (0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.forwardData)(result, new _values_errors_js__WEBPACK_IMPORTED_MODULE_13__.ConvexError((0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.createHybridErrorStacktrace)(\"action\", name, result)));\n            }\n            throw new Error((0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.createHybridErrorStacktrace)(\"action\", name, result));\n        }\n        return result.value;\n    }\n    /**\n   * @internal\n   */ async actionInternal(udfPath, args, componentPath) {\n        const actionArgs = (0,_common_index_js__WEBPACK_IMPORTED_MODULE_12__.parseArgs)(args);\n        const requestId = this.nextRequestId;\n        this._nextRequestId++;\n        this.tryReportLongDisconnect();\n        const message = {\n            type: \"Action\",\n            requestId,\n            udfPath,\n            componentPath,\n            args: [\n                (0,_values_index_js__WEBPACK_IMPORTED_MODULE_1__.convexToJson)(actionArgs)\n            ]\n        };\n        const mightBeSent = this.webSocketManager.sendMessage(message);\n        return this.requestManager.request(message, mightBeSent);\n    }\n    /**\n   * Close any network handles associated with this client and stop all subscriptions.\n   *\n   * Call this method when you're done with an {@link BaseConvexClient} to\n   * dispose of its sockets and resources.\n   *\n   * @returns A `Promise` fulfilled when the connection has been completely closed.\n   */ async close() {\n        this.authenticationManager.stop();\n        return this.webSocketManager.terminate();\n    }\n    /**\n   * Return the address for this client, useful for creating a new client.\n   *\n   * Not guaranteed to match the address with which this client was constructed:\n   * it may be canonicalized.\n   */ get url() {\n        return this.address;\n    }\n    /**\n   * @internal\n   */ get nextRequestId() {\n        return this._nextRequestId;\n    }\n    /**\n   * @internal\n   */ get sessionId() {\n        return this._sessionId;\n    }\n    /**\n   * Reports performance marks to the server. This should only be called when\n   * we have a functional websocket.\n   */ reportMarks() {\n        if (this.debug) {\n            const report = (0,_metrics_js__WEBPACK_IMPORTED_MODULE_11__.getMarksReport)(this.sessionId);\n            this.webSocketManager.sendMessage({\n                type: \"Event\",\n                eventType: \"ClientConnect\",\n                event: report\n            });\n        }\n    }\n    tryReportLongDisconnect() {\n        if (!this.debug) {\n            return;\n        }\n        const timeOfOldestRequest = this.connectionState().timeOfOldestInflightRequest;\n        if (timeOfOldestRequest === null || Date.now() - timeOfOldestRequest.getTime() <= 60 * 1e3) {\n            return;\n        }\n        const endpoint = \"\".concat(this.address, \"/api/debug_event\");\n        fetch(endpoint, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Convex-Client\": \"npm-\".concat(_index_js__WEBPACK_IMPORTED_MODULE_0__.version)\n            },\n            body: JSON.stringify({\n                event: \"LongWebsocketDisconnect\"\n            })\n        }).then((response)=>{\n            if (!response.ok) {\n                this.logger.warn(\"Analytics request failed with response:\", response.body);\n            }\n        }).catch((error)=>{\n            this.logger.warn(\"Analytics response failed with error:\", error);\n        });\n    }\n    /**\n   * @param address - The url of your Convex deployment, often provided\n   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.\n   * @param onTransition - A callback receiving an array of query tokens\n   * corresponding to query results that have changed -- additional handlers\n   * can be added via `addOnTransitionHandler`.\n   * @param options - See {@link BaseConvexClientOptions} for a full description.\n   */ constructor(address, onTransition, options){\n        __publicField(this, \"address\");\n        __publicField(this, \"state\");\n        __publicField(this, \"requestManager\");\n        __publicField(this, \"webSocketManager\");\n        __publicField(this, \"authenticationManager\");\n        __publicField(this, \"remoteQuerySet\");\n        __publicField(this, \"optimisticQueryResults\");\n        __publicField(this, \"_transitionHandlerCounter\", 0);\n        __publicField(this, \"_nextRequestId\");\n        __publicField(this, \"_onTransitionFns\", /* @__PURE__ */ new Map());\n        __publicField(this, \"_sessionId\");\n        __publicField(this, \"firstMessageReceived\", false);\n        __publicField(this, \"debug\");\n        __publicField(this, \"logger\");\n        __publicField(this, \"maxObservedTimestamp\");\n        __publicField(this, \"connectionStateSubscribers\", /* @__PURE__ */ new Map());\n        __publicField(this, \"nextConnectionStateSubscriberId\", 0);\n        __publicField(this, \"_lastPublishedConnectionState\");\n        /**\n     * Call this whenever the connection state may have changed in a way that could\n     * require publishing it. Schedules a possibly update.\n     */ __publicField(this, \"markConnectionStateDirty\", ()=>{\n            void Promise.resolve().then(()=>{\n                const curConnectionState = this.connectionState();\n                if (JSON.stringify(curConnectionState) !== JSON.stringify(this._lastPublishedConnectionState)) {\n                    this._lastPublishedConnectionState = curConnectionState;\n                    for (const cb of this.connectionStateSubscribers.values()){\n                        cb(curConnectionState);\n                    }\n                }\n            });\n        });\n        // Instance property so that `mark()` doesn't need to be called as a method.\n        __publicField(this, \"mark\", (name)=>{\n            if (this.debug) {\n                (0,_metrics_js__WEBPACK_IMPORTED_MODULE_11__.mark)(name, this.sessionId);\n            }\n        });\n        if (typeof address === \"object\") {\n            throw new Error(\"Passing a ClientConfig object is no longer supported. Pass the URL of the Convex deployment as a string directly.\");\n        }\n        if ((options === null || options === void 0 ? void 0 : options.skipConvexDeploymentUrlCheck) !== true) {\n            (0,_common_index_js__WEBPACK_IMPORTED_MODULE_12__.validateDeploymentUrl)(address);\n        }\n        options = {\n            ...options\n        };\n        var _options_authRefreshTokenLeewaySeconds;\n        const authRefreshTokenLeewaySeconds = (_options_authRefreshTokenLeewaySeconds = options.authRefreshTokenLeewaySeconds) !== null && _options_authRefreshTokenLeewaySeconds !== void 0 ? _options_authRefreshTokenLeewaySeconds : 2;\n        let webSocketConstructor = options.webSocketConstructor;\n        if (!webSocketConstructor && typeof WebSocket === \"undefined\") {\n            throw new Error(\"No WebSocket global variable defined! To use Convex in an environment without WebSocket try the HTTP client: https://docs.convex.dev/api/classes/browser.ConvexHttpClient\");\n        }\n        webSocketConstructor = webSocketConstructor || WebSocket;\n        var _options_reportDebugInfoToConvex;\n        this.debug = (_options_reportDebugInfoToConvex = options.reportDebugInfoToConvex) !== null && _options_reportDebugInfoToConvex !== void 0 ? _options_reportDebugInfoToConvex : false;\n        this.address = address;\n        var _options_verbose, _options_verbose1;\n        this.logger = options.logger === false ? (0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.instantiateNoopLogger)({\n            verbose: (_options_verbose = options.verbose) !== null && _options_verbose !== void 0 ? _options_verbose : false\n        }) : options.logger !== true && options.logger ? options.logger : (0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.instantiateDefaultLogger)({\n            verbose: (_options_verbose1 = options.verbose) !== null && _options_verbose1 !== void 0 ? _options_verbose1 : false\n        });\n        const i = address.search(\"://\");\n        if (i === -1) {\n            throw new Error(\"Provided address was not an absolute URL.\");\n        }\n        const origin = address.substring(i + 3);\n        const protocol = address.substring(0, i);\n        let wsProtocol;\n        if (protocol === \"http\") {\n            wsProtocol = \"ws\";\n        } else if (protocol === \"https\") {\n            wsProtocol = \"wss\";\n        } else {\n            throw new Error(\"Unknown parent protocol \".concat(protocol));\n        }\n        const wsUri = \"\".concat(wsProtocol, \"://\").concat(origin, \"/api/\").concat(_index_js__WEBPACK_IMPORTED_MODULE_0__.version, \"/sync\");\n        this.state = new _local_state_js__WEBPACK_IMPORTED_MODULE_3__.LocalSyncState();\n        this.remoteQuerySet = new _remote_query_set_js__WEBPACK_IMPORTED_MODULE_6__.RemoteQuerySet((queryId)=>this.state.queryPath(queryId), this.logger);\n        this.requestManager = new _request_manager_js__WEBPACK_IMPORTED_MODULE_4__.RequestManager(this.logger, this.markConnectionStateDirty);\n        const pauseSocket = ()=>{\n            this.webSocketManager.pause();\n            this.state.pause();\n        };\n        this.authenticationManager = new _authentication_manager_js__WEBPACK_IMPORTED_MODULE_10__.AuthenticationManager(this.state, {\n            authenticate: (token)=>{\n                const message = this.state.setAuth(token);\n                this.webSocketManager.sendMessage(message);\n                return message.baseVersion;\n            },\n            stopSocket: ()=>this.webSocketManager.stop(),\n            tryRestartSocket: ()=>this.webSocketManager.tryRestart(),\n            pauseSocket,\n            resumeSocket: ()=>this.webSocketManager.resume(),\n            clearAuth: ()=>{\n                this.clearAuth();\n            }\n        }, {\n            logger: this.logger,\n            refreshTokenLeewaySeconds: authRefreshTokenLeewaySeconds\n        });\n        this.optimisticQueryResults = new _optimistic_updates_impl_js__WEBPACK_IMPORTED_MODULE_5__.OptimisticQueryResults();\n        this.addOnTransitionHandler((transition)=>{\n            onTransition(transition.queries.map((q)=>q.token));\n        });\n        this._nextRequestId = 0;\n        this._sessionId = (0,_session_js__WEBPACK_IMPORTED_MODULE_9__.newSessionId)();\n        const { unsavedChangesWarning } = options;\n        if ( false || typeof window.addEventListener === \"undefined\") {\n            if (unsavedChangesWarning === true) {\n                throw new Error(\"unsavedChangesWarning requested, but window.addEventListener not found! Remove {unsavedChangesWarning: true} from Convex client options.\");\n            }\n        } else if (unsavedChangesWarning !== false) {\n            window.addEventListener(\"beforeunload\", (e)=>{\n                if (this.requestManager.hasIncompleteRequests()) {\n                    e.preventDefault();\n                    const confirmationMessage = \"Are you sure you want to leave? Your changes may not be saved.\";\n                    (e || window.event).returnValue = confirmationMessage;\n                    return confirmationMessage;\n                }\n            });\n        }\n        this.webSocketManager = new _web_socket_manager_js__WEBPACK_IMPORTED_MODULE_8__.WebSocketManager(wsUri, {\n            onOpen: (reconnectMetadata)=>{\n                this.mark(\"convexWebSocketOpen\");\n                this.webSocketManager.sendMessage({\n                    ...reconnectMetadata,\n                    type: \"Connect\",\n                    sessionId: this._sessionId,\n                    maxObservedTimestamp: this.maxObservedTimestamp\n                });\n                const oldRemoteQueryResults = new Set(this.remoteQuerySet.remoteQueryResults().keys());\n                this.remoteQuerySet = new _remote_query_set_js__WEBPACK_IMPORTED_MODULE_6__.RemoteQuerySet((queryId)=>this.state.queryPath(queryId), this.logger);\n                const [querySetModification, authModification] = this.state.restart(oldRemoteQueryResults);\n                if (authModification) {\n                    this.webSocketManager.sendMessage(authModification);\n                }\n                this.webSocketManager.sendMessage(querySetModification);\n                for (const message of this.requestManager.restart()){\n                    this.webSocketManager.sendMessage(message);\n                }\n            },\n            onResume: ()=>{\n                const [querySetModification, authModification] = this.state.resume();\n                if (authModification) {\n                    this.webSocketManager.sendMessage(authModification);\n                }\n                if (querySetModification) {\n                    this.webSocketManager.sendMessage(querySetModification);\n                }\n                for (const message of this.requestManager.resume()){\n                    this.webSocketManager.sendMessage(message);\n                }\n            },\n            onMessage: (serverMessage)=>{\n                if (!this.firstMessageReceived) {\n                    this.firstMessageReceived = true;\n                    this.mark(\"convexFirstMessageReceived\");\n                    this.reportMarks();\n                }\n                switch(serverMessage.type){\n                    case \"Transition\":\n                        {\n                            this.observedTimestamp(serverMessage.endVersion.ts);\n                            this.authenticationManager.onTransition(serverMessage);\n                            this.remoteQuerySet.transition(serverMessage);\n                            this.state.transition(serverMessage);\n                            const completedRequests = this.requestManager.removeCompleted(this.remoteQuerySet.timestamp());\n                            this.notifyOnQueryResultChanges(completedRequests);\n                            break;\n                        }\n                    case \"MutationResponse\":\n                        {\n                            if (serverMessage.success) {\n                                this.observedTimestamp(serverMessage.ts);\n                            }\n                            const completedMutationInfo = this.requestManager.onResponse(serverMessage);\n                            if (completedMutationInfo !== null) {\n                                this.notifyOnQueryResultChanges(/* @__PURE__ */ new Map([\n                                    [\n                                        completedMutationInfo.requestId,\n                                        completedMutationInfo.result\n                                    ]\n                                ]));\n                            }\n                            break;\n                        }\n                    case \"ActionResponse\":\n                        {\n                            this.requestManager.onResponse(serverMessage);\n                            break;\n                        }\n                    case \"AuthError\":\n                        {\n                            this.authenticationManager.onAuthError(serverMessage);\n                            break;\n                        }\n                    case \"FatalError\":\n                        {\n                            const error = (0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.logFatalError)(this.logger, serverMessage.error);\n                            void this.webSocketManager.terminate();\n                            throw error;\n                        }\n                    default:\n                        {\n                            serverMessage;\n                        }\n                }\n                return {\n                    hasSyncedPastLastReconnect: this.hasSyncedPastLastReconnect()\n                };\n            },\n            onServerDisconnectError: options.onServerDisconnectError\n        }, webSocketConstructor, this.logger, this.markConnectionStateDirty, this.debug);\n        this.mark(\"convexClientConstructed\");\n        if (options.expectAuth) {\n            pauseSocket();\n        }\n    }\n} //# sourceMappingURL=client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYixJQUFJQSxZQUFZQyxPQUFPQyxjQUFjO0FBQ3JDLElBQUlDLGtCQUFrQixDQUFDQyxLQUFLQyxLQUFLQyxRQUFVRCxPQUFPRCxNQUFNSixVQUFVSSxLQUFLQyxLQUFLO1FBQUVFLFlBQVk7UUFBTUMsY0FBYztRQUFNQyxVQUFVO1FBQU1IO0lBQU0sS0FBS0YsR0FBRyxDQUFDQyxJQUFJLEdBQUdDO0FBQzFKLElBQUlJLGdCQUFnQixDQUFDTixLQUFLQyxLQUFLQyxRQUFVSCxnQkFBZ0JDLEtBQUssT0FBT0MsUUFBUSxXQUFXQSxNQUFNLEtBQUtBLEtBQUtDO0FBQy9EO0FBQ1k7QUFPOUI7QUFDMkI7QUFDSTtBQUdoQjtBQUNpQjtBQUNJO0FBQ0E7QUFDZjtBQUdQO0FBQ2U7QUFDcUI7QUFDcEI7QUFDUTtBQUN0RCxNQUFNMEI7SUEwUFg7Ozs7R0FJQyxHQUNEQyw2QkFBNkI7UUFDM0IsTUFBTUEsNkJBQTZCLElBQUksQ0FBQ0MsY0FBYyxDQUFDRCwwQkFBMEIsTUFBTSxJQUFJLENBQUNFLEtBQUssQ0FBQ0YsMEJBQTBCO1FBQzVILE9BQU9BO0lBQ1Q7SUFDQUcsa0JBQWtCQyxVQUFVLEVBQUU7UUFDNUIsSUFBSSxJQUFJLENBQUNDLG9CQUFvQixLQUFLLEtBQUssS0FBSyxJQUFJLENBQUNBLG9CQUFvQixDQUFDQyxlQUFlLENBQUNGLGFBQWE7WUFDakcsSUFBSSxDQUFDQyxvQkFBb0IsR0FBR0Q7UUFDOUI7SUFDRjtJQUNBRywwQkFBMEI7UUFDeEIsT0FBTyxJQUFJLENBQUNGLG9CQUFvQjtJQUNsQztJQUNBOzs7Ozs7O0dBT0MsR0FDREcsMkJBQTJCQyxpQkFBaUIsRUFBRTtRQUM1QyxNQUFNQyxxQkFBcUIsSUFBSSxDQUFDQyxjQUFjLENBQUNELGtCQUFr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QWE7NEJBQ2hCLElBQUksQ0FBQzdJLHFCQUFxQixDQUFDb0osV0FBVyxDQUFDUDs0QkFDdkM7d0JBQ0Y7b0JBQ0EsS0FBSzt3QkFBYzs0QkFDakIsTUFBTS9DLFFBQVF2SywwREFBYUEsQ0FBQyxJQUFJLENBQUNnSSxNQUFNLEVBQUVzRixjQUFjL0MsS0FBSzs0QkFDNUQsS0FBSyxJQUFJLENBQUN4RixnQkFBZ0IsQ0FBQytELFNBQVM7NEJBQ3BDLE1BQU15Qjt3QkFDUjtvQkFDQTt3QkFBUzs0QkFDUCtDO3dCQUNGO2dCQUNGO2dCQUNBLE9BQU87b0JBQ0x0TSw0QkFBNEIsSUFBSSxDQUFDQSwwQkFBMEI7Z0JBQzdEO1lBQ0Y7WUFDQThNLHlCQUF5QjFJLFFBQVEwSSx1QkFBdUI7UUFDMUQsR0FDQS9DLHNCQUNBLElBQUksQ0FBQy9DLE1BQU0sRUFDWCxJQUFJLENBQUMwRCx3QkFBd0IsRUFDN0IsSUFBSSxDQUFDdEMsS0FBSztRQUVaLElBQUksQ0FBQzFJLElBQUksQ0FBQztRQUNWLElBQUkwRSxRQUFRMkksVUFBVSxFQUFFO1lBQ3RCcEM7UUFDRjtJQUNGO0FBMmNGLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL2NsaWVudC5qcz85ZmMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vLi4vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbnZleFRvSnNvbiB9IGZyb20gXCIuLi8uLi92YWx1ZXMvaW5kZXguanNcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZUh5YnJpZEVycm9yU3RhY2t0cmFjZSxcbiAgZm9yd2FyZERhdGEsXG4gIGluc3RhbnRpYXRlRGVmYXVsdExvZ2dlcixcbiAgaW5zdGFudGlhdGVOb29wTG9nZ2VyLFxuICBsb2dGYXRhbEVycm9yXG59IGZyb20gXCIuLi9sb2dnaW5nLmpzXCI7XG5pbXBvcnQgeyBMb2NhbFN5bmNTdGF0ZSB9IGZyb20gXCIuL2xvY2FsX3N0YXRlLmpzXCI7XG5pbXBvcnQgeyBSZXF1ZXN0TWFuYWdlciB9IGZyb20gXCIuL3JlcXVlc3RfbWFuYWdlci5qc1wiO1xuaW1wb3J0IHtcbiAgT3B0aW1pc3RpY1F1ZXJ5UmVzdWx0c1xufSBmcm9tIFwiLi9vcHRpbWlzdGljX3VwZGF0ZXNfaW1wbC5qc1wiO1xuaW1wb3J0IHsgUmVtb3RlUXVlcnlTZXQgfSBmcm9tIFwiLi9yZW1vdGVfcXVlcnlfc2V0LmpzXCI7XG5pbXBvcnQgeyBzZXJpYWxpemVQYXRoQW5kQXJncyB9IGZyb20gXCIuL3VkZl9wYXRoX3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBXZWJTb2NrZXRNYW5hZ2VyIH0gZnJvbSBcIi4vd2ViX3NvY2tldF9tYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBuZXdTZXNzaW9uSWQgfSBmcm9tIFwiLi9zZXNzaW9uLmpzXCI7XG5pbXBvcnQge1xuICBBdXRoZW50aWNhdGlvbk1hbmFnZXJcbn0gZnJvbSBcIi4vYXV0aGVudGljYXRpb25fbWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgZ2V0TWFya3NSZXBvcnQsIG1hcmsgfSBmcm9tIFwiLi9tZXRyaWNzLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUFyZ3MsIHZhbGlkYXRlRGVwbG95bWVudFVybCB9IGZyb20gXCIuLi8uLi9jb21tb24vaW5kZXguanNcIjtcbmltcG9ydCB7IENvbnZleEVycm9yIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9lcnJvcnMuanNcIjtcbmltcG9ydCB7IGp3dERlY29kZSB9IGZyb20gXCIuLi8uLi92ZW5kb3Ivand0LWRlY29kZS9pbmRleC5qc1wiO1xuZXhwb3J0IGNsYXNzIEJhc2VDb252ZXhDbGllbnQge1xuICAvKipcbiAgICogQHBhcmFtIGFkZHJlc3MgLSBUaGUgdXJsIG9mIHlvdXIgQ29udmV4IGRlcGxveW1lbnQsIG9mdGVuIHByb3ZpZGVkXG4gICAqIGJ5IGFuIGVudmlyb25tZW50IHZhcmlhYmxlLiBFLmcuIGBodHRwczovL3NtYWxsLW1vdXNlLTEyMy5jb252ZXguY2xvdWRgLlxuICAgKiBAcGFyYW0gb25UcmFuc2l0aW9uIC0gQSBjYWxsYmFjayByZWNlaXZpbmcgYW4gYXJyYXkgb2YgcXVlcnkgdG9rZW5zXG4gICAqIGNvcnJlc3BvbmRpbmcgdG8gcXVlcnkgcmVzdWx0cyB0aGF0IGhhdmUgY2hhbmdlZCAtLSBhZGRpdGlvbmFsIGhhbmRsZXJzXG4gICAqIGNhbiBiZSBhZGRlZCB2aWEgYGFkZE9uVHJhbnNpdGlvbkhhbmRsZXJgLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFNlZSB7QGxpbmsgQmFzZUNvbnZleENsaWVudE9wdGlvbnN9IGZvciBhIGZ1bGwgZGVzY3JpcHRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBvblRyYW5zaXRpb24sIG9wdGlvbnMpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYWRkcmVzc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RhdGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlcXVlc3RNYW5hZ2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ3ZWJTb2NrZXRNYW5hZ2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhdXRoZW50aWNhdGlvbk1hbmFnZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlbW90ZVF1ZXJ5U2V0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvcHRpbWlzdGljUXVlcnlSZXN1bHRzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfdHJhbnNpdGlvbkhhbmRsZXJDb3VudGVyXCIsIDApO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbmV4dFJlcXVlc3RJZFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX29uVHJhbnNpdGlvbkZuc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3Nlc3Npb25JZFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZmlyc3RNZXNzYWdlUmVjZWl2ZWRcIiwgZmFsc2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkZWJ1Z1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibG9nZ2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtYXhPYnNlcnZlZFRpbWVzdGFtcFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29ubmVjdGlvblN0YXRlU3Vic2NyaWJlcnNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5leHRDb25uZWN0aW9uU3RhdGVTdWJzY3JpYmVySWRcIiwgMCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9sYXN0UHVibGlzaGVkQ29ubmVjdGlvblN0YXRlXCIpO1xuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGUgY29ubmVjdGlvbiBzdGF0ZSBtYXkgaGF2ZSBjaGFuZ2VkIGluIGEgd2F5IHRoYXQgY291bGRcbiAgICAgKiByZXF1aXJlIHB1Ymxpc2hpbmcgaXQuIFNjaGVkdWxlcyBhIHBvc3NpYmx5IHVwZGF0ZS5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5XCIsICgpID0+IHtcbiAgICAgIHZvaWQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1ckNvbm5lY3Rpb25TdGF0ZSA9IHRoaXMuY29ubmVjdGlvblN0YXRlKCk7XG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShjdXJDb25uZWN0aW9uU3RhdGUpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLl9sYXN0UHVibGlzaGVkQ29ubmVjdGlvblN0YXRlKSkge1xuICAgICAgICAgIHRoaXMuX2xhc3RQdWJsaXNoZWRDb25uZWN0aW9uU3RhdGUgPSBjdXJDb25uZWN0aW9uU3RhdGU7XG4gICAgICAgICAgZm9yIChjb25zdCBjYiBvZiB0aGlzLmNvbm5lY3Rpb25TdGF0ZVN1YnNjcmliZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBjYihjdXJDb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gSW5zdGFuY2UgcHJvcGVydHkgc28gdGhhdCBgbWFyaygpYCBkb2Vzbid0IG5lZWQgdG8gYmUgY2FsbGVkIGFzIGEgbWV0aG9kLlxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtYXJrXCIsIChuYW1lKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICBtYXJrKG5hbWUsIHRoaXMuc2Vzc2lvbklkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGFkZHJlc3MgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJQYXNzaW5nIGEgQ2xpZW50Q29uZmlnIG9iamVjdCBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBQYXNzIHRoZSBVUkwgb2YgdGhlIENvbnZleCBkZXBsb3ltZW50IGFzIGEgc3RyaW5nIGRpcmVjdGx5LlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucz8uc2tpcENvbnZleERlcGxveW1lbnRVcmxDaGVjayAhPT0gdHJ1ZSkge1xuICAgICAgdmFsaWRhdGVEZXBsb3ltZW50VXJsKGFkZHJlc3MpO1xuICAgIH1cbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgYXV0aFJlZnJlc2hUb2tlbkxlZXdheVNlY29uZHMgPSBvcHRpb25zLmF1dGhSZWZyZXNoVG9rZW5MZWV3YXlTZWNvbmRzID8/IDI7XG4gICAgbGV0IHdlYlNvY2tldENvbnN0cnVjdG9yID0gb3B0aW9ucy53ZWJTb2NrZXRDb25zdHJ1Y3RvcjtcbiAgICBpZiAoIXdlYlNvY2tldENvbnN0cnVjdG9yICYmIHR5cGVvZiBXZWJTb2NrZXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJObyBXZWJTb2NrZXQgZ2xvYmFsIHZhcmlhYmxlIGRlZmluZWQhIFRvIHVzZSBDb252ZXggaW4gYW4gZW52aXJvbm1lbnQgd2l0aG91dCBXZWJTb2NrZXQgdHJ5IHRoZSBIVFRQIGNsaWVudDogaHR0cHM6Ly9kb2NzLmNvbnZleC5kZXYvYXBpL2NsYXNzZXMvYnJvd3Nlci5Db252ZXhIdHRwQ2xpZW50XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHdlYlNvY2tldENvbnN0cnVjdG9yID0gd2ViU29ja2V0Q29uc3RydWN0b3IgfHwgV2ViU29ja2V0O1xuICAgIHRoaXMuZGVidWcgPSBvcHRpb25zLnJlcG9ydERlYnVnSW5mb1RvQ29udmV4ID8/IGZhbHNlO1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgdGhpcy5sb2dnZXIgPSBvcHRpb25zLmxvZ2dlciA9PT0gZmFsc2UgPyBpbnN0YW50aWF0ZU5vb3BMb2dnZXIoeyB2ZXJib3NlOiBvcHRpb25zLnZlcmJvc2UgPz8gZmFsc2UgfSkgOiBvcHRpb25zLmxvZ2dlciAhPT0gdHJ1ZSAmJiBvcHRpb25zLmxvZ2dlciA/IG9wdGlvbnMubG9nZ2VyIDogaW5zdGFudGlhdGVEZWZhdWx0TG9nZ2VyKHsgdmVyYm9zZTogb3B0aW9ucy52ZXJib3NlID8/IGZhbHNlIH0pO1xuICAgIGNvbnN0IGkgPSBhZGRyZXNzLnNlYXJjaChcIjovL1wiKTtcbiAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVkIGFkZHJlc3Mgd2FzIG5vdCBhbiBhYnNvbHV0ZSBVUkwuXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW4gPSBhZGRyZXNzLnN1YnN0cmluZyhpICsgMyk7XG4gICAgY29uc3QgcHJvdG9jb2wgPSBhZGRyZXNzLnN1YnN0cmluZygwLCBpKTtcbiAgICBsZXQgd3NQcm90b2NvbDtcbiAgICBpZiAocHJvdG9jb2wgPT09IFwiaHR0cFwiKSB7XG4gICAgICB3c1Byb3RvY29sID0gXCJ3c1wiO1xuICAgIH0gZWxzZSBpZiAocHJvdG9jb2wgPT09IFwiaHR0cHNcIikge1xuICAgICAgd3NQcm90b2NvbCA9IFwid3NzXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJlbnQgcHJvdG9jb2wgJHtwcm90b2NvbH1gKTtcbiAgICB9XG4gICAgY29uc3Qgd3NVcmkgPSBgJHt3c1Byb3RvY29sfTovLyR7b3JpZ2lufS9hcGkvJHt2ZXJzaW9ufS9zeW5jYDtcbiAgICB0aGlzLnN0YXRlID0gbmV3IExvY2FsU3luY1N0YXRlKCk7XG4gICAgdGhpcy5yZW1vdGVRdWVyeVNldCA9IG5ldyBSZW1vdGVRdWVyeVNldChcbiAgICAgIChxdWVyeUlkKSA9PiB0aGlzLnN0YXRlLnF1ZXJ5UGF0aChxdWVyeUlkKSxcbiAgICAgIHRoaXMubG9nZ2VyXG4gICAgKTtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gbmV3IFJlcXVlc3RNYW5hZ2VyKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICB0aGlzLm1hcmtDb25uZWN0aW9uU3RhdGVEaXJ0eVxuICAgICk7XG4gICAgY29uc3QgcGF1c2VTb2NrZXQgPSAoKSA9PiB7XG4gICAgICB0aGlzLndlYlNvY2tldE1hbmFnZXIucGF1c2UoKTtcbiAgICAgIHRoaXMuc3RhdGUucGF1c2UoKTtcbiAgICB9O1xuICAgIHRoaXMuYXV0aGVudGljYXRpb25NYW5hZ2VyID0gbmV3IEF1dGhlbnRpY2F0aW9uTWFuYWdlcihcbiAgICAgIHRoaXMuc3RhdGUsXG4gICAgICB7XG4gICAgICAgIGF1dGhlbnRpY2F0ZTogKHRva2VuKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuc3RhdGUuc2V0QXV0aCh0b2tlbik7XG4gICAgICAgICAgdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlLmJhc2VWZXJzaW9uO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wU29ja2V0OiAoKSA9PiB0aGlzLndlYlNvY2tldE1hbmFnZXIuc3RvcCgpLFxuICAgICAgICB0cnlSZXN0YXJ0U29ja2V0OiAoKSA9PiB0aGlzLndlYlNvY2tldE1hbmFnZXIudHJ5UmVzdGFydCgpLFxuICAgICAgICBwYXVzZVNvY2tldCxcbiAgICAgICAgcmVzdW1lU29ja2V0OiAoKSA9PiB0aGlzLndlYlNvY2tldE1hbmFnZXIucmVzdW1lKCksXG4gICAgICAgIGNsZWFyQXV0aDogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuY2xlYXJBdXRoKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGxvZ2dlcjogdGhpcy5sb2dnZXIsXG4gICAgICAgIHJlZnJlc2hUb2tlbkxlZXdheVNlY29uZHM6IGF1dGhSZWZyZXNoVG9rZW5MZWV3YXlTZWNvbmRzXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLm9wdGltaXN0aWNRdWVyeVJlc3VsdHMgPSBuZXcgT3B0aW1pc3RpY1F1ZXJ5UmVzdWx0cygpO1xuICAgIHRoaXMuYWRkT25UcmFuc2l0aW9uSGFuZGxlcigodHJhbnNpdGlvbikgPT4ge1xuICAgICAgb25UcmFuc2l0aW9uKHRyYW5zaXRpb24ucXVlcmllcy5tYXAoKHEpID0+IHEudG9rZW4pKTtcbiAgICB9KTtcbiAgICB0aGlzLl9uZXh0UmVxdWVzdElkID0gMDtcbiAgICB0aGlzLl9zZXNzaW9uSWQgPSBuZXdTZXNzaW9uSWQoKTtcbiAgICBjb25zdCB7IHVuc2F2ZWRDaGFuZ2VzV2FybmluZyB9ID0gb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmICh1bnNhdmVkQ2hhbmdlc1dhcm5pbmcgPT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwidW5zYXZlZENoYW5nZXNXYXJuaW5nIHJlcXVlc3RlZCwgYnV0IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIG5vdCBmb3VuZCEgUmVtb3ZlIHt1bnNhdmVkQ2hhbmdlc1dhcm5pbmc6IHRydWV9IGZyb20gQ29udmV4IGNsaWVudCBvcHRpb25zLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh1bnNhdmVkQ2hhbmdlc1dhcm5pbmcgIT09IGZhbHNlKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCAoZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0TWFuYWdlci5oYXNJbmNvbXBsZXRlUmVxdWVzdHMoKSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBjb25zdCBjb25maXJtYXRpb25NZXNzYWdlID0gXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gbGVhdmU/IFlvdXIgY2hhbmdlcyBtYXkgbm90IGJlIHNhdmVkLlwiO1xuICAgICAgICAgIChlIHx8IHdpbmRvdy5ldmVudCkucmV0dXJuVmFsdWUgPSBjb25maXJtYXRpb25NZXNzYWdlO1xuICAgICAgICAgIHJldHVybiBjb25maXJtYXRpb25NZXNzYWdlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy53ZWJTb2NrZXRNYW5hZ2VyID0gbmV3IFdlYlNvY2tldE1hbmFnZXIoXG4gICAgICB3c1VyaSxcbiAgICAgIHtcbiAgICAgICAgb25PcGVuOiAocmVjb25uZWN0TWV0YWRhdGEpID0+IHtcbiAgICAgICAgICB0aGlzLm1hcmsoXCJjb252ZXhXZWJTb2NrZXRPcGVuXCIpO1xuICAgICAgICAgIHRoaXMud2ViU29ja2V0TWFuYWdlci5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAuLi5yZWNvbm5lY3RNZXRhZGF0YSxcbiAgICAgICAgICAgIHR5cGU6IFwiQ29ubmVjdFwiLFxuICAgICAgICAgICAgc2Vzc2lvbklkOiB0aGlzLl9zZXNzaW9uSWQsXG4gICAgICAgICAgICBtYXhPYnNlcnZlZFRpbWVzdGFtcDogdGhpcy5tYXhPYnNlcnZlZFRpbWVzdGFtcFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IG9sZFJlbW90ZVF1ZXJ5UmVzdWx0cyA9IG5ldyBTZXQoXG4gICAgICAgICAgICB0aGlzLnJlbW90ZVF1ZXJ5U2V0LnJlbW90ZVF1ZXJ5UmVzdWx0cygpLmtleXMoKVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5yZW1vdGVRdWVyeVNldCA9IG5ldyBSZW1vdGVRdWVyeVNldChcbiAgICAgICAgICAgIChxdWVyeUlkKSA9PiB0aGlzLnN0YXRlLnF1ZXJ5UGF0aChxdWVyeUlkKSxcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBbcXVlcnlTZXRNb2RpZmljYXRpb24sIGF1dGhNb2RpZmljYXRpb25dID0gdGhpcy5zdGF0ZS5yZXN0YXJ0KFxuICAgICAgICAgICAgb2xkUmVtb3RlUXVlcnlSZXN1bHRzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoYXV0aE1vZGlmaWNhdGlvbikge1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnNlbmRNZXNzYWdlKGF1dGhNb2RpZmljYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLndlYlNvY2tldE1hbmFnZXIuc2VuZE1lc3NhZ2UocXVlcnlTZXRNb2RpZmljYXRpb24pO1xuICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiB0aGlzLnJlcXVlc3RNYW5hZ2VyLnJlc3RhcnQoKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25SZXN1bWU6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBbcXVlcnlTZXRNb2RpZmljYXRpb24sIGF1dGhNb2RpZmljYXRpb25dID0gdGhpcy5zdGF0ZS5yZXN1bWUoKTtcbiAgICAgICAgICBpZiAoYXV0aE1vZGlmaWNhdGlvbikge1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnNlbmRNZXNzYWdlKGF1dGhNb2RpZmljYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocXVlcnlTZXRNb2RpZmljYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0TWFuYWdlci5zZW5kTWVzc2FnZShxdWVyeVNldE1vZGlmaWNhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiB0aGlzLnJlcXVlc3RNYW5hZ2VyLnJlc3VtZSgpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldE1hbmFnZXIuc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbk1lc3NhZ2U6IChzZXJ2ZXJNZXNzYWdlKSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLmZpcnN0TWVzc2FnZVJlY2VpdmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0TWVzc2FnZVJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWFyayhcImNvbnZleEZpcnN0TWVzc2FnZVJlY2VpdmVkXCIpO1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRNYXJrcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKHNlcnZlck1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIlRyYW5zaXRpb25cIjoge1xuICAgICAgICAgICAgICB0aGlzLm9ic2VydmVkVGltZXN0YW1wKHNlcnZlck1lc3NhZ2UuZW5kVmVyc2lvbi50cyk7XG4gICAgICAgICAgICAgIHRoaXMuYXV0aGVudGljYXRpb25NYW5hZ2VyLm9uVHJhbnNpdGlvbihzZXJ2ZXJNZXNzYWdlKTtcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdGVRdWVyeVNldC50cmFuc2l0aW9uKHNlcnZlck1lc3NhZ2UpO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlLnRyYW5zaXRpb24oc2VydmVyTWVzc2FnZSk7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlZFJlcXVlc3RzID0gdGhpcy5yZXF1ZXN0TWFuYWdlci5yZW1vdmVDb21wbGV0ZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdGVRdWVyeVNldC50aW1lc3RhbXAoKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0aGlzLm5vdGlmeU9uUXVlcnlSZXN1bHRDaGFuZ2VzKGNvbXBsZXRlZFJlcXVlc3RzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiTXV0YXRpb25SZXNwb25zZVwiOiB7XG4gICAgICAgICAgICAgIGlmIChzZXJ2ZXJNZXNzYWdlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVkVGltZXN0YW1wKHNlcnZlck1lc3NhZ2UudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlZE11dGF0aW9uSW5mbyA9IHRoaXMucmVxdWVzdE1hbmFnZXIub25SZXNwb25zZShzZXJ2ZXJNZXNzYWdlKTtcbiAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZE11dGF0aW9uSW5mbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5T25RdWVyeVJlc3VsdENoYW5nZXMoXG4gICAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWRNdXRhdGlvbkluZm8ucmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZE11dGF0aW9uSW5mby5yZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIkFjdGlvblJlc3BvbnNlXCI6IHtcbiAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0TWFuYWdlci5vblJlc3BvbnNlKHNlcnZlck1lc3NhZ2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJBdXRoRXJyb3JcIjoge1xuICAgICAgICAgICAgICB0aGlzLmF1dGhlbnRpY2F0aW9uTWFuYWdlci5vbkF1dGhFcnJvcihzZXJ2ZXJNZXNzYWdlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiRmF0YWxFcnJvclwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbG9nRmF0YWxFcnJvcih0aGlzLmxvZ2dlciwgc2VydmVyTWVzc2FnZS5lcnJvcik7XG4gICAgICAgICAgICAgIHZvaWQgdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgc2VydmVyTWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhhc1N5bmNlZFBhc3RMYXN0UmVjb25uZWN0OiB0aGlzLmhhc1N5bmNlZFBhc3RMYXN0UmVjb25uZWN0KClcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBvblNlcnZlckRpc2Nvbm5lY3RFcnJvcjogb3B0aW9ucy5vblNlcnZlckRpc2Nvbm5lY3RFcnJvclxuICAgICAgfSxcbiAgICAgIHdlYlNvY2tldENvbnN0cnVjdG9yLFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICB0aGlzLm1hcmtDb25uZWN0aW9uU3RhdGVEaXJ0eSxcbiAgICAgIHRoaXMuZGVidWdcbiAgICApO1xuICAgIHRoaXMubWFyayhcImNvbnZleENsaWVudENvbnN0cnVjdGVkXCIpO1xuICAgIGlmIChvcHRpb25zLmV4cGVjdEF1dGgpIHtcbiAgICAgIHBhdXNlU29ja2V0KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBvdXRzdGFuZGluZyB3b3JrIGZyb20gcHJpb3IgdG8gdGhlIHRpbWUgb2YgdGhlIG1vc3QgcmVjZW50IHJlc3RhcnQuXG4gICAqIFRoaXMgaW5kaWNhdGVzIHRoYXQgdGhlIGNsaWVudCBoYXMgbm90IHByb3ZlbiBpdHNlbGYgdG8gaGF2ZSBnb3R0ZW4gcGFzdCB0aGUgaXNzdWUgdGhhdFxuICAgKiBwb3RlbnRpYWxseSBsZWQgdG8gdGhlIHJlc3RhcnQuIFVzZSB0aGlzIHRvIGluZmx1ZW5jZSB3aGVuIHRvIHJlc2V0IGJhY2tvZmYgYWZ0ZXIgYSBmYWlsdXJlLlxuICAgKi9cbiAgaGFzU3luY2VkUGFzdExhc3RSZWNvbm5lY3QoKSB7XG4gICAgY29uc3QgaGFzU3luY2VkUGFzdExhc3RSZWNvbm5lY3QgPSB0aGlzLnJlcXVlc3RNYW5hZ2VyLmhhc1N5bmNlZFBhc3RMYXN0UmVjb25uZWN0KCkgfHwgdGhpcy5zdGF0ZS5oYXNTeW5jZWRQYXN0TGFzdFJlY29ubmVjdCgpO1xuICAgIHJldHVybiBoYXNTeW5jZWRQYXN0TGFzdFJlY29ubmVjdDtcbiAgfVxuICBvYnNlcnZlZFRpbWVzdGFtcChvYnNlcnZlZFRzKSB7XG4gICAgaWYgKHRoaXMubWF4T2JzZXJ2ZWRUaW1lc3RhbXAgPT09IHZvaWQgMCB8fCB0aGlzLm1heE9ic2VydmVkVGltZXN0YW1wLmxlc3NUaGFuT3JFcXVhbChvYnNlcnZlZFRzKSkge1xuICAgICAgdGhpcy5tYXhPYnNlcnZlZFRpbWVzdGFtcCA9IG9ic2VydmVkVHM7XG4gICAgfVxuICB9XG4gIGdldE1heE9ic2VydmVkVGltZXN0YW1wKCkge1xuICAgIHJldHVybiB0aGlzLm1heE9ic2VydmVkVGltZXN0YW1wO1xuICB9XG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBjdXJyZW50IHF1ZXJ5IHJlc3VsdHMgYmFzZWQgb24gdGhlIHJlbW90ZVF1ZXJ5U2V0IGFuZCB0aGVcbiAgICogY3VycmVudCBvcHRpbWlzdGljIHVwZGF0ZXMgYW5kIGNhbGwgYG9uVHJhbnNpdGlvbmAgZm9yIGFsbCB0aGUgY2hhbmdlZFxuICAgKiBxdWVyaWVzLlxuICAgKlxuICAgKiBAcGFyYW0gY29tcGxldGVkTXV0YXRpb25zIC0gQSBzZXQgb2YgbXV0YXRpb24gSURzIHdob3NlIG9wdGltaXN0aWMgdXBkYXRlc1xuICAgKiBhcmUgbm8gbG9uZ2VyIG5lZWRlZC5cbiAgICovXG4gIG5vdGlmeU9uUXVlcnlSZXN1bHRDaGFuZ2VzKGNvbXBsZXRlZFJlcXVlc3RzKSB7XG4gICAgY29uc3QgcmVtb3RlUXVlcnlSZXN1bHRzID0gdGhpcy5yZW1vdGVRdWVyeVNldC5yZW1vdGVRdWVyeVJlc3VsdHMoKTtcbiAgICBjb25zdCBxdWVyeVRva2VuVG9WYWx1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbcXVlcnlJZCwgcmVzdWx0XSBvZiByZW1vdGVRdWVyeVJlc3VsdHMpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5VG9rZW4gPSB0aGlzLnN0YXRlLnF1ZXJ5VG9rZW4ocXVlcnlJZCk7XG4gICAgICBpZiAocXVlcnlUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBxdWVyeSA9IHtcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgdWRmUGF0aDogdGhpcy5zdGF0ZS5xdWVyeVBhdGgocXVlcnlJZCksXG4gICAgICAgICAgYXJnczogdGhpcy5zdGF0ZS5xdWVyeUFyZ3MocXVlcnlJZClcbiAgICAgICAgfTtcbiAgICAgICAgcXVlcnlUb2tlblRvVmFsdWUuc2V0KHF1ZXJ5VG9rZW4sIHF1ZXJ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2hhbmdlZFF1ZXJ5VG9rZW5zID0gdGhpcy5vcHRpbWlzdGljUXVlcnlSZXN1bHRzLmluZ2VzdFF1ZXJ5UmVzdWx0c0Zyb21TZXJ2ZXIoXG4gICAgICBxdWVyeVRva2VuVG9WYWx1ZSxcbiAgICAgIG5ldyBTZXQoY29tcGxldGVkUmVxdWVzdHMua2V5cygpKVxuICAgICk7XG4gICAgdGhpcy5oYW5kbGVUcmFuc2l0aW9uKHtcbiAgICAgIHF1ZXJpZXM6IGNoYW5nZWRRdWVyeVRva2Vucy5tYXAoKHRva2VuKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNSZXN1bHQgPSB0aGlzLm9wdGltaXN0aWNRdWVyeVJlc3VsdHMucmF3UXVlcnlSZXN1bHQodG9rZW4pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRva2VuLFxuICAgICAgICAgIG1vZGlmaWNhdGlvbjoge1xuICAgICAgICAgICAga2luZDogXCJVcGRhdGVkXCIsXG4gICAgICAgICAgICByZXN1bHQ6IG9wdGltaXN0aWNSZXN1bHRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIHJlZmxlY3RlZE11dGF0aW9uczogQXJyYXkuZnJvbShjb21wbGV0ZWRSZXF1ZXN0cykubWFwKFxuICAgICAgICAoW3JlcXVlc3RJZCwgcmVzdWx0XSkgPT4gKHtcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgcmVzdWx0XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgdGltZXN0YW1wOiB0aGlzLnJlbW90ZVF1ZXJ5U2V0LnRpbWVzdGFtcCgpXG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlVHJhbnNpdGlvbih0cmFuc2l0aW9uKSB7XG4gICAgZm9yIChjb25zdCBmbiBvZiB0aGlzLl9vblRyYW5zaXRpb25GbnMudmFsdWVzKCkpIHtcbiAgICAgIGZuKHRyYW5zaXRpb24pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkIGEgaGFuZGxlciB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uIGEgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogQW55IGV4dGVybmFsIHNpZGUgZWZmZWN0cyAoZS5nLiBzZXR0aW5nIFJlYWN0IHN0YXRlKSBzaG91bGQgYmUgaGFuZGxlZCBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0gZm5cbiAgICpcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFkZE9uVHJhbnNpdGlvbkhhbmRsZXIoZm4pIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuX3RyYW5zaXRpb25IYW5kbGVyQ291bnRlcisrO1xuICAgIHRoaXMuX29uVHJhbnNpdGlvbkZucy5zZXQoaWQsIGZuKTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5fb25UcmFuc2l0aW9uRm5zLmRlbGV0ZShpZCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBKV1QgYXV0aCB0b2tlbiBhbmQgZGVjb2RlZCBjbGFpbXMuXG4gICAqL1xuICBnZXRDdXJyZW50QXV0aENsYWltcygpIHtcbiAgICBjb25zdCBhdXRoVG9rZW4gPSB0aGlzLnN0YXRlLmdldEF1dGgoKTtcbiAgICBsZXQgZGVjb2RlZCA9IHt9O1xuICAgIGlmIChhdXRoVG9rZW4gJiYgYXV0aFRva2VuLnRva2VuVHlwZSA9PT0gXCJVc2VyXCIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRlY29kZWQgPSBhdXRoVG9rZW4gPyBqd3REZWNvZGUoYXV0aFRva2VuLnZhbHVlKSA6IHt9O1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIGRlY29kZWQgPSB7fTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHsgdG9rZW46IGF1dGhUb2tlbi52YWx1ZSwgZGVjb2RlZCB9O1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuIHRvIGJlIHVzZWQgZm9yIHN1YnNlcXVlbnQgcXVlcmllcyBhbmQgbXV0YXRpb25zLlxuICAgKiBgZmV0Y2hUb2tlbmAgd2lsbCBiZSBjYWxsZWQgYXV0b21hdGljYWxseSBhZ2FpbiBpZiBhIHRva2VuIGV4cGlyZXMuXG4gICAqIGBmZXRjaFRva2VuYCBzaG91bGQgcmV0dXJuIGBudWxsYCBpZiB0aGUgdG9rZW4gY2Fubm90IGJlIHJldHJpZXZlZCwgZm9yIGV4YW1wbGVcbiAgICogd2hlbiB0aGUgdXNlcidzIHJpZ2h0cyB3ZXJlIHBlcm1hbmVudGx5IHJldm9rZWQuXG4gICAqIEBwYXJhbSBmZXRjaFRva2VuIC0gYW4gYXN5bmMgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBKV1QtZW5jb2RlZCBPcGVuSUQgQ29ubmVjdCBJZGVudGl0eSBUb2tlblxuICAgKiBAcGFyYW0gb25DaGFuZ2UgLSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYXV0aGVudGljYXRpb24gc3RhdHVzIGNoYW5nZXNcbiAgICovXG4gIHNldEF1dGgoZmV0Y2hUb2tlbiwgb25DaGFuZ2UpIHtcbiAgICB2b2lkIHRoaXMuYXV0aGVudGljYXRpb25NYW5hZ2VyLnNldENvbmZpZyhmZXRjaFRva2VuLCBvbkNoYW5nZSk7XG4gIH1cbiAgaGFzQXV0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5oYXNBdXRoKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRBZG1pbkF1dGgodmFsdWUsIGZha2VVc2VySWRlbnRpdHkpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5zdGF0ZS5zZXRBZG1pbkF1dGgodmFsdWUsIGZha2VVc2VySWRlbnRpdHkpO1xuICAgIHRoaXMud2ViU29ja2V0TWFuYWdlci5zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgfVxuICBjbGVhckF1dGgoKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuc3RhdGUuY2xlYXJBdXRoKCk7XG4gICAgdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICB9XG4gIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byBhIHF1ZXJ5IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogV2hlbmV2ZXIgdGhpcyBxdWVyeSdzIHJlc3VsdCBjaGFuZ2VzLCB0aGUgYG9uVHJhbnNpdGlvbmAgY2FsbGJhY2tcbiAgICAgKiBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3Igd2lsbCBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBxdWVyeS5cbiAgICAgKiBAcGFyYW0gYXJncyAtIEFuIGFyZ3VtZW50cyBvYmplY3QgZm9yIHRoZSBxdWVyeS4gSWYgdGhpcyBpcyBvbWl0dGVkLCB0aGVcbiAgICAgKiBhcmd1bWVudHMgd2lsbCBiZSBge31gLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQSB7QGxpbmsgU3Vic2NyaWJlT3B0aW9uc30gb3B0aW9ucyBvYmplY3QgZm9yIHRoaXMgcXVlcnkuXG4gIFxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIGEge0BsaW5rIFF1ZXJ5VG9rZW59IGNvcnJlc3BvbmRpbmcgdG8gdGhpc1xuICAgICAqIHF1ZXJ5IGFuZCBhbiBgdW5zdWJzY3JpYmVgIGNhbGxiYWNrLlxuICAgICAqL1xuICBzdWJzY3JpYmUobmFtZSwgYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGFyZ3NPYmplY3QgPSBwYXJzZUFyZ3MoYXJncyk7XG4gICAgY29uc3QgeyBtb2RpZmljYXRpb24sIHF1ZXJ5VG9rZW4sIHVuc3Vic2NyaWJlIH0gPSB0aGlzLnN0YXRlLnN1YnNjcmliZShcbiAgICAgIG5hbWUsXG4gICAgICBhcmdzT2JqZWN0LFxuICAgICAgb3B0aW9ucz8uam91cm5hbCxcbiAgICAgIG9wdGlvbnM/LmNvbXBvbmVudFBhdGhcbiAgICApO1xuICAgIGlmIChtb2RpZmljYXRpb24gIT09IG51bGwpIHtcbiAgICAgIHRoaXMud2ViU29ja2V0TWFuYWdlci5zZW5kTWVzc2FnZShtb2RpZmljYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcXVlcnlUb2tlbixcbiAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vZGlmaWNhdGlvbjIgPSB1bnN1YnNjcmliZSgpO1xuICAgICAgICBpZiAobW9kaWZpY2F0aW9uMikge1xuICAgICAgICAgIHRoaXMud2ViU29ja2V0TWFuYWdlci5zZW5kTWVzc2FnZShtb2RpZmljYXRpb24yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEEgcXVlcnkgcmVzdWx0IGJhc2VkIG9ubHkgb24gdGhlIGN1cnJlbnQsIGxvY2FsIHN0YXRlLlxuICAgKlxuICAgKiBUaGUgb25seSB3YXkgdGhpcyB3aWxsIHJldHVybiBhIHZhbHVlIGlzIGlmIHdlJ3JlIGFscmVhZHkgc3Vic2NyaWJlZCB0byB0aGVcbiAgICogcXVlcnkgb3IgaXRzIHZhbHVlIGhhcyBiZWVuIHNldCBvcHRpbWlzdGljYWxseS5cbiAgICovXG4gIGxvY2FsUXVlcnlSZXN1bHQodWRmUGF0aCwgYXJncykge1xuICAgIGNvbnN0IGFyZ3NPYmplY3QgPSBwYXJzZUFyZ3MoYXJncyk7XG4gICAgY29uc3QgcXVlcnlUb2tlbiA9IHNlcmlhbGl6ZVBhdGhBbmRBcmdzKHVkZlBhdGgsIGFyZ3NPYmplY3QpO1xuICAgIHJldHVybiB0aGlzLm9wdGltaXN0aWNRdWVyeVJlc3VsdHMucXVlcnlSZXN1bHQocXVlcnlUb2tlbik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBxdWVyeSByZXN1bHQgYnkgcXVlcnkgdG9rZW4gYmFzZWQgb24gY3VycmVudCwgbG9jYWwgc3RhdGVcbiAgICpcbiAgICogVGhlIG9ubHkgd2F5IHRoaXMgd2lsbCByZXR1cm4gYSB2YWx1ZSBpcyBpZiB3ZSdyZSBhbHJlYWR5IHN1YnNjcmliZWQgdG8gdGhlXG4gICAqIHF1ZXJ5IG9yIGl0cyB2YWx1ZSBoYXMgYmVlbiBzZXQgb3B0aW1pc3RpY2FsbHkuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4ocXVlcnlUb2tlbikge1xuICAgIHJldHVybiB0aGlzLm9wdGltaXN0aWNRdWVyeVJlc3VsdHMucXVlcnlSZXN1bHQocXVlcnlUb2tlbik7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgbG9jYWwgcXVlcnkgcmVzdWx0IGlzIGF2YWlsYWJsZSBmb3IgYSB0b2tlbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZG9lcyBub3QgdGhyb3cgaWYgdGhlIHJlc3VsdCBpcyBhbiBlcnJvci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBoYXNMb2NhbFF1ZXJ5UmVzdWx0QnlUb2tlbihxdWVyeVRva2VuKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW1pc3RpY1F1ZXJ5UmVzdWx0cy5oYXNRdWVyeVJlc3VsdChxdWVyeVRva2VuKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBsb2NhbFF1ZXJ5TG9ncyh1ZGZQYXRoLCBhcmdzKSB7XG4gICAgY29uc3QgYXJnc09iamVjdCA9IHBhcnNlQXJncyhhcmdzKTtcbiAgICBjb25zdCBxdWVyeVRva2VuID0gc2VyaWFsaXplUGF0aEFuZEFyZ3ModWRmUGF0aCwgYXJnc09iamVjdCk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW1pc3RpY1F1ZXJ5UmVzdWx0cy5xdWVyeUxvZ3MocXVlcnlUb2tlbik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBjdXJyZW50IHtAbGluayBRdWVyeUpvdXJuYWx9IGZvciB0aGlzIHF1ZXJ5IGZ1bmN0aW9uLlxuICAgKlxuICAgKiBJZiB3ZSBoYXZlIG5vdCB5ZXQgcmVjZWl2ZWQgYSByZXN1bHQgZm9yIHRoaXMgcXVlcnksIHRoaXMgd2lsbCBiZSBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcXVlcnkuXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBvYmplY3QgZm9yIHRoaXMgcXVlcnkuXG4gICAqIEByZXR1cm5zIFRoZSBxdWVyeSdzIHtAbGluayBRdWVyeUpvdXJuYWx9IG9yIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgcXVlcnlKb3VybmFsKG5hbWUsIGFyZ3MpIHtcbiAgICBjb25zdCBhcmdzT2JqZWN0ID0gcGFyc2VBcmdzKGFyZ3MpO1xuICAgIGNvbnN0IHF1ZXJ5VG9rZW4gPSBzZXJpYWxpemVQYXRoQW5kQXJncyhuYW1lLCBhcmdzT2JqZWN0KTtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5xdWVyeUpvdXJuYWwocXVlcnlUb2tlbik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB7QGxpbmsgQ29ubmVjdGlvblN0YXRlfSBiZXR3ZWVuIHRoZSBjbGllbnQgYW5kIHRoZSBDb252ZXhcbiAgICogYmFja2VuZC5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHtAbGluayBDb25uZWN0aW9uU3RhdGV9IHdpdGggdGhlIENvbnZleCBiYWNrZW5kLlxuICAgKi9cbiAgY29ubmVjdGlvblN0YXRlKCkge1xuICAgIGNvbnN0IHdzQ29ubmVjdGlvblN0YXRlID0gdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLmNvbm5lY3Rpb25TdGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBoYXNJbmZsaWdodFJlcXVlc3RzOiB0aGlzLnJlcXVlc3RNYW5hZ2VyLmhhc0luZmxpZ2h0UmVxdWVzdHMoKSxcbiAgICAgIGlzV2ViU29ja2V0Q29ubmVjdGVkOiB3c0Nvbm5lY3Rpb25TdGF0ZS5pc0Nvbm5lY3RlZCxcbiAgICAgIGhhc0V2ZXJDb25uZWN0ZWQ6IHdzQ29ubmVjdGlvblN0YXRlLmhhc0V2ZXJDb25uZWN0ZWQsXG4gICAgICBjb25uZWN0aW9uQ291bnQ6IHdzQ29ubmVjdGlvblN0YXRlLmNvbm5lY3Rpb25Db3VudCxcbiAgICAgIGNvbm5lY3Rpb25SZXRyaWVzOiB3c0Nvbm5lY3Rpb25TdGF0ZS5jb25uZWN0aW9uUmV0cmllcyxcbiAgICAgIHRpbWVPZk9sZGVzdEluZmxpZ2h0UmVxdWVzdDogdGhpcy5yZXF1ZXN0TWFuYWdlci50aW1lT2ZPbGRlc3RJbmZsaWdodFJlcXVlc3QoKSxcbiAgICAgIGluZmxpZ2h0TXV0YXRpb25zOiB0aGlzLnJlcXVlc3RNYW5hZ2VyLmluZmxpZ2h0TXV0YXRpb25zKCksXG4gICAgICBpbmZsaWdodEFjdGlvbnM6IHRoaXMucmVxdWVzdE1hbmFnZXIuaW5mbGlnaHRBY3Rpb25zKClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gdGhlIHtAbGluayBDb25uZWN0aW9uU3RhdGV9IGJldHdlZW4gdGhlIGNsaWVudCBhbmQgdGhlIENvbnZleFxuICAgKiBiYWNrZW5kLCBjYWxsaW5nIGEgY2FsbGJhY2sgZWFjaCB0aW1lIGl0IGNoYW5nZXMuXG4gICAqXG4gICAqIFN1YnNjcmliZWQgY2FsbGJhY2tzIHdpbGwgYmUgY2FsbGVkIHdoZW4gYW55IHBhcnQgb2YgQ29ubmVjdGlvblN0YXRlIGNoYW5nZXMuXG4gICAqIENvbm5lY3Rpb25TdGF0ZSBtYXkgZ3JvdyBpbiBmdXR1cmUgdmVyc2lvbnMgKGUuZy4gdG8gcHJvdmlkZSBhIGFycmF5IG9mXG4gICAqIGluZmxpZ2h0IHJlcXVlc3RzKSBpbiB3aGljaCBjYXNlIGNhbGxiYWNrcyB3b3VsZCBiZSBjYWxsZWQgbW9yZSBmcmVxdWVudGx5LlxuICAgKlxuICAgKiBAcmV0dXJucyBBbiB1bnN1YnNjcmliZSBmdW5jdGlvbiB0byBzdG9wIGxpc3RlbmluZy5cbiAgICovXG4gIHN1YnNjcmliZVRvQ29ubmVjdGlvblN0YXRlKGNiKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLm5leHRDb25uZWN0aW9uU3RhdGVTdWJzY3JpYmVySWQrKztcbiAgICB0aGlzLmNvbm5lY3Rpb25TdGF0ZVN1YnNjcmliZXJzLnNldChpZCwgY2IpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0ZVN1YnNjcmliZXJzLmRlbGV0ZShpZCk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICAgKiBFeGVjdXRlIGEgbXV0YXRpb24gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBtdXRhdGlvbi5cbiAgICAgKiBAcGFyYW0gYXJncyAtIEFuIGFyZ3VtZW50cyBvYmplY3QgZm9yIHRoZSBtdXRhdGlvbi4gSWYgdGhpcyBpcyBvbWl0dGVkLFxuICAgICAqIHRoZSBhcmd1bWVudHMgd2lsbCBiZSBge31gLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQSB7QGxpbmsgTXV0YXRpb25PcHRpb25zfSBvcHRpb25zIG9iamVjdCBmb3IgdGhpcyBtdXRhdGlvbi5cbiAgXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2Ugb2YgdGhlIG11dGF0aW9uJ3MgcmVzdWx0LlxuICAgICAqL1xuICBhc3luYyBtdXRhdGlvbihuYW1lLCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5tdXRhdGlvbkludGVybmFsKG5hbWUsIGFyZ3MsIG9wdGlvbnMpO1xuICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3JEYXRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgZm9yd2FyZERhdGEoXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIG5ldyBDb252ZXhFcnJvcihcbiAgICAgICAgICAgIGNyZWF0ZUh5YnJpZEVycm9yU3RhY2t0cmFjZShcIm11dGF0aW9uXCIsIG5hbWUsIHJlc3VsdClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoY3JlYXRlSHlicmlkRXJyb3JTdGFja3RyYWNlKFwibXV0YXRpb25cIiwgbmFtZSwgcmVzdWx0KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgbXV0YXRpb25JbnRlcm5hbCh1ZGZQYXRoLCBhcmdzLCBvcHRpb25zLCBjb21wb25lbnRQYXRoKSB7XG4gICAgY29uc3QgeyBtdXRhdGlvblByb21pc2UgfSA9IHRoaXMuZW5xdWV1ZU11dGF0aW9uKFxuICAgICAgdWRmUGF0aCxcbiAgICAgIGFyZ3MsXG4gICAgICBvcHRpb25zLFxuICAgICAgY29tcG9uZW50UGF0aFxuICAgICk7XG4gICAgcmV0dXJuIG11dGF0aW9uUHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlTXV0YXRpb24odWRmUGF0aCwgYXJncywgb3B0aW9ucywgY29tcG9uZW50UGF0aCkge1xuICAgIGNvbnN0IG11dGF0aW9uQXJncyA9IHBhcnNlQXJncyhhcmdzKTtcbiAgICB0aGlzLnRyeVJlcG9ydExvbmdEaXNjb25uZWN0KCk7XG4gICAgY29uc3QgcmVxdWVzdElkID0gdGhpcy5uZXh0UmVxdWVzdElkO1xuICAgIHRoaXMuX25leHRSZXF1ZXN0SWQrKztcbiAgICBpZiAob3B0aW9ucyAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlID0gb3B0aW9ucy5vcHRpbWlzdGljVXBkYXRlO1xuICAgICAgaWYgKG9wdGltaXN0aWNVcGRhdGUgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCB3cmFwcGVkVXBkYXRlID0gKGxvY2FsUXVlcnlTdG9yZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGltaXN0aWNVcGRhdGUoXG4gICAgICAgICAgICBsb2NhbFF1ZXJ5U3RvcmUsXG4gICAgICAgICAgICBtdXRhdGlvbkFyZ3NcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICBcIk9wdGltaXN0aWMgdXBkYXRlIGhhbmRsZXIgcmV0dXJuZWQgYSBQcm9taXNlLiBPcHRpbWlzdGljIHVwZGF0ZXMgc2hvdWxkIGJlIHN5bmNocm9ub3VzLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2hhbmdlZFF1ZXJ5VG9rZW5zID0gdGhpcy5vcHRpbWlzdGljUXVlcnlSZXN1bHRzLmFwcGx5T3B0aW1pc3RpY1VwZGF0ZShcbiAgICAgICAgICB3cmFwcGVkVXBkYXRlLFxuICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBjaGFuZ2VkUXVlcmllcyA9IGNoYW5nZWRRdWVyeVRva2Vucy5tYXAoKHRva2VuKSA9PiB7XG4gICAgICAgICAgY29uc3QgbG9jYWxSZXN1bHQgPSB0aGlzLmxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHRva2VuKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICBtb2RpZmljYXRpb246IHtcbiAgICAgICAgICAgICAga2luZDogXCJVcGRhdGVkXCIsXG4gICAgICAgICAgICAgIHJlc3VsdDogbG9jYWxSZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBsb2NhbFJlc3VsdCxcbiAgICAgICAgICAgICAgICBsb2dMaW5lczogW11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbmRsZVRyYW5zaXRpb24oe1xuICAgICAgICAgIHF1ZXJpZXM6IGNoYW5nZWRRdWVyaWVzLFxuICAgICAgICAgIHJlZmxlY3RlZE11dGF0aW9uczogW10sXG4gICAgICAgICAgdGltZXN0YW1wOiB0aGlzLnJlbW90ZVF1ZXJ5U2V0LnRpbWVzdGFtcCgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgdHlwZTogXCJNdXRhdGlvblwiLFxuICAgICAgcmVxdWVzdElkLFxuICAgICAgdWRmUGF0aCxcbiAgICAgIGNvbXBvbmVudFBhdGgsXG4gICAgICBhcmdzOiBbY29udmV4VG9Kc29uKG11dGF0aW9uQXJncyldXG4gICAgfTtcbiAgICBjb25zdCBtaWdodEJlU2VudCA9IHRoaXMud2ViU29ja2V0TWFuYWdlci5zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgICBjb25zdCBtdXRhdGlvblByb21pc2UgPSB0aGlzLnJlcXVlc3RNYW5hZ2VyLnJlcXVlc3QobWVzc2FnZSwgbWlnaHRCZVNlbnQpO1xuICAgIHJldHVybiB7XG4gICAgICByZXF1ZXN0SWQsXG4gICAgICBtdXRhdGlvblByb21pc2VcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlIGFuIGFjdGlvbiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYWN0aW9uLlxuICAgKiBAcGFyYW0gYXJncyAtIEFuIGFyZ3VtZW50cyBvYmplY3QgZm9yIHRoZSBhY3Rpb24uIElmIHRoaXMgaXMgb21pdHRlZCxcbiAgICogdGhlIGFyZ3VtZW50cyB3aWxsIGJlIGB7fWAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgYWN0aW9uJ3MgcmVzdWx0LlxuICAgKi9cbiAgYXN5bmMgYWN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmFjdGlvbkludGVybmFsKG5hbWUsIGFyZ3MpO1xuICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3JEYXRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgZm9yd2FyZERhdGEoXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIG5ldyBDb252ZXhFcnJvcihjcmVhdGVIeWJyaWRFcnJvclN0YWNrdHJhY2UoXCJhY3Rpb25cIiwgbmFtZSwgcmVzdWx0KSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihjcmVhdGVIeWJyaWRFcnJvclN0YWNrdHJhY2UoXCJhY3Rpb25cIiwgbmFtZSwgcmVzdWx0KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgYWN0aW9uSW50ZXJuYWwodWRmUGF0aCwgYXJncywgY29tcG9uZW50UGF0aCkge1xuICAgIGNvbnN0IGFjdGlvbkFyZ3MgPSBwYXJzZUFyZ3MoYXJncyk7XG4gICAgY29uc3QgcmVxdWVzdElkID0gdGhpcy5uZXh0UmVxdWVzdElkO1xuICAgIHRoaXMuX25leHRSZXF1ZXN0SWQrKztcbiAgICB0aGlzLnRyeVJlcG9ydExvbmdEaXNjb25uZWN0KCk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgIHR5cGU6IFwiQWN0aW9uXCIsXG4gICAgICByZXF1ZXN0SWQsXG4gICAgICB1ZGZQYXRoLFxuICAgICAgY29tcG9uZW50UGF0aCxcbiAgICAgIGFyZ3M6IFtjb252ZXhUb0pzb24oYWN0aW9uQXJncyldXG4gICAgfTtcbiAgICBjb25zdCBtaWdodEJlU2VudCA9IHRoaXMud2ViU29ja2V0TWFuYWdlci5zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0TWFuYWdlci5yZXF1ZXN0KG1lc3NhZ2UsIG1pZ2h0QmVTZW50KTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2UgYW55IG5ldHdvcmsgaGFuZGxlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjbGllbnQgYW5kIHN0b3AgYWxsIHN1YnNjcmlwdGlvbnMuXG4gICAqXG4gICAqIENhbGwgdGhpcyBtZXRob2Qgd2hlbiB5b3UncmUgZG9uZSB3aXRoIGFuIHtAbGluayBCYXNlQ29udmV4Q2xpZW50fSB0b1xuICAgKiBkaXNwb3NlIG9mIGl0cyBzb2NrZXRzIGFuZCByZXNvdXJjZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgYFByb21pc2VgIGZ1bGZpbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuIGNvbXBsZXRlbHkgY2xvc2VkLlxuICAgKi9cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgdGhpcy5hdXRoZW50aWNhdGlvbk1hbmFnZXIuc3RvcCgpO1xuICAgIHJldHVybiB0aGlzLndlYlNvY2tldE1hbmFnZXIudGVybWluYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYWRkcmVzcyBmb3IgdGhpcyBjbGllbnQsIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBuZXcgY2xpZW50LlxuICAgKlxuICAgKiBOb3QgZ3VhcmFudGVlZCB0byBtYXRjaCB0aGUgYWRkcmVzcyB3aXRoIHdoaWNoIHRoaXMgY2xpZW50IHdhcyBjb25zdHJ1Y3RlZDpcbiAgICogaXQgbWF5IGJlIGNhbm9uaWNhbGl6ZWQuXG4gICAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLmFkZHJlc3M7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0IG5leHRSZXF1ZXN0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25leHRSZXF1ZXN0SWQ7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0IHNlc3Npb25JZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbklkO1xuICB9XG4gIC8qKlxuICAgKiBSZXBvcnRzIHBlcmZvcm1hbmNlIG1hcmtzIHRvIHRoZSBzZXJ2ZXIuIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAgICogd2UgaGF2ZSBhIGZ1bmN0aW9uYWwgd2Vic29ja2V0LlxuICAgKi9cbiAgcmVwb3J0TWFya3MoKSB7XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIGNvbnN0IHJlcG9ydCA9IGdldE1hcmtzUmVwb3J0KHRoaXMuc2Vzc2lvbklkKTtcbiAgICAgIHRoaXMud2ViU29ja2V0TWFuYWdlci5zZW5kTWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwiRXZlbnRcIixcbiAgICAgICAgZXZlbnRUeXBlOiBcIkNsaWVudENvbm5lY3RcIixcbiAgICAgICAgZXZlbnQ6IHJlcG9ydFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHRyeVJlcG9ydExvbmdEaXNjb25uZWN0KCkge1xuICAgIGlmICghdGhpcy5kZWJ1Zykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0aW1lT2ZPbGRlc3RSZXF1ZXN0ID0gdGhpcy5jb25uZWN0aW9uU3RhdGUoKS50aW1lT2ZPbGRlc3RJbmZsaWdodFJlcXVlc3Q7XG4gICAgaWYgKHRpbWVPZk9sZGVzdFJlcXVlc3QgPT09IG51bGwgfHwgRGF0ZS5ub3coKSAtIHRpbWVPZk9sZGVzdFJlcXVlc3QuZ2V0VGltZSgpIDw9IDYwICogMWUzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy5hZGRyZXNzfS9hcGkvZGVidWdfZXZlbnRgO1xuICAgIGZldGNoKGVuZHBvaW50LCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgXCJDb252ZXgtQ2xpZW50XCI6IGBucG0tJHt2ZXJzaW9ufWBcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGV2ZW50OiBcIkxvbmdXZWJzb2NrZXREaXNjb25uZWN0XCIgfSlcbiAgICB9KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICAgIFwiQW5hbHl0aWNzIHJlcXVlc3QgZmFpbGVkIHdpdGggcmVzcG9uc2U6XCIsXG4gICAgICAgICAgcmVzcG9uc2UuYm9keVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcIkFuYWx5dGljcyByZXNwb25zZSBmYWlsZWQgd2l0aCBlcnJvcjpcIiwgZXJyb3IpO1xuICAgIH0pO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQuanMubWFwXG4iXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2RlZk5vcm1hbFByb3AiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fcHVibGljRmllbGQiLCJ2ZXJzaW9uIiwiY29udmV4VG9Kc29uIiwiY3JlYXRlSHlicmlkRXJyb3JTdGFja3RyYWNlIiwiZm9yd2FyZERhdGEiLCJpbnN0YW50aWF0ZURlZmF1bHRMb2dnZXIiLCJpbnN0YW50aWF0ZU5vb3BMb2dnZXIiLCJsb2dGYXRhbEVycm9yIiwiTG9jYWxTeW5jU3RhdGUiLCJSZXF1ZXN0TWFuYWdlciIsIk9wdGltaXN0aWNRdWVyeVJlc3VsdHMiLCJSZW1vdGVRdWVyeVNldCIsInNlcmlhbGl6ZVBhdGhBbmRBcmdzIiwiV2ViU29ja2V0TWFuYWdlciIsIm5ld1Nlc3Npb25JZCIsIkF1dGhlbnRpY2F0aW9uTWFuYWdlciIsImdldE1hcmtzUmVwb3J0IiwibWFyayIsInBhcnNlQXJncyIsInZhbGlkYXRlRGVwbG95bWVudFVybCIsIkNvbnZleEVycm9yIiwiand0RGVjb2RlIiwiQmFzZUNvbnZleENsaWVudCIsImhhc1N5bmNlZFBhc3RMYXN0UmVjb25uZWN0IiwicmVxdWVzdE1hbmFnZXIiLCJzdGF0ZSIsIm9ic2VydmVkVGltZXN0YW1wIiwib2JzZXJ2ZWRUcyIsIm1heE9ic2VydmVkVGltZXN0YW1wIiwibGVzc1RoYW5PckVxdWFsIiwiZ2V0TWF4T2JzZXJ2ZWRUaW1lc3RhbXAiLCJub3RpZnlPblF1ZXJ5UmVzdWx0Q2hhbmdlcyIsImNvbXBsZXRlZFJlcXVlc3RzIiwicmVtb3RlUXVlcnlSZXN1bHRzIiwicmVtb3RlUXVlcnlTZXQiLCJxdWVyeVRva2VuVG9WYWx1ZSIsIk1hcCIsInF1ZXJ5SWQiLCJyZXN1bHQiLCJxdWVyeVRva2VuIiwicXVlcnkiLCJ1ZGZQYXRoIiwicXVlcnlQYXRoIiwiYXJncyIsInF1ZXJ5QXJncyIsInNldCIsImNoYW5nZWRRdWVyeVRva2VucyIsIm9wdGltaXN0aWNRdWVyeVJlc3VsdHMiLCJpbmdlc3RRdWVyeVJlc3VsdHNGcm9tU2VydmVyIiwiU2V0Iiwia2V5cyIsImhhbmRsZVRyYW5zaXRpb24iLCJxdWVyaWVzIiwibWFwIiwidG9rZW4iLCJvcHRpbWlzdGljUmVzdWx0IiwicmF3UXVlcnlSZXN1bHQiLCJtb2RpZmljYXRpb24iLCJraW5kIiwicmVmbGVjdGVkTXV0YXRpb25zIiwiQXJyYXkiLCJmcm9tIiwicmVxdWVzdElkIiwidGltZXN0YW1wIiwidHJhbnNpdGlvbiIsImZuIiwiX29uVHJhbnNpdGlvbkZucyIsInZhbHVlcyIsImFkZE9uVHJhbnNpdGlvbkhhbmRsZXIiLCJpZCIsIl90cmFuc2l0aW9uSGFuZGxlckNvdW50ZXIiLCJkZWxldGUiLCJnZXRDdXJyZW50QXV0aENsYWltcyIsImF1dGhUb2tlbiIsImdldEF1dGgiLCJkZWNvZGVkIiwidG9rZW5UeXBlIiwic2V0QXV0aCIsImZldGNoVG9rZW4iLCJvbkNoYW5nZSIsImF1dGhlbnRpY2F0aW9uTWFuYWdlciIsInNldENvbmZpZyIsImhhc0F1dGgiLCJzZXRBZG1pbkF1dGgiLCJmYWtlVXNlcklkZW50aXR5IiwibWVzc2FnZSIsIndlYlNvY2tldE1hbmFnZXIiLCJzZW5kTWVzc2FnZSIsImNsZWFyQXV0aCIsInN1YnNjcmliZSIsIm5hbWUiLCJvcHRpb25zIiwiYXJnc09iamVjdCIsInVuc3Vic2NyaWJlIiwiam91cm5hbCIsImNvbXBvbmVudFBhdGgiLCJtb2RpZmljYXRpb24yIiwibG9jYWxRdWVyeVJlc3VsdCIsInF1ZXJ5UmVzdWx0IiwibG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4iLCJoYXNMb2NhbFF1ZXJ5UmVzdWx0QnlUb2tlbiIsImhhc1F1ZXJ5UmVzdWx0IiwibG9jYWxRdWVyeUxvZ3MiLCJxdWVyeUxvZ3MiLCJxdWVyeUpvdXJuYWwiLCJjb25uZWN0aW9uU3RhdGUiLCJ3c0Nvbm5lY3Rpb25TdGF0ZSIsImhhc0luZmxpZ2h0UmVxdWVzdHMiLCJpc1dlYlNvY2tldENvbm5lY3RlZCIsImlzQ29ubmVjdGVkIiwiaGFzRXZlckNvbm5lY3RlZCIsImNvbm5lY3Rpb25Db3VudCIsImNvbm5lY3Rpb25SZXRyaWVzIiwidGltZU9mT2xkZXN0SW5mbGlnaHRSZXF1ZXN0IiwiaW5mbGlnaHRNdXRhdGlvbnMiLCJpbmZsaWdodEFjdGlvbnMiLCJzdWJzY3JpYmVUb0Nvbm5lY3Rpb25TdGF0ZSIsImNiIiwibmV4dENvbm5lY3Rpb25TdGF0ZVN1YnNjcmliZXJJZCIsImNvbm5lY3Rpb25TdGF0ZVN1YnNjcmliZXJzIiwibXV0YXRpb24iLCJtdXRhdGlvbkludGVybmFsIiwic3VjY2VzcyIsImVycm9yRGF0YSIsIkVycm9yIiwibXV0YXRpb25Qcm9taXNlIiwiZW5xdWV1ZU11dGF0aW9uIiwibXV0YXRpb25BcmdzIiwidHJ5UmVwb3J0TG9uZ0Rpc2Nvbm5lY3QiLCJuZXh0UmVxdWVzdElkIiwiX25leHRSZXF1ZXN0SWQiLCJvcHRpbWlzdGljVXBkYXRlIiwid3JhcHBlZFVwZGF0ZSIsImxvY2FsUXVlcnlTdG9yZSIsIlByb21pc2UiLCJsb2dnZXIiLCJ3YXJuIiwiYXBwbHlPcHRpbWlzdGljVXBkYXRlIiwiY2hhbmdlZFF1ZXJpZXMiLCJsb2NhbFJlc3VsdCIsImxvZ0xpbmVzIiwidHlwZSIsIm1pZ2h0QmVTZW50IiwicmVxdWVzdCIsImFjdGlvbiIsImFjdGlvbkludGVybmFsIiwiYWN0aW9uQXJncyIsImNsb3NlIiwic3RvcCIsInRlcm1pbmF0ZSIsInVybCIsImFkZHJlc3MiLCJzZXNzaW9uSWQiLCJfc2Vzc2lvbklkIiwicmVwb3J0TWFya3MiLCJkZWJ1ZyIsInJlcG9ydCIsImV2ZW50VHlwZSIsImV2ZW50IiwidGltZU9mT2xkZXN0UmVxdWVzdCIsIkRhdGUiLCJub3ciLCJnZXRUaW1lIiwiZW5kcG9pbnQiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInRoZW4iLCJyZXNwb25zZSIsIm9rIiwiY2F0Y2giLCJlcnJvciIsImNvbnN0cnVjdG9yIiwib25UcmFuc2l0aW9uIiwicmVzb2x2ZSIsImN1ckNvbm5lY3Rpb25TdGF0ZSIsIl9sYXN0UHVibGlzaGVkQ29ubmVjdGlvblN0YXRlIiwic2tpcENvbnZleERlcGxveW1lbnRVcmxDaGVjayIsImF1dGhSZWZyZXNoVG9rZW5MZWV3YXlTZWNvbmRzIiwid2ViU29ja2V0Q29uc3RydWN0b3IiLCJXZWJTb2NrZXQiLCJyZXBvcnREZWJ1Z0luZm9Ub0NvbnZleCIsInZlcmJvc2UiLCJpIiwic2VhcmNoIiwib3JpZ2luIiwic3Vic3RyaW5nIiwicHJvdG9jb2wiLCJ3c1Byb3RvY29sIiwid3NVcmkiLCJtYXJrQ29ubmVjdGlvblN0YXRlRGlydHkiLCJwYXVzZVNvY2tldCIsInBhdXNlIiwiYXV0aGVudGljYXRlIiwiYmFzZVZlcnNpb24iLCJzdG9wU29ja2V0IiwidHJ5UmVzdGFydFNvY2tldCIsInRyeVJlc3RhcnQiLCJyZXN1bWVTb2NrZXQiLCJyZXN1bWUiLCJyZWZyZXNoVG9rZW5MZWV3YXlTZWNvbmRzIiwicSIsInVuc2F2ZWRDaGFuZ2VzV2FybmluZyIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwiaGFzSW5jb21wbGV0ZVJlcXVlc3RzIiwicHJldmVudERlZmF1bHQiLCJjb25maXJtYXRpb25NZXNzYWdlIiwicmV0dXJuVmFsdWUiLCJvbk9wZW4iLCJyZWNvbm5lY3RNZXRhZGF0YSIsIm9sZFJlbW90ZVF1ZXJ5UmVzdWx0cyIsInF1ZXJ5U2V0TW9kaWZpY2F0aW9uIiwiYXV0aE1vZGlmaWNhdGlvbiIsInJlc3RhcnQiLCJvblJlc3VtZSIsIm9uTWVzc2FnZSIsInNlcnZlck1lc3NhZ2UiLCJmaXJzdE1lc3NhZ2VSZWNlaXZlZCIsImVuZFZlcnNpb24iLCJ0cyIsInJlbW92ZUNvbXBsZXRlZCIsImNvbXBsZXRlZE11dGF0aW9uSW5mbyIsIm9uUmVzcG9uc2UiLCJvbkF1dGhFcnJvciIsIm9uU2VydmVyRGlzY29ubmVjdEVycm9yIiwiZXhwZWN0QXV0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/client.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/local_state.js":
/*!******************************************************************!*\
  !*** ./node_modules/convex/dist/esm/browser/sync/local_state.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LocalSyncState: function() { return /* binding */ LocalSyncState; }\n/* harmony export */ });\n/* harmony import */ var _values_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/index.js\");\n/* harmony import */ var _udf_path_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./udf_path_utils.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/udf_path_utils.js\");\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n\nclass LocalSyncState {\n    hasSyncedPastLastReconnect() {\n        return this.outstandingQueriesOlderThanRestart.size === 0 && !this.outstandingAuthOlderThanRestart;\n    }\n    markAuthCompletion() {\n        this.outstandingAuthOlderThanRestart = false;\n    }\n    subscribe(udfPath, args, journal, componentPath) {\n        const canonicalizedUdfPath = (0,_udf_path_utils_js__WEBPACK_IMPORTED_MODULE_1__.canonicalizeUdfPath)(udfPath);\n        const queryToken = (0,_udf_path_utils_js__WEBPACK_IMPORTED_MODULE_1__.serializePathAndArgs)(canonicalizedUdfPath, args);\n        const existingEntry = this.querySet.get(queryToken);\n        if (existingEntry !== void 0) {\n            existingEntry.numSubscribers += 1;\n            return {\n                queryToken,\n                modification: null,\n                unsubscribe: ()=>this.removeSubscriber(queryToken)\n            };\n        } else {\n            const queryId = this.nextQueryId++;\n            const query = {\n                id: queryId,\n                canonicalizedUdfPath,\n                args,\n                numSubscribers: 1,\n                journal,\n                componentPath\n            };\n            this.querySet.set(queryToken, query);\n            this.queryIdToToken.set(queryId, queryToken);\n            const baseVersion = this.querySetVersion;\n            const newVersion = this.querySetVersion + 1;\n            const add = {\n                type: \"Add\",\n                queryId,\n                udfPath: canonicalizedUdfPath,\n                args: [\n                    (0,_values_index_js__WEBPACK_IMPORTED_MODULE_0__.convexToJson)(args)\n                ],\n                journal,\n                componentPath\n            };\n            if (this.paused) {\n                this.pendingQuerySetModifications.set(queryId, add);\n            } else {\n                this.querySetVersion = newVersion;\n            }\n            const modification = {\n                type: \"ModifyQuerySet\",\n                baseVersion,\n                newVersion,\n                modifications: [\n                    add\n                ]\n            };\n            return {\n                queryToken,\n                modification,\n                unsubscribe: ()=>this.removeSubscriber(queryToken)\n            };\n        }\n    }\n    transition(transition) {\n        for (const modification of transition.modifications){\n            switch(modification.type){\n                case \"QueryUpdated\":\n                case \"QueryFailed\":\n                    {\n                        this.outstandingQueriesOlderThanRestart.delete(modification.queryId);\n                        const journal = modification.journal;\n                        if (journal !== void 0) {\n                            const queryToken = this.queryIdToToken.get(modification.queryId);\n                            if (queryToken !== void 0) {\n                                this.querySet.get(queryToken).journal = journal;\n                            }\n                        }\n                        break;\n                    }\n                case \"QueryRemoved\":\n                    {\n                        this.outstandingQueriesOlderThanRestart.delete(modification.queryId);\n                        break;\n                    }\n                default:\n                    {\n                        modification;\n                        throw new Error(\"Invalid modification \".concat(modification.type));\n                    }\n            }\n        }\n    }\n    queryId(udfPath, args) {\n        const canonicalizedUdfPath = (0,_udf_path_utils_js__WEBPACK_IMPORTED_MODULE_1__.canonicalizeUdfPath)(udfPath);\n        const queryToken = (0,_udf_path_utils_js__WEBPACK_IMPORTED_MODULE_1__.serializePathAndArgs)(canonicalizedUdfPath, args);\n        const existingEntry = this.querySet.get(queryToken);\n        if (existingEntry !== void 0) {\n            return existingEntry.id;\n        }\n        return null;\n    }\n    isCurrentOrNewerAuthVersion(version) {\n        return version >= this.identityVersion;\n    }\n    getAuth() {\n        return this.auth;\n    }\n    setAuth(value) {\n        this.auth = {\n            tokenType: \"User\",\n            value\n        };\n        const baseVersion = this.identityVersion;\n        if (!this.paused) {\n            this.identityVersion = baseVersion + 1;\n        }\n        return {\n            type: \"Authenticate\",\n            baseVersion,\n            ...this.auth\n        };\n    }\n    setAdminAuth(value, actingAs) {\n        const auth = {\n            tokenType: \"Admin\",\n            value,\n            impersonating: actingAs\n        };\n        this.auth = auth;\n        const baseVersion = this.identityVersion;\n        if (!this.paused) {\n            this.identityVersion = baseVersion + 1;\n        }\n        return {\n            type: \"Authenticate\",\n            baseVersion,\n            ...auth\n        };\n    }\n    clearAuth() {\n        this.auth = void 0;\n        this.markAuthCompletion();\n        const baseVersion = this.identityVersion;\n        if (!this.paused) {\n            this.identityVersion = baseVersion + 1;\n        }\n        return {\n            type: \"Authenticate\",\n            tokenType: \"None\",\n            baseVersion\n        };\n    }\n    hasAuth() {\n        return !!this.auth;\n    }\n    isNewAuth(value) {\n        var _this_auth;\n        return ((_this_auth = this.auth) === null || _this_auth === void 0 ? void 0 : _this_auth.value) !== value;\n    }\n    queryPath(queryId) {\n        const pathAndArgs = this.queryIdToToken.get(queryId);\n        if (pathAndArgs) {\n            return this.querySet.get(pathAndArgs).canonicalizedUdfPath;\n        }\n        return null;\n    }\n    queryArgs(queryId) {\n        const pathAndArgs = this.queryIdToToken.get(queryId);\n        if (pathAndArgs) {\n            return this.querySet.get(pathAndArgs).args;\n        }\n        return null;\n    }\n    queryToken(queryId) {\n        var _this_queryIdToToken_get;\n        return (_this_queryIdToToken_get = this.queryIdToToken.get(queryId)) !== null && _this_queryIdToToken_get !== void 0 ? _this_queryIdToToken_get : null;\n    }\n    queryJournal(queryToken) {\n        var _this_querySet_get;\n        return (_this_querySet_get = this.querySet.get(queryToken)) === null || _this_querySet_get === void 0 ? void 0 : _this_querySet_get.journal;\n    }\n    restart(oldRemoteQueryResults) {\n        this.unpause();\n        this.outstandingQueriesOlderThanRestart.clear();\n        const modifications = [];\n        for (const localQuery of this.querySet.values()){\n            const add = {\n                type: \"Add\",\n                queryId: localQuery.id,\n                udfPath: localQuery.canonicalizedUdfPath,\n                args: [\n                    (0,_values_index_js__WEBPACK_IMPORTED_MODULE_0__.convexToJson)(localQuery.args)\n                ],\n                journal: localQuery.journal,\n                componentPath: localQuery.componentPath\n            };\n            modifications.push(add);\n            if (!oldRemoteQueryResults.has(localQuery.id)) {\n                this.outstandingQueriesOlderThanRestart.add(localQuery.id);\n            }\n        }\n        this.querySetVersion = 1;\n        const querySet = {\n            type: \"ModifyQuerySet\",\n            baseVersion: 0,\n            newVersion: 1,\n            modifications\n        };\n        if (!this.auth) {\n            this.identityVersion = 0;\n            return [\n                querySet,\n                void 0\n            ];\n        }\n        this.outstandingAuthOlderThanRestart = true;\n        const authenticate = {\n            type: \"Authenticate\",\n            baseVersion: 0,\n            ...this.auth\n        };\n        this.identityVersion = 1;\n        return [\n            querySet,\n            authenticate\n        ];\n    }\n    pause() {\n        this.paused = true;\n    }\n    resume() {\n        const querySet = this.pendingQuerySetModifications.size > 0 ? {\n            type: \"ModifyQuerySet\",\n            baseVersion: this.querySetVersion,\n            newVersion: ++this.querySetVersion,\n            modifications: Array.from(this.pendingQuerySetModifications.values())\n        } : void 0;\n        const authenticate = this.auth !== void 0 ? {\n            type: \"Authenticate\",\n            baseVersion: this.identityVersion++,\n            ...this.auth\n        } : void 0;\n        this.unpause();\n        return [\n            querySet,\n            authenticate\n        ];\n    }\n    unpause() {\n        this.paused = false;\n        this.pendingQuerySetModifications.clear();\n    }\n    removeSubscriber(queryToken) {\n        const localQuery = this.querySet.get(queryToken);\n        if (localQuery.numSubscribers > 1) {\n            localQuery.numSubscribers -= 1;\n            return null;\n        } else {\n            this.querySet.delete(queryToken);\n            this.queryIdToToken.delete(localQuery.id);\n            this.outstandingQueriesOlderThanRestart.delete(localQuery.id);\n            const baseVersion = this.querySetVersion;\n            const newVersion = this.querySetVersion + 1;\n            const remove = {\n                type: \"Remove\",\n                queryId: localQuery.id\n            };\n            if (this.paused) {\n                if (this.pendingQuerySetModifications.has(localQuery.id)) {\n                    this.pendingQuerySetModifications.delete(localQuery.id);\n                } else {\n                    this.pendingQuerySetModifications.set(localQuery.id, remove);\n                }\n            } else {\n                this.querySetVersion = newVersion;\n            }\n            return {\n                type: \"ModifyQuerySet\",\n                baseVersion,\n                newVersion,\n                modifications: [\n                    remove\n                ]\n            };\n        }\n    }\n    constructor(){\n        __publicField(this, \"nextQueryId\");\n        __publicField(this, \"querySetVersion\");\n        __publicField(this, \"querySet\");\n        __publicField(this, \"queryIdToToken\");\n        __publicField(this, \"identityVersion\");\n        __publicField(this, \"auth\");\n        __publicField(this, \"outstandingQueriesOlderThanRestart\");\n        __publicField(this, \"outstandingAuthOlderThanRestart\");\n        __publicField(this, \"paused\");\n        __publicField(this, \"pendingQuerySetModifications\");\n        this.nextQueryId = 0;\n        this.querySetVersion = 0;\n        this.identityVersion = 0;\n        this.querySet = /* @__PURE__ */ new Map();\n        this.queryIdToToken = /* @__PURE__ */ new Map();\n        this.outstandingQueriesOlderThanRestart = /* @__PURE__ */ new Set();\n        this.outstandingAuthOlderThanRestart = false;\n        this.paused = false;\n        this.pendingQuerySetModifications = /* @__PURE__ */ new Map();\n    }\n} //# sourceMappingURL=local_state.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL2xvY2FsX3N0YXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxrQkFBa0IsQ0FBQ0MsS0FBS0MsS0FBS0MsUUFBVUQsT0FBT0QsTUFBTUosVUFBVUksS0FBS0MsS0FBSztRQUFFRSxZQUFZO1FBQU1DLGNBQWM7UUFBTUMsVUFBVTtRQUFNSDtJQUFNLEtBQUtGLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztBQUMxSixJQUFJSSxnQkFBZ0IsQ0FBQ04sS0FBS0MsS0FBS0MsUUFBVUgsZ0JBQWdCQyxLQUFLLE9BQU9DLFFBQVEsV0FBV0EsTUFBTSxLQUFLQSxLQUFLQztBQUNuRDtBQUl4QjtBQUN0QixNQUFNUTtJQXNCWEMsNkJBQTZCO1FBQzNCLE9BQU8sSUFBSSxDQUFDQyxrQ0FBa0MsQ0FBQ0MsSUFBSSxLQUFLLEtBQUssQ0FBQyxJQUFJLENBQUNDLCtCQUErQjtJQUNwRztJQUNBQyxxQkFBcUI7UUFDbkIsSUFBSSxDQUFDRCwrQkFBK0IsR0FBRztJQUN6QztJQUNBRSxVQUFVQyxPQUFPLEVBQUVDLElBQUksRUFBRUMsT0FBTyxFQUFFQyxhQUFhLEVBQUU7UUFDL0MsTUFBTUMsdUJBQXVCYix1RUFBbUJBLENBQUNTO1FBQ2pELE1BQU1LLGFBQWFiLHdFQUFvQkEsQ0FBQ1ksc0JBQXNCSDtRQUM5RCxNQUFNSyxnQkFBZ0IsSUFBSSxDQUFDQyxRQUFRLENBQUNDLEdBQUcsQ0FBQ0g7UUFDeEMsSUFBSUMsa0JBQWtCLEtBQUssR0FBRztZQUM1QkEsY0FBY0csY0FBYyxJQUFJO1lBQ2hDLE9BQU87Z0JBQ0xKO2dCQUNBSyxjQUFjO2dCQUNkQyxhQUFhLElBQU0sSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ1A7WUFDM0M7UUFDRixPQUFPO1lBQ0wsTUFBTVEsVUFBVSxJQUFJLENBQUNDLFdB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SSxDQUFDeUIsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ00sZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ1ksZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ3pCLFFBQVEsR0FBRyxhQUFhLEdBQUcsSUFBSXVEO1FBQ3BDLElBQUksQ0FBQzVDLGNBQWMsR0FBRyxhQUFhLEdBQUcsSUFBSTRDO1FBQzFDLElBQUksQ0FBQ25FLGtDQUFrQyxHQUFHLGFBQWEsR0FBRyxJQUFJb0U7UUFDOUQsSUFBSSxDQUFDbEUsK0JBQStCLEdBQUc7UUFDdkMsSUFBSSxDQUFDMkIsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyw0QkFBNEIsR0FBRyxhQUFhLEdBQUcsSUFBSXFDO0lBQzFEO0FBd1FGLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL2xvY2FsX3N0YXRlLmpzPzRiYTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuaW1wb3J0IHsgY29udmV4VG9Kc29uIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHtcbiAgY2Fub25pY2FsaXplVWRmUGF0aCxcbiAgc2VyaWFsaXplUGF0aEFuZEFyZ3Ncbn0gZnJvbSBcIi4vdWRmX3BhdGhfdXRpbHMuanNcIjtcbmV4cG9ydCBjbGFzcyBMb2NhbFN5bmNTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJuZXh0UXVlcnlJZFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicXVlcnlTZXRWZXJzaW9uXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJxdWVyeVNldFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicXVlcnlJZFRvVG9rZW5cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlkZW50aXR5VmVyc2lvblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYXV0aFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib3V0c3RhbmRpbmdRdWVyaWVzT2xkZXJUaGFuUmVzdGFydFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib3V0c3RhbmRpbmdBdXRoT2xkZXJUaGFuUmVzdGFydFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGF1c2VkXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwZW5kaW5nUXVlcnlTZXRNb2RpZmljYXRpb25zXCIpO1xuICAgIHRoaXMubmV4dFF1ZXJ5SWQgPSAwO1xuICAgIHRoaXMucXVlcnlTZXRWZXJzaW9uID0gMDtcbiAgICB0aGlzLmlkZW50aXR5VmVyc2lvbiA9IDA7XG4gICAgdGhpcy5xdWVyeVNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5xdWVyeUlkVG9Ub2tlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5vdXRzdGFuZGluZ1F1ZXJpZXNPbGRlclRoYW5SZXN0YXJ0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLm91dHN0YW5kaW5nQXV0aE9sZGVyVGhhblJlc3RhcnQgPSBmYWxzZTtcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMucGVuZGluZ1F1ZXJ5U2V0TW9kaWZpY2F0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgaGFzU3luY2VkUGFzdExhc3RSZWNvbm5lY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0c3RhbmRpbmdRdWVyaWVzT2xkZXJUaGFuUmVzdGFydC5zaXplID09PSAwICYmICF0aGlzLm91dHN0YW5kaW5nQXV0aE9sZGVyVGhhblJlc3RhcnQ7XG4gIH1cbiAgbWFya0F1dGhDb21wbGV0aW9uKCkge1xuICAgIHRoaXMub3V0c3RhbmRpbmdBdXRoT2xkZXJUaGFuUmVzdGFydCA9IGZhbHNlO1xuICB9XG4gIHN1YnNjcmliZSh1ZGZQYXRoLCBhcmdzLCBqb3VybmFsLCBjb21wb25lbnRQYXRoKSB7XG4gICAgY29uc3QgY2Fub25pY2FsaXplZFVkZlBhdGggPSBjYW5vbmljYWxpemVVZGZQYXRoKHVkZlBhdGgpO1xuICAgIGNvbnN0IHF1ZXJ5VG9rZW4gPSBzZXJpYWxpemVQYXRoQW5kQXJncyhjYW5vbmljYWxpemVkVWRmUGF0aCwgYXJncyk7XG4gICAgY29uc3QgZXhpc3RpbmdFbnRyeSA9IHRoaXMucXVlcnlTZXQuZ2V0KHF1ZXJ5VG9rZW4pO1xuICAgIGlmIChleGlzdGluZ0VudHJ5ICE9PSB2b2lkIDApIHtcbiAgICAgIGV4aXN0aW5nRW50cnkubnVtU3Vic2NyaWJlcnMgKz0gMTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHF1ZXJ5VG9rZW4sXG4gICAgICAgIG1vZGlmaWNhdGlvbjogbnVsbCxcbiAgICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHRoaXMucmVtb3ZlU3Vic2NyaWJlcihxdWVyeVRva2VuKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcXVlcnlJZCA9IHRoaXMubmV4dFF1ZXJ5SWQrKztcbiAgICAgIGNvbnN0IHF1ZXJ5ID0ge1xuICAgICAgICBpZDogcXVlcnlJZCxcbiAgICAgICAgY2Fub25pY2FsaXplZFVkZlBhdGgsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIG51bVN1YnNjcmliZXJzOiAxLFxuICAgICAgICBqb3VybmFsLFxuICAgICAgICBjb21wb25lbnRQYXRoXG4gICAgICB9O1xuICAgICAgdGhpcy5xdWVyeVNldC5zZXQocXVlcnlUb2tlbiwgcXVlcnkpO1xuICAgICAgdGhpcy5xdWVyeUlkVG9Ub2tlbi5zZXQocXVlcnlJZCwgcXVlcnlUb2tlbik7XG4gICAgICBjb25zdCBiYXNlVmVyc2lvbiA9IHRoaXMucXVlcnlTZXRWZXJzaW9uO1xuICAgICAgY29uc3QgbmV3VmVyc2lvbiA9IHRoaXMucXVlcnlTZXRWZXJzaW9uICsgMTtcbiAgICAgIGNvbnN0IGFkZCA9IHtcbiAgICAgICAgdHlwZTogXCJBZGRcIixcbiAgICAgICAgcXVlcnlJZCxcbiAgICAgICAgdWRmUGF0aDogY2Fub25pY2FsaXplZFVkZlBhdGgsXG4gICAgICAgIGFyZ3M6IFtjb252ZXhUb0pzb24oYXJncyldLFxuICAgICAgICBqb3VybmFsLFxuICAgICAgICBjb21wb25lbnRQYXRoXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ1F1ZXJ5U2V0TW9kaWZpY2F0aW9ucy5zZXQocXVlcnlJZCwgYWRkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucXVlcnlTZXRWZXJzaW9uID0gbmV3VmVyc2lvbjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGlmaWNhdGlvbiA9IHtcbiAgICAgICAgdHlwZTogXCJNb2RpZnlRdWVyeVNldFwiLFxuICAgICAgICBiYXNlVmVyc2lvbixcbiAgICAgICAgbmV3VmVyc2lvbixcbiAgICAgICAgbW9kaWZpY2F0aW9uczogW2FkZF1cbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBxdWVyeVRva2VuLFxuICAgICAgICBtb2RpZmljYXRpb24sXG4gICAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB0aGlzLnJlbW92ZVN1YnNjcmliZXIocXVlcnlUb2tlbilcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHRyYW5zaXRpb24odHJhbnNpdGlvbikge1xuICAgIGZvciAoY29uc3QgbW9kaWZpY2F0aW9uIG9mIHRyYW5zaXRpb24ubW9kaWZpY2F0aW9ucykge1xuICAgICAgc3dpdGNoIChtb2RpZmljYXRpb24udHlwZSkge1xuICAgICAgICBjYXNlIFwiUXVlcnlVcGRhdGVkXCI6XG4gICAgICAgIGNhc2UgXCJRdWVyeUZhaWxlZFwiOiB7XG4gICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1F1ZXJpZXNPbGRlclRoYW5SZXN0YXJ0LmRlbGV0ZShtb2RpZmljYXRpb24ucXVlcnlJZCk7XG4gICAgICAgICAgY29uc3Qgam91cm5hbCA9IG1vZGlmaWNhdGlvbi5qb3VybmFsO1xuICAgICAgICAgIGlmIChqb3VybmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5VG9rZW4gPSB0aGlzLnF1ZXJ5SWRUb1Rva2VuLmdldChtb2RpZmljYXRpb24ucXVlcnlJZCk7XG4gICAgICAgICAgICBpZiAocXVlcnlUb2tlbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHRoaXMucXVlcnlTZXQuZ2V0KHF1ZXJ5VG9rZW4pLmpvdXJuYWwgPSBqb3VybmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiUXVlcnlSZW1vdmVkXCI6IHtcbiAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUXVlcmllc09sZGVyVGhhblJlc3RhcnQuZGVsZXRlKG1vZGlmaWNhdGlvbi5xdWVyeUlkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgbW9kaWZpY2F0aW9uO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtb2RpZmljYXRpb24gJHttb2RpZmljYXRpb24udHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBxdWVyeUlkKHVkZlBhdGgsIGFyZ3MpIHtcbiAgICBjb25zdCBjYW5vbmljYWxpemVkVWRmUGF0aCA9IGNhbm9uaWNhbGl6ZVVkZlBhdGgodWRmUGF0aCk7XG4gICAgY29uc3QgcXVlcnlUb2tlbiA9IHNlcmlhbGl6ZVBhdGhBbmRBcmdzKGNhbm9uaWNhbGl6ZWRVZGZQYXRoLCBhcmdzKTtcbiAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gdGhpcy5xdWVyeVNldC5nZXQocXVlcnlUb2tlbik7XG4gICAgaWYgKGV4aXN0aW5nRW50cnkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nRW50cnkuaWQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlzQ3VycmVudE9yTmV3ZXJBdXRoVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIHZlcnNpb24gPj0gdGhpcy5pZGVudGl0eVZlcnNpb247XG4gIH1cbiAgZ2V0QXV0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5hdXRoO1xuICB9XG4gIHNldEF1dGgodmFsdWUpIHtcbiAgICB0aGlzLmF1dGggPSB7XG4gICAgICB0b2tlblR5cGU6IFwiVXNlclwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICAgIGNvbnN0IGJhc2VWZXJzaW9uID0gdGhpcy5pZGVudGl0eVZlcnNpb247XG4gICAgaWYgKCF0aGlzLnBhdXNlZCkge1xuICAgICAgdGhpcy5pZGVudGl0eVZlcnNpb24gPSBiYXNlVmVyc2lvbiArIDE7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkF1dGhlbnRpY2F0ZVwiLFxuICAgICAgYmFzZVZlcnNpb24sXG4gICAgICAuLi50aGlzLmF1dGhcbiAgICB9O1xuICB9XG4gIHNldEFkbWluQXV0aCh2YWx1ZSwgYWN0aW5nQXMpIHtcbiAgICBjb25zdCBhdXRoID0ge1xuICAgICAgdG9rZW5UeXBlOiBcIkFkbWluXCIsXG4gICAgICB2YWx1ZSxcbiAgICAgIGltcGVyc29uYXRpbmc6IGFjdGluZ0FzXG4gICAgfTtcbiAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgIGNvbnN0IGJhc2VWZXJzaW9uID0gdGhpcy5pZGVudGl0eVZlcnNpb247XG4gICAgaWYgKCF0aGlzLnBhdXNlZCkge1xuICAgICAgdGhpcy5pZGVudGl0eVZlcnNpb24gPSBiYXNlVmVyc2lvbiArIDE7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkF1dGhlbnRpY2F0ZVwiLFxuICAgICAgYmFzZVZlcnNpb24sXG4gICAgICAuLi5hdXRoXG4gICAgfTtcbiAgfVxuICBjbGVhckF1dGgoKSB7XG4gICAgdGhpcy5hdXRoID0gdm9pZCAwO1xuICAgIHRoaXMubWFya0F1dGhDb21wbGV0aW9uKCk7XG4gICAgY29uc3QgYmFzZVZlcnNpb24gPSB0aGlzLmlkZW50aXR5VmVyc2lvbjtcbiAgICBpZiAoIXRoaXMucGF1c2VkKSB7XG4gICAgICB0aGlzLmlkZW50aXR5VmVyc2lvbiA9IGJhc2VWZXJzaW9uICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiQXV0aGVudGljYXRlXCIsXG4gICAgICB0b2tlblR5cGU6IFwiTm9uZVwiLFxuICAgICAgYmFzZVZlcnNpb25cbiAgICB9O1xuICB9XG4gIGhhc0F1dGgoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5hdXRoO1xuICB9XG4gIGlzTmV3QXV0aCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmF1dGg/LnZhbHVlICE9PSB2YWx1ZTtcbiAgfVxuICBxdWVyeVBhdGgocXVlcnlJZCkge1xuICAgIGNvbnN0IHBhdGhBbmRBcmdzID0gdGhpcy5xdWVyeUlkVG9Ub2tlbi5nZXQocXVlcnlJZCk7XG4gICAgaWYgKHBhdGhBbmRBcmdzKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeVNldC5nZXQocGF0aEFuZEFyZ3MpLmNhbm9uaWNhbGl6ZWRVZGZQYXRoO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBxdWVyeUFyZ3MocXVlcnlJZCkge1xuICAgIGNvbnN0IHBhdGhBbmRBcmdzID0gdGhpcy5xdWVyeUlkVG9Ub2tlbi5nZXQocXVlcnlJZCk7XG4gICAgaWYgKHBhdGhBbmRBcmdzKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeVNldC5nZXQocGF0aEFuZEFyZ3MpLmFyZ3M7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHF1ZXJ5VG9rZW4ocXVlcnlJZCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5SWRUb1Rva2VuLmdldChxdWVyeUlkKSA/PyBudWxsO1xuICB9XG4gIHF1ZXJ5Sm91cm5hbChxdWVyeVRva2VuKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZXQuZ2V0KHF1ZXJ5VG9rZW4pPy5qb3VybmFsO1xuICB9XG4gIHJlc3RhcnQob2xkUmVtb3RlUXVlcnlSZXN1bHRzKSB7XG4gICAgdGhpcy51bnBhdXNlKCk7XG4gICAgdGhpcy5vdXRzdGFuZGluZ1F1ZXJpZXNPbGRlclRoYW5SZXN0YXJ0LmNsZWFyKCk7XG4gICAgY29uc3QgbW9kaWZpY2F0aW9ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgbG9jYWxRdWVyeSBvZiB0aGlzLnF1ZXJ5U2V0LnZhbHVlcygpKSB7XG4gICAgICBjb25zdCBhZGQgPSB7XG4gICAgICAgIHR5cGU6IFwiQWRkXCIsXG4gICAgICAgIHF1ZXJ5SWQ6IGxvY2FsUXVlcnkuaWQsXG4gICAgICAgIHVkZlBhdGg6IGxvY2FsUXVlcnkuY2Fub25pY2FsaXplZFVkZlBhdGgsXG4gICAgICAgIGFyZ3M6IFtjb252ZXhUb0pzb24obG9jYWxRdWVyeS5hcmdzKV0sXG4gICAgICAgIGpvdXJuYWw6IGxvY2FsUXVlcnkuam91cm5hbCxcbiAgICAgICAgY29tcG9uZW50UGF0aDogbG9jYWxRdWVyeS5jb21wb25lbnRQYXRoXG4gICAgICB9O1xuICAgICAgbW9kaWZpY2F0aW9ucy5wdXNoKGFkZCk7XG4gICAgICBpZiAoIW9sZFJlbW90ZVF1ZXJ5UmVzdWx0cy5oYXMobG9jYWxRdWVyeS5pZCkpIHtcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1F1ZXJpZXNPbGRlclRoYW5SZXN0YXJ0LmFkZChsb2NhbFF1ZXJ5LmlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5xdWVyeVNldFZlcnNpb24gPSAxO1xuICAgIGNvbnN0IHF1ZXJ5U2V0ID0ge1xuICAgICAgdHlwZTogXCJNb2RpZnlRdWVyeVNldFwiLFxuICAgICAgYmFzZVZlcnNpb246IDAsXG4gICAgICBuZXdWZXJzaW9uOiAxLFxuICAgICAgbW9kaWZpY2F0aW9uc1xuICAgIH07XG4gICAgaWYgKCF0aGlzLmF1dGgpIHtcbiAgICAgIHRoaXMuaWRlbnRpdHlWZXJzaW9uID0gMDtcbiAgICAgIHJldHVybiBbcXVlcnlTZXQsIHZvaWQgMF07XG4gICAgfVxuICAgIHRoaXMub3V0c3RhbmRpbmdBdXRoT2xkZXJUaGFuUmVzdGFydCA9IHRydWU7XG4gICAgY29uc3QgYXV0aGVudGljYXRlID0ge1xuICAgICAgdHlwZTogXCJBdXRoZW50aWNhdGVcIixcbiAgICAgIGJhc2VWZXJzaW9uOiAwLFxuICAgICAgLi4udGhpcy5hdXRoXG4gICAgfTtcbiAgICB0aGlzLmlkZW50aXR5VmVyc2lvbiA9IDE7XG4gICAgcmV0dXJuIFtxdWVyeVNldCwgYXV0aGVudGljYXRlXTtcbiAgfVxuICBwYXVzZSgpIHtcbiAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gIH1cbiAgcmVzdW1lKCkge1xuICAgIGNvbnN0IHF1ZXJ5U2V0ID0gdGhpcy5wZW5kaW5nUXVlcnlTZXRNb2RpZmljYXRpb25zLnNpemUgPiAwID8ge1xuICAgICAgdHlwZTogXCJNb2RpZnlRdWVyeVNldFwiLFxuICAgICAgYmFzZVZlcnNpb246IHRoaXMucXVlcnlTZXRWZXJzaW9uLFxuICAgICAgbmV3VmVyc2lvbjogKyt0aGlzLnF1ZXJ5U2V0VmVyc2lvbixcbiAgICAgIG1vZGlmaWNhdGlvbnM6IEFycmF5LmZyb20oXG4gICAgICAgIHRoaXMucGVuZGluZ1F1ZXJ5U2V0TW9kaWZpY2F0aW9ucy52YWx1ZXMoKVxuICAgICAgKVxuICAgIH0gOiB2b2lkIDA7XG4gICAgY29uc3QgYXV0aGVudGljYXRlID0gdGhpcy5hdXRoICE9PSB2b2lkIDAgPyB7XG4gICAgICB0eXBlOiBcIkF1dGhlbnRpY2F0ZVwiLFxuICAgICAgYmFzZVZlcnNpb246IHRoaXMuaWRlbnRpdHlWZXJzaW9uKyssXG4gICAgICAuLi50aGlzLmF1dGhcbiAgICB9IDogdm9pZCAwO1xuICAgIHRoaXMudW5wYXVzZSgpO1xuICAgIHJldHVybiBbcXVlcnlTZXQsIGF1dGhlbnRpY2F0ZV07XG4gIH1cbiAgdW5wYXVzZSgpIHtcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMucGVuZGluZ1F1ZXJ5U2V0TW9kaWZpY2F0aW9ucy5jbGVhcigpO1xuICB9XG4gIHJlbW92ZVN1YnNjcmliZXIocXVlcnlUb2tlbikge1xuICAgIGNvbnN0IGxvY2FsUXVlcnkgPSB0aGlzLnF1ZXJ5U2V0LmdldChxdWVyeVRva2VuKTtcbiAgICBpZiAobG9jYWxRdWVyeS5udW1TdWJzY3JpYmVycyA+IDEpIHtcbiAgICAgIGxvY2FsUXVlcnkubnVtU3Vic2NyaWJlcnMgLT0gMTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnF1ZXJ5U2V0LmRlbGV0ZShxdWVyeVRva2VuKTtcbiAgICAgIHRoaXMucXVlcnlJZFRvVG9rZW4uZGVsZXRlKGxvY2FsUXVlcnkuaWQpO1xuICAgICAgdGhpcy5vdXRzdGFuZGluZ1F1ZXJpZXNPbGRlclRoYW5SZXN0YXJ0LmRlbGV0ZShsb2NhbFF1ZXJ5LmlkKTtcbiAgICAgIGNvbnN0IGJhc2VWZXJzaW9uID0gdGhpcy5xdWVyeVNldFZlcnNpb247XG4gICAgICBjb25zdCBuZXdWZXJzaW9uID0gdGhpcy5xdWVyeVNldFZlcnNpb24gKyAxO1xuICAgICAgY29uc3QgcmVtb3ZlID0ge1xuICAgICAgICB0eXBlOiBcIlJlbW92ZVwiLFxuICAgICAgICBxdWVyeUlkOiBsb2NhbFF1ZXJ5LmlkXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdRdWVyeVNldE1vZGlmaWNhdGlvbnMuaGFzKGxvY2FsUXVlcnkuaWQpKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nUXVlcnlTZXRNb2RpZmljYXRpb25zLmRlbGV0ZShsb2NhbFF1ZXJ5LmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdRdWVyeVNldE1vZGlmaWNhdGlvbnMuc2V0KGxvY2FsUXVlcnkuaWQsIHJlbW92ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucXVlcnlTZXRWZXJzaW9uID0gbmV3VmVyc2lvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiTW9kaWZ5UXVlcnlTZXRcIixcbiAgICAgICAgYmFzZVZlcnNpb24sXG4gICAgICAgIG5ld1ZlcnNpb24sXG4gICAgICAgIG1vZGlmaWNhdGlvbnM6IFtyZW1vdmVdXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxfc3RhdGUuanMubWFwXG4iXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2RlZk5vcm1hbFByb3AiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fcHVibGljRmllbGQiLCJjb252ZXhUb0pzb24iLCJjYW5vbmljYWxpemVVZGZQYXRoIiwic2VyaWFsaXplUGF0aEFuZEFyZ3MiLCJMb2NhbFN5bmNTdGF0ZSIsImhhc1N5bmNlZFBhc3RMYXN0UmVjb25uZWN0Iiwib3V0c3RhbmRpbmdRdWVyaWVzT2xkZXJUaGFuUmVzdGFydCIsInNpemUiLCJvdXRzdGFuZGluZ0F1dGhPbGRlclRoYW5SZXN0YXJ0IiwibWFya0F1dGhDb21wbGV0aW9uIiwic3Vic2NyaWJlIiwidWRmUGF0aCIsImFyZ3MiLCJqb3VybmFsIiwiY29tcG9uZW50UGF0aCIsImNhbm9uaWNhbGl6ZWRVZGZQYXRoIiwicXVlcnlUb2tlbiIsImV4aXN0aW5nRW50cnkiLCJxdWVyeVNldCIsImdldCIsIm51bVN1YnNjcmliZXJzIiwibW9kaWZpY2F0aW9uIiwidW5zdWJzY3JpYmUiLCJyZW1vdmVTdWJzY3JpYmVyIiwicXVlcnlJZCIsIm5leHRRdWVyeUlkIiwicXVlcnkiLCJpZCIsInNldCIsInF1ZXJ5SWRUb1Rva2VuIiwiYmFzZVZlcnNpb24iLCJxdWVyeVNldFZlcnNpb24iLCJuZXdWZXJzaW9uIiwiYWRkIiwidHlwZSIsInBhdXNlZCIsInBlbmRpbmdRdWVyeVNldE1vZGlmaWNhdGlvbnMiLCJtb2RpZmljYXRpb25zIiwidHJhbnNpdGlvbiIsImRlbGV0ZSIsIkVycm9yIiwiaXNDdXJyZW50T3JOZXdlckF1dGhWZXJzaW9uIiwidmVyc2lvbiIsImlkZW50aXR5VmVyc2lvbiIsImdldEF1dGgiLCJhdXRoIiwic2V0QXV0aCIsInRva2VuVHlwZSIsInNldEFkbWluQXV0aCIsImFjdGluZ0FzIiwiaW1wZXJzb25hdGluZyIsImNsZWFyQXV0aCIsImhhc0F1dGgiLCJpc05ld0F1dGgiLCJxdWVyeVBhdGgiLCJwYXRoQW5kQXJncyIsInF1ZXJ5QXJncyIsInF1ZXJ5Sm91cm5hbCIsInJlc3RhcnQiLCJvbGRSZW1vdGVRdWVyeVJlc3VsdHMiLCJ1bnBhdXNlIiwiY2xlYXIiLCJsb2NhbFF1ZXJ5IiwidmFsdWVzIiwicHVzaCIsImhhcyIsImF1dGhlbnRpY2F0ZSIsInBhdXNlIiwicmVzdW1lIiwiQXJyYXkiLCJmcm9tIiwicmVtb3ZlIiwiY29uc3RydWN0b3IiLCJNYXAiLCJTZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/local_state.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/metrics.js":
/*!**************************************************************!*\
  !*** ./node_modules/convex/dist/esm/browser/sync/metrics.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMarksReport: function() { return /* binding */ getMarksReport; },\n/* harmony export */   mark: function() { return /* binding */ mark; }\n/* harmony export */ });\n\nconst markNames = [\n    \"convexClientConstructed\",\n    \"convexWebSocketOpen\",\n    \"convexFirstMessageReceived\"\n];\nfunction mark(name, sessionId) {\n    const detail = {\n        sessionId\n    };\n    if (typeof performance === \"undefined\" || !performance.mark) return;\n    performance.mark(name, {\n        detail\n    });\n}\nfunction performanceMarkToJson(mark2) {\n    let name = mark2.name.slice(\"convex\".length);\n    name = name.charAt(0).toLowerCase() + name.slice(1);\n    return {\n        name,\n        startTime: mark2.startTime\n    };\n}\nfunction getMarksReport(sessionId) {\n    if (typeof performance === \"undefined\" || !performance.getEntriesByName) {\n        return [];\n    }\n    const allMarks = [];\n    for (const name of markNames){\n        const marks = performance.getEntriesByName(name).filter((entry)=>entry.entryType === \"mark\").filter((mark2)=>mark2.detail.sessionId === sessionId);\n        allMarks.push(...marks);\n    }\n    return allMarks.map(performanceMarkToJson);\n} //# sourceMappingURL=metrics.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL21ldHJpY3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBYTtBQUNiLE1BQU1BLFlBQVk7SUFDaEI7SUFDQTtJQUNBO0NBQ0Q7QUFDTSxTQUFTQyxLQUFLQyxJQUFJLEVBQUVDLFNBQVM7SUFDbEMsTUFBTUMsU0FBUztRQUFFRDtJQUFVO0lBQzNCLElBQUksT0FBT0UsZ0JBQWdCLGVBQWUsQ0FBQ0EsWUFBWUosSUFBSSxFQUFFO0lBQzdESSxZQUFZSixJQUFJLENBQUNDLE1BQU07UUFBRUU7SUFBTztBQUNsQztBQUNBLFNBQVNFLHNCQUFzQkMsS0FBSztJQUNsQyxJQUFJTCxPQUFPSyxNQUFNTCxJQUFJLENBQUNNLEtBQUssQ0FBQyxTQUFTQyxNQUFNO0lBQzNDUCxPQUFPQSxLQUFLUSxNQUFNLENBQUMsR0FBR0MsV0FBVyxLQUFLVCxLQUFLTSxLQUFLLENBQUM7SUFDakQsT0FBTztRQUNMTjtRQUNBVSxXQUFXTCxNQUFNSyxTQUFTO0lBQzVCO0FBQ0Y7QUFDTyxTQUFTQyxlQUFlVixTQUFTO0lBQ3RDLElBQUksT0FBT0UsZ0JBQWdCLGVBQWUsQ0FBQ0EsWUFBWVMsZ0JBQWdCLEVBQUU7UUFDdkUsT0FBTyxFQUFFO0lBQ1g7SUFDQSxNQUFNQyxXQUFXLEVBQUU7SUFDbkIsS0FBSyxNQUFNYixRQUFRRixVQUFXO1FBQzVCLE1BQU1nQixRQUFRWCxZQUFZUyxnQkFBZ0IsQ0FBQ1osTUFBTWUsTUFBTSxDQUFDLENBQUNDLFFBQVVBLE1BQU1DLFNBQVMsS0FBSyxRQUFRRixNQUFNLENBQUMsQ0FBQ1YsUUFBVUEsTUFBTUgsTUFBTSxDQUFDRCxTQUFTLEtBQUtBO1FBQzVJWSxTQUFTSyxJQUFJLElBQUlKO0lBQ25CO0lBQ0EsT0FBT0QsU0FBU00sR0FBRyxDQUFDZjtBQUN0QixFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL2Jyb3dzZXIvc3luYy9tZXRyaWNzLmpzPzNmNTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBtYXJrTmFtZXMgPSBbXG4gIFwiY29udmV4Q2xpZW50Q29uc3RydWN0ZWRcIixcbiAgXCJjb252ZXhXZWJTb2NrZXRPcGVuXCIsXG4gIFwiY29udmV4Rmlyc3RNZXNzYWdlUmVjZWl2ZWRcIlxuXTtcbmV4cG9ydCBmdW5jdGlvbiBtYXJrKG5hbWUsIHNlc3Npb25JZCkge1xuICBjb25zdCBkZXRhaWwgPSB7IHNlc3Npb25JZCB9O1xuICBpZiAodHlwZW9mIHBlcmZvcm1hbmNlID09PSBcInVuZGVmaW5lZFwiIHx8ICFwZXJmb3JtYW5jZS5tYXJrKSByZXR1cm47XG4gIHBlcmZvcm1hbmNlLm1hcmsobmFtZSwgeyBkZXRhaWwgfSk7XG59XG5mdW5jdGlvbiBwZXJmb3JtYW5jZU1hcmtUb0pzb24obWFyazIpIHtcbiAgbGV0IG5hbWUgPSBtYXJrMi5uYW1lLnNsaWNlKFwiY29udmV4XCIubGVuZ3RoKTtcbiAgbmFtZSA9IG5hbWUuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgc3RhcnRUaW1lOiBtYXJrMi5zdGFydFRpbWVcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJrc1JlcG9ydChzZXNzaW9uSWQpIHtcbiAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBhbGxNYXJrcyA9IFtdO1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgbWFya05hbWVzKSB7XG4gICAgY29uc3QgbWFya3MgPSBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKG5hbWUpLmZpbHRlcigoZW50cnkpID0+IGVudHJ5LmVudHJ5VHlwZSA9PT0gXCJtYXJrXCIpLmZpbHRlcigobWFyazIpID0+IG1hcmsyLmRldGFpbC5zZXNzaW9uSWQgPT09IHNlc3Npb25JZCk7XG4gICAgYWxsTWFya3MucHVzaCguLi5tYXJrcyk7XG4gIH1cbiAgcmV0dXJuIGFsbE1hcmtzLm1hcChwZXJmb3JtYW5jZU1hcmtUb0pzb24pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0cmljcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJtYXJrTmFtZXMiLCJtYXJrIiwibmFtZSIsInNlc3Npb25JZCIsImRldGFpbCIsInBlcmZvcm1hbmNlIiwicGVyZm9ybWFuY2VNYXJrVG9Kc29uIiwibWFyazIiLCJzbGljZSIsImxlbmd0aCIsImNoYXJBdCIsInRvTG93ZXJDYXNlIiwic3RhcnRUaW1lIiwiZ2V0TWFya3NSZXBvcnQiLCJnZXRFbnRyaWVzQnlOYW1lIiwiYWxsTWFya3MiLCJtYXJrcyIsImZpbHRlciIsImVudHJ5IiwiZW50cnlUeXBlIiwicHVzaCIsIm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/metrics.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/optimistic_updates_impl.js":
/*!******************************************************************************!*\
  !*** ./node_modules/convex/dist/esm/browser/sync/optimistic_updates_impl.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OptimisticQueryResults: function() { return /* binding */ OptimisticQueryResults; }\n/* harmony export */ });\n/* harmony import */ var _server_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../server/api.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/server/api.js\");\n/* harmony import */ var _common_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/common/index.js\");\n/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../logging.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/logging.js\");\n/* harmony import */ var _udf_path_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./udf_path_utils.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/udf_path_utils.js\");\n/* harmony import */ var _values_errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../values/errors.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/errors.js\");\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n\n\n\n\nclass OptimisticLocalStoreImpl {\n    getQuery(query) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        const queryArgs = (0,_common_index_js__WEBPACK_IMPORTED_MODULE_1__.parseArgs)(args[0]);\n        const name = (0,_server_api_js__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(query);\n        const queryResult = this.queryResults.get((0,_udf_path_utils_js__WEBPACK_IMPORTED_MODULE_3__.serializePathAndArgs)(name, queryArgs));\n        if (queryResult === void 0) {\n            return void 0;\n        }\n        return OptimisticLocalStoreImpl.queryValue(queryResult.result);\n    }\n    getAllQueries(query) {\n        const queriesWithName = [];\n        const name = (0,_server_api_js__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(query);\n        for (const queryResult of this.queryResults.values()){\n            if (queryResult.udfPath === (0,_udf_path_utils_js__WEBPACK_IMPORTED_MODULE_3__.canonicalizeUdfPath)(name)) {\n                queriesWithName.push({\n                    args: queryResult.args,\n                    value: OptimisticLocalStoreImpl.queryValue(queryResult.result)\n                });\n            }\n        }\n        return queriesWithName;\n    }\n    setQuery(queryReference, args, value) {\n        const queryArgs = (0,_common_index_js__WEBPACK_IMPORTED_MODULE_1__.parseArgs)(args);\n        const name = (0,_server_api_js__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(queryReference);\n        const queryToken = (0,_udf_path_utils_js__WEBPACK_IMPORTED_MODULE_3__.serializePathAndArgs)(name, queryArgs);\n        let result;\n        if (value === void 0) {\n            result = void 0;\n        } else {\n            result = {\n                success: true,\n                value,\n                // It's an optimistic update, so there are no function logs to show.\n                logLines: []\n            };\n        }\n        const query = {\n            udfPath: name,\n            args: queryArgs,\n            result\n        };\n        this.queryResults.set(queryToken, query);\n        this.modifiedQueries.push(queryToken);\n    }\n    static queryValue(result) {\n        if (result === void 0) {\n            return void 0;\n        } else if (result.success) {\n            return result.value;\n        } else {\n            return void 0;\n        }\n    }\n    constructor(queryResults){\n        // A references of the query results in OptimisticQueryResults\n        __publicField(this, \"queryResults\");\n        // All of the queries modified by this class\n        __publicField(this, \"modifiedQueries\");\n        this.queryResults = queryResults;\n        this.modifiedQueries = [];\n    }\n}\nclass OptimisticQueryResults {\n    /**\n   * Apply all optimistic updates on top of server query results\n   */ ingestQueryResultsFromServer(serverQueryResults, optimisticUpdatesToDrop) {\n        this.optimisticUpdates = this.optimisticUpdates.filter((updateAndId)=>{\n            return !optimisticUpdatesToDrop.has(updateAndId.mutationId);\n        });\n        const oldQueryResults = this.queryResults;\n        this.queryResults = new Map(serverQueryResults);\n        const localStore = new OptimisticLocalStoreImpl(this.queryResults);\n        for (const updateAndId of this.optimisticUpdates){\n            updateAndId.update(localStore);\n        }\n        const changedQueries = [];\n        for (const [queryToken, query] of this.queryResults){\n            const oldQuery = oldQueryResults.get(queryToken);\n            if (oldQuery === void 0 || oldQuery.result !== query.result) {\n                changedQueries.push(queryToken);\n            }\n        }\n        return changedQueries;\n    }\n    applyOptimisticUpdate(update, mutationId) {\n        this.optimisticUpdates.push({\n            update,\n            mutationId\n        });\n        const localStore = new OptimisticLocalStoreImpl(this.queryResults);\n        update(localStore);\n        return localStore.modifiedQueries;\n    }\n    /**\n   * \"Raw\" with respect to errors vs values, but query results still have\n   * optimistic updates applied.\n   *\n   * @internal\n   */ rawQueryResult(queryToken) {\n        const query = this.queryResults.get(queryToken);\n        if (query === void 0) {\n            return void 0;\n        }\n        return query.result;\n    }\n    queryResult(queryToken) {\n        const query = this.queryResults.get(queryToken);\n        if (query === void 0) {\n            return void 0;\n        }\n        const result = query.result;\n        if (result === void 0) {\n            return void 0;\n        } else if (result.success) {\n            return result.value;\n        } else {\n            if (result.errorData !== void 0) {\n                throw (0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.forwardData)(result, new _values_errors_js__WEBPACK_IMPORTED_MODULE_4__.ConvexError((0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.createHybridErrorStacktrace)(\"query\", query.udfPath, result)));\n            }\n            throw new Error((0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.createHybridErrorStacktrace)(\"query\", query.udfPath, result));\n        }\n    }\n    hasQueryResult(queryToken) {\n        return this.queryResults.get(queryToken) !== void 0;\n    }\n    /**\n   * @internal\n   */ queryLogs(queryToken) {\n        var _query_result;\n        const query = this.queryResults.get(queryToken);\n        return query === null || query === void 0 ? void 0 : (_query_result = query.result) === null || _query_result === void 0 ? void 0 : _query_result.logLines;\n    }\n    constructor(){\n        __publicField(this, \"queryResults\");\n        __publicField(this, \"optimisticUpdates\");\n        this.queryResults = /* @__PURE__ */ new Map();\n        this.optimisticUpdates = [];\n    }\n} //# sourceMappingURL=optimistic_updates_impl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL29wdGltaXN0aWNfdXBkYXRlc19pbXBsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxrQkFBa0IsQ0FBQ0MsS0FBS0MsS0FBS0MsUUFBVUQsT0FBT0QsTUFBTUosVUFBVUksS0FBS0MsS0FBSztRQUFFRSxZQUFZO1FBQU1DLGNBQWM7UUFBTUMsVUFBVTtRQUFNSDtJQUFNLEtBQUtGLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztBQUMxSixJQUFJSSxnQkFBZ0IsQ0FBQ04sS0FBS0MsS0FBS0MsUUFBVUgsZ0JBQWdCQyxLQUFLLE9BQU9DLFFBQVEsV0FBV0EsTUFBTSxLQUFLQSxLQUFLQztBQUczRTtBQUNxQjtBQUN1QjtBQUk1QztBQUN3QjtBQUNyRCxNQUFNWTtJQVNKQyxTQUFTQyxLQUFLLEVBQVc7UUFBVDtZQUFHQyxLQUFILDJCQUFPOztRQUNyQixNQUFNQyxZQUFZViwyREFBU0EsQ0FBQ1MsSUFBSSxDQUFDLEVBQUU7UUFDbkMsTUFBTUUsT0FBT1osK0RBQWVBLENBQUNTO1FBQzdCLE1BQU1JLGNBQWMsSUFBSSxDQUFDQyxZQUFZLENBQUNDLEdBQUcsQ0FDdkNWLHdFQUFvQkEsQ0FBQ08sTUFBTUQ7UUFFN0IsSUFBSUUsZ0JBQWdCLEtBQUssR0FBRztZQUMxQixPQUFPLEtBQUs7UUFDZDtRQUNBLE9BQU9OLHlCQUF5QlMsVUFBVSxDQUFDSCxZQUFZSSxNQUFNO0lBQy9EO0lBQ0FDLGNBQWNULEtBQUssRUFBRTtRQUNuQixNQUFNVSxrQkFBa0IsRUFBRTtRQUMxQixNQUFNUCxPQUFPWiwrREFBZUEsQ0FBQ1M7UUFDN0IsS0FBSyxNQUFNSSxlQUFlLElBQUksQ0FBQ0MsWUFBWSxDQUFDTSxNQUFNLEdBQUk7WUFDcEQsSUFBSVAsWUFBWVEsT0FBTyxLQUFLakIsdUVBQW1C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QUNOLGlCQUFpQixHQUFHLEVBQUU7SUFDN0I7QUErRUYsRUFDQSxtREFBbUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9icm93c2VyL3N5bmMvb3B0aW1pc3RpY191cGRhdGVzX2ltcGwuanM/NDVhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5pbXBvcnQge1xuICBnZXRGdW5jdGlvbk5hbWVcbn0gZnJvbSBcIi4uLy4uL3NlcnZlci9hcGkuanNcIjtcbmltcG9ydCB7IHBhcnNlQXJncyB9IGZyb20gXCIuLi8uLi9jb21tb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGNyZWF0ZUh5YnJpZEVycm9yU3RhY2t0cmFjZSwgZm9yd2FyZERhdGEgfSBmcm9tIFwiLi4vbG9nZ2luZy5qc1wiO1xuaW1wb3J0IHtcbiAgY2Fub25pY2FsaXplVWRmUGF0aCxcbiAgc2VyaWFsaXplUGF0aEFuZEFyZ3Ncbn0gZnJvbSBcIi4vdWRmX3BhdGhfdXRpbHMuanNcIjtcbmltcG9ydCB7IENvbnZleEVycm9yIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9lcnJvcnMuanNcIjtcbmNsYXNzIE9wdGltaXN0aWNMb2NhbFN0b3JlSW1wbCB7XG4gIGNvbnN0cnVjdG9yKHF1ZXJ5UmVzdWx0cykge1xuICAgIC8vIEEgcmVmZXJlbmNlcyBvZiB0aGUgcXVlcnkgcmVzdWx0cyBpbiBPcHRpbWlzdGljUXVlcnlSZXN1bHRzXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInF1ZXJ5UmVzdWx0c1wiKTtcbiAgICAvLyBBbGwgb2YgdGhlIHF1ZXJpZXMgbW9kaWZpZWQgYnkgdGhpcyBjbGFzc1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtb2RpZmllZFF1ZXJpZXNcIik7XG4gICAgdGhpcy5xdWVyeVJlc3VsdHMgPSBxdWVyeVJlc3VsdHM7XG4gICAgdGhpcy5tb2RpZmllZFF1ZXJpZXMgPSBbXTtcbiAgfVxuICBnZXRRdWVyeShxdWVyeSwgLi4uYXJncykge1xuICAgIGNvbnN0IHF1ZXJ5QXJncyA9IHBhcnNlQXJncyhhcmdzWzBdKTtcbiAgICBjb25zdCBuYW1lID0gZ2V0RnVuY3Rpb25OYW1lKHF1ZXJ5KTtcbiAgICBjb25zdCBxdWVyeVJlc3VsdCA9IHRoaXMucXVlcnlSZXN1bHRzLmdldChcbiAgICAgIHNlcmlhbGl6ZVBhdGhBbmRBcmdzKG5hbWUsIHF1ZXJ5QXJncylcbiAgICApO1xuICAgIGlmIChxdWVyeVJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gT3B0aW1pc3RpY0xvY2FsU3RvcmVJbXBsLnF1ZXJ5VmFsdWUocXVlcnlSZXN1bHQucmVzdWx0KTtcbiAgfVxuICBnZXRBbGxRdWVyaWVzKHF1ZXJ5KSB7XG4gICAgY29uc3QgcXVlcmllc1dpdGhOYW1lID0gW107XG4gICAgY29uc3QgbmFtZSA9IGdldEZ1bmN0aW9uTmFtZShxdWVyeSk7XG4gICAgZm9yIChjb25zdCBxdWVyeVJlc3VsdCBvZiB0aGlzLnF1ZXJ5UmVzdWx0cy52YWx1ZXMoKSkge1xuICAgICAgaWYgKHF1ZXJ5UmVzdWx0LnVkZlBhdGggPT09IGNhbm9uaWNhbGl6ZVVkZlBhdGgobmFtZSkpIHtcbiAgICAgICAgcXVlcmllc1dpdGhOYW1lLnB1c2goe1xuICAgICAgICAgIGFyZ3M6IHF1ZXJ5UmVzdWx0LmFyZ3MsXG4gICAgICAgICAgdmFsdWU6IE9wdGltaXN0aWNMb2NhbFN0b3JlSW1wbC5xdWVyeVZhbHVlKHF1ZXJ5UmVzdWx0LnJlc3VsdClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWVyaWVzV2l0aE5hbWU7XG4gIH1cbiAgc2V0UXVlcnkocXVlcnlSZWZlcmVuY2UsIGFyZ3MsIHZhbHVlKSB7XG4gICAgY29uc3QgcXVlcnlBcmdzID0gcGFyc2VBcmdzKGFyZ3MpO1xuICAgIGNvbnN0IG5hbWUgPSBnZXRGdW5jdGlvbk5hbWUocXVlcnlSZWZlcmVuY2UpO1xuICAgIGNvbnN0IHF1ZXJ5VG9rZW4gPSBzZXJpYWxpemVQYXRoQW5kQXJncyhuYW1lLCBxdWVyeUFyZ3MpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJlc3VsdCA9IHZvaWQgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgLy8gSXQncyBhbiBvcHRpbWlzdGljIHVwZGF0ZSwgc28gdGhlcmUgYXJlIG5vIGZ1bmN0aW9uIGxvZ3MgdG8gc2hvdy5cbiAgICAgICAgbG9nTGluZXM6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBxdWVyeSA9IHtcbiAgICAgIHVkZlBhdGg6IG5hbWUsXG4gICAgICBhcmdzOiBxdWVyeUFyZ3MsXG4gICAgICByZXN1bHRcbiAgICB9O1xuICAgIHRoaXMucXVlcnlSZXN1bHRzLnNldChxdWVyeVRva2VuLCBxdWVyeSk7XG4gICAgdGhpcy5tb2RpZmllZFF1ZXJpZXMucHVzaChxdWVyeVRva2VuKTtcbiAgfVxuICBzdGF0aWMgcXVlcnlWYWx1ZShyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBPcHRpbWlzdGljUXVlcnlSZXN1bHRzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInF1ZXJ5UmVzdWx0c1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib3B0aW1pc3RpY1VwZGF0ZXNcIik7XG4gICAgdGhpcy5xdWVyeVJlc3VsdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMgPSBbXTtcbiAgfVxuICAvKipcbiAgICogQXBwbHkgYWxsIG9wdGltaXN0aWMgdXBkYXRlcyBvbiB0b3Agb2Ygc2VydmVyIHF1ZXJ5IHJlc3VsdHNcbiAgICovXG4gIGluZ2VzdFF1ZXJ5UmVzdWx0c0Zyb21TZXJ2ZXIoc2VydmVyUXVlcnlSZXN1bHRzLCBvcHRpbWlzdGljVXBkYXRlc1RvRHJvcCkge1xuICAgIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMgPSB0aGlzLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcigodXBkYXRlQW5kSWQpID0+IHtcbiAgICAgIHJldHVybiAhb3B0aW1pc3RpY1VwZGF0ZXNUb0Ryb3AuaGFzKHVwZGF0ZUFuZElkLm11dGF0aW9uSWQpO1xuICAgIH0pO1xuICAgIGNvbnN0IG9sZFF1ZXJ5UmVzdWx0cyA9IHRoaXMucXVlcnlSZXN1bHRzO1xuICAgIHRoaXMucXVlcnlSZXN1bHRzID0gbmV3IE1hcChzZXJ2ZXJRdWVyeVJlc3VsdHMpO1xuICAgIGNvbnN0IGxvY2FsU3RvcmUgPSBuZXcgT3B0aW1pc3RpY0xvY2FsU3RvcmVJbXBsKHRoaXMucXVlcnlSZXN1bHRzKTtcbiAgICBmb3IgKGNvbnN0IHVwZGF0ZUFuZElkIG9mIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMpIHtcbiAgICAgIHVwZGF0ZUFuZElkLnVwZGF0ZShsb2NhbFN0b3JlKTtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlZFF1ZXJpZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtxdWVyeVRva2VuLCBxdWVyeV0gb2YgdGhpcy5xdWVyeVJlc3VsdHMpIHtcbiAgICAgIGNvbnN0IG9sZFF1ZXJ5ID0gb2xkUXVlcnlSZXN1bHRzLmdldChxdWVyeVRva2VuKTtcbiAgICAgIGlmIChvbGRRdWVyeSA9PT0gdm9pZCAwIHx8IG9sZFF1ZXJ5LnJlc3VsdCAhPT0gcXVlcnkucmVzdWx0KSB7XG4gICAgICAgIGNoYW5nZWRRdWVyaWVzLnB1c2gocXVlcnlUb2tlbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkUXVlcmllcztcbiAgfVxuICBhcHBseU9wdGltaXN0aWNVcGRhdGUodXBkYXRlLCBtdXRhdGlvbklkKSB7XG4gICAgdGhpcy5vcHRpbWlzdGljVXBkYXRlcy5wdXNoKHtcbiAgICAgIHVwZGF0ZSxcbiAgICAgIG11dGF0aW9uSWRcbiAgICB9KTtcbiAgICBjb25zdCBsb2NhbFN0b3JlID0gbmV3IE9wdGltaXN0aWNMb2NhbFN0b3JlSW1wbCh0aGlzLnF1ZXJ5UmVzdWx0cyk7XG4gICAgdXBkYXRlKGxvY2FsU3RvcmUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlLm1vZGlmaWVkUXVlcmllcztcbiAgfVxuICAvKipcbiAgICogXCJSYXdcIiB3aXRoIHJlc3BlY3QgdG8gZXJyb3JzIHZzIHZhbHVlcywgYnV0IHF1ZXJ5IHJlc3VsdHMgc3RpbGwgaGF2ZVxuICAgKiBvcHRpbWlzdGljIHVwZGF0ZXMgYXBwbGllZC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICByYXdRdWVyeVJlc3VsdChxdWVyeVRva2VuKSB7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5UmVzdWx0cy5nZXQocXVlcnlUb2tlbik7XG4gICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeS5yZXN1bHQ7XG4gIH1cbiAgcXVlcnlSZXN1bHQocXVlcnlUb2tlbikge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeVJlc3VsdHMuZ2V0KHF1ZXJ5VG9rZW4pO1xuICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBxdWVyeS5yZXN1bHQ7XG4gICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3JEYXRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgZm9yd2FyZERhdGEoXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIG5ldyBDb252ZXhFcnJvcihcbiAgICAgICAgICAgIGNyZWF0ZUh5YnJpZEVycm9yU3RhY2t0cmFjZShcInF1ZXJ5XCIsIHF1ZXJ5LnVkZlBhdGgsIHJlc3VsdClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGNyZWF0ZUh5YnJpZEVycm9yU3RhY2t0cmFjZShcInF1ZXJ5XCIsIHF1ZXJ5LnVkZlBhdGgsIHJlc3VsdClcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGhhc1F1ZXJ5UmVzdWx0KHF1ZXJ5VG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVJlc3VsdHMuZ2V0KHF1ZXJ5VG9rZW4pICE9PSB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcXVlcnlMb2dzKHF1ZXJ5VG9rZW4pIHtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnlSZXN1bHRzLmdldChxdWVyeVRva2VuKTtcbiAgICByZXR1cm4gcXVlcnk/LnJlc3VsdD8ubG9nTGluZXM7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wdGltaXN0aWNfdXBkYXRlc19pbXBsLmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19kZWZOb3JtYWxQcm9wIiwib2JqIiwia2V5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX3B1YmxpY0ZpZWxkIiwiZ2V0RnVuY3Rpb25OYW1lIiwicGFyc2VBcmdzIiwiY3JlYXRlSHlicmlkRXJyb3JTdGFja3RyYWNlIiwiZm9yd2FyZERhdGEiLCJjYW5vbmljYWxpemVVZGZQYXRoIiwic2VyaWFsaXplUGF0aEFuZEFyZ3MiLCJDb252ZXhFcnJvciIsIk9wdGltaXN0aWNMb2NhbFN0b3JlSW1wbCIsImdldFF1ZXJ5IiwicXVlcnkiLCJhcmdzIiwicXVlcnlBcmdzIiwibmFtZSIsInF1ZXJ5UmVzdWx0IiwicXVlcnlSZXN1bHRzIiwiZ2V0IiwicXVlcnlWYWx1ZSIsInJlc3VsdCIsImdldEFsbFF1ZXJpZXMiLCJxdWVyaWVzV2l0aE5hbWUiLCJ2YWx1ZXMiLCJ1ZGZQYXRoIiwicHVzaCIsInNldFF1ZXJ5IiwicXVlcnlSZWZlcmVuY2UiLCJxdWVyeVRva2VuIiwic3VjY2VzcyIsImxvZ0xpbmVzIiwic2V0IiwibW9kaWZpZWRRdWVyaWVzIiwiY29uc3RydWN0b3IiLCJPcHRpbWlzdGljUXVlcnlSZXN1bHRzIiwiaW5nZXN0UXVlcnlSZXN1bHRzRnJvbVNlcnZlciIsInNlcnZlclF1ZXJ5UmVzdWx0cyIsIm9wdGltaXN0aWNVcGRhdGVzVG9Ecm9wIiwib3B0aW1pc3RpY1VwZGF0ZXMiLCJmaWx0ZXIiLCJ1cGRhdGVBbmRJZCIsImhhcyIsIm11dGF0aW9uSWQiLCJvbGRRdWVyeVJlc3VsdHMiLCJNYXAiLCJsb2NhbFN0b3JlIiwidXBkYXRlIiwiY2hhbmdlZFF1ZXJpZXMiLCJvbGRRdWVyeSIsImFwcGx5T3B0aW1pc3RpY1VwZGF0ZSIsInJhd1F1ZXJ5UmVzdWx0IiwiZXJyb3JEYXRhIiwiRXJyb3IiLCJoYXNRdWVyeVJlc3VsdCIsInF1ZXJ5TG9ncyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/optimistic_updates_impl.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/paginated_query_client.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/convex/dist/esm/browser/sync/paginated_query_client.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PaginatedQueryClient: function() { return /* binding */ PaginatedQueryClient; }\n/* harmony export */ });\n/* harmony import */ var _udf_path_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./udf_path_utils.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/udf_path_utils.js\");\n/* harmony import */ var _pagination_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pagination.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/pagination.js\");\n/* harmony import */ var _vendor_long_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../vendor/long.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/vendor/long.js\");\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n\n\nclass PaginatedQueryClient {\n    /**\n   * Subscribe to a paginated query.\n   *\n   * @param name - The name of the paginated query function\n   * @param args - Arguments for the query (excluding paginationOpts)\n   * @param options - Pagination options including initialNumItems\n   * @returns Object with paginatedQueryToken and unsubscribe function\n   */ subscribe(name, args, options) {\n        const canonicalizedUdfPath = (0,_udf_path_utils_js__WEBPACK_IMPORTED_MODULE_0__.canonicalizeUdfPath)(name);\n        const token = (0,_udf_path_utils_js__WEBPACK_IMPORTED_MODULE_0__.serializePaginatedPathAndArgs)(canonicalizedUdfPath, args, options);\n        const unsubscribe = ()=>this.removePaginatedQuerySubscriber(token);\n        const existingEntry = this.paginatedQuerySet.get(token);\n        if (existingEntry) {\n            existingEntry.numSubscribers += 1;\n            return {\n                paginatedQueryToken: token,\n                unsubscribe\n            };\n        }\n        this.paginatedQuerySet.set(token, {\n            token,\n            canonicalizedUdfPath,\n            args,\n            numSubscribers: 1,\n            options: {\n                initialNumItems: options.initialNumItems\n            },\n            nextPageKey: 0,\n            pageKeys: [],\n            pageKeyToQuery: /* @__PURE__ */ new Map(),\n            ongoingSplits: /* @__PURE__ */ new Map(),\n            skip: false,\n            id: options.id\n        });\n        this.addPageToPaginatedQuery(token, null, options.initialNumItems);\n        return {\n            paginatedQueryToken: token,\n            unsubscribe\n        };\n    }\n    /**\n   * Get current results for a paginated query based on local state.\n   *\n   * Throws an error when one of the pages has errored.\n   */ localQueryResult(name, args, options) {\n        const canonicalizedUdfPath = (0,_udf_path_utils_js__WEBPACK_IMPORTED_MODULE_0__.canonicalizeUdfPath)(name);\n        const token = (0,_udf_path_utils_js__WEBPACK_IMPORTED_MODULE_0__.serializePaginatedPathAndArgs)(canonicalizedUdfPath, args, options);\n        return this.localQueryResultByToken(token);\n    }\n    /**\n   * @internal\n   */ localQueryResultByToken(token) {\n        const paginatedQuery = this.paginatedQuerySet.get(token);\n        if (!paginatedQuery) {\n            return void 0;\n        }\n        const activePages = this.activePageQueryTokens(paginatedQuery);\n        if (activePages.length === 0) {\n            return {\n                results: [],\n                status: \"LoadingFirstPage\",\n                loadMore: (numItems)=>{\n                    return this.loadMoreOfPaginatedQuery(token, numItems);\n                }\n            };\n        }\n        let allResults = [];\n        let hasUndefined = false;\n        let isDone = false;\n        for (const pageToken of activePages){\n            const result = this.client.localQueryResultByToken(pageToken);\n            if (result === void 0) {\n                hasUndefined = true;\n                isDone = false;\n                continue;\n            }\n            const paginationResult = (0,_pagination_js__WEBPACK_IMPORTED_MODULE_1__.asPaginationResult)(result);\n            allResults = allResults.concat(paginationResult.page);\n            isDone = !!paginationResult.isDone;\n        }\n        let status;\n        if (hasUndefined) {\n            status = allResults.length === 0 ? \"LoadingFirstPage\" : \"LoadingMore\";\n        } else if (isDone) {\n            status = \"Exhausted\";\n        } else {\n            status = \"CanLoadMore\";\n        }\n        return {\n            results: allResults,\n            status,\n            loadMore: (numItems)=>{\n                return this.loadMoreOfPaginatedQuery(token, numItems);\n            }\n        };\n    }\n    onBaseTransition(transition) {\n        const changedBaseTokens = transition.queries.map((q)=>q.token);\n        const changed = this.queriesContainingTokens(changedBaseTokens);\n        let paginatedQueries = [];\n        if (changed.length > 0) {\n            this.processPaginatedQuerySplits(changed, (token)=>this.client.localQueryResultByToken(token));\n            paginatedQueries = changed.map((token)=>({\n                    token,\n                    modification: {\n                        kind: \"Updated\",\n                        result: this.localQueryResultByToken(token)\n                    }\n                }));\n        }\n        const extendedTransition = {\n            ...transition,\n            paginatedQueries\n        };\n        this.onTransition(extendedTransition);\n    }\n    /**\n   * Load more items for a paginated query.\n   *\n   * This *always* causes a transition, the status of the query\n   * has probably changed from \"CanLoadMore\" to \"LoadingMore\".\n   * Data might have changed too: maybe a subscription to this page\n   * query already exists (unlikely but possible) or this page query\n   * has an optimistic update providing some initial data.\n   *\n   * @internal\n   */ loadMoreOfPaginatedQuery(token, numItems) {\n        this.mustGetPaginatedQuery(token);\n        const lastPageToken = this.queryTokenForLastPageOfPaginatedQuery(token);\n        const lastPageResult = this.client.localQueryResultByToken(lastPageToken);\n        if (!lastPageResult) {\n            return false;\n        }\n        const paginationResult = (0,_pagination_js__WEBPACK_IMPORTED_MODULE_1__.asPaginationResult)(lastPageResult);\n        if (paginationResult.isDone) {\n            return false;\n        }\n        this.addPageToPaginatedQuery(token, paginationResult.continueCursor, numItems);\n        const loadMoreTransition = {\n            timestamp: this.lastTransitionTs,\n            reflectedMutations: [],\n            queries: [],\n            paginatedQueries: [\n                {\n                    token,\n                    modification: {\n                        kind: \"Updated\",\n                        result: this.localQueryResultByToken(token)\n                    }\n                }\n            ]\n        };\n        this.onTransition(loadMoreTransition);\n        return true;\n    }\n    /**\n   * @internal\n   */ queriesContainingTokens(queryTokens) {\n        if (queryTokens.length === 0) {\n            return [];\n        }\n        const changed = [];\n        const queryTokenSet = new Set(queryTokens);\n        for (const [paginatedToken, paginatedQuery] of this.paginatedQuerySet){\n            for (const pageToken of this.allQueryTokens(paginatedQuery)){\n                if (queryTokenSet.has(pageToken)) {\n                    changed.push(paginatedToken);\n                    break;\n                }\n            }\n        }\n        return changed;\n    }\n    /**\n   * @internal\n   */ processPaginatedQuerySplits(changed, getResult) {\n        for (const paginatedQueryToken of changed){\n            const paginatedQuery = this.mustGetPaginatedQuery(paginatedQueryToken);\n            const { ongoingSplits, pageKeyToQuery, pageKeys } = paginatedQuery;\n            for (const [pageKey, [splitKey1, splitKey2]] of ongoingSplits){\n                const bothNewPagesLoaded = getResult(pageKeyToQuery.get(splitKey1).queryToken) !== void 0 && getResult(pageKeyToQuery.get(splitKey2).queryToken) !== void 0;\n                if (bothNewPagesLoaded) {\n                    this.completePaginatedQuerySplit(paginatedQuery, pageKey, splitKey1, splitKey2);\n                }\n            }\n            for (const pageKey of pageKeys){\n                if (ongoingSplits.has(pageKey)) {\n                    continue;\n                }\n                const pageToken = pageKeyToQuery.get(pageKey).queryToken;\n                const pageResult = getResult(pageToken);\n                if (!pageResult) {\n                    continue;\n                }\n                const result = (0,_pagination_js__WEBPACK_IMPORTED_MODULE_1__.asPaginationResult)(pageResult);\n                const shouldSplit = result.splitCursor && (result.pageStatus === \"SplitRecommended\" || result.pageStatus === \"SplitRequired\" || // This client-driven page splitting condition will change in the future.\n                result.page.length > paginatedQuery.options.initialNumItems * 2);\n                if (shouldSplit) {\n                    this.splitPaginatedQueryPage(paginatedQuery, pageKey, result.splitCursor, // we just checked\n                    result.continueCursor);\n                }\n            }\n        }\n    }\n    splitPaginatedQueryPage(paginatedQuery, pageKey, splitCursor, continueCursor) {\n        const splitKey1 = paginatedQuery.nextPageKey++;\n        const splitKey2 = paginatedQuery.nextPageKey++;\n        const paginationOpts = {\n            cursor: continueCursor,\n            numItems: paginatedQuery.options.initialNumItems,\n            id: paginatedQuery.id\n        };\n        const firstSubscription = this.client.subscribe(paginatedQuery.canonicalizedUdfPath, {\n            ...paginatedQuery.args,\n            paginationOpts: {\n                ...paginationOpts,\n                cursor: null,\n                // Start from beginning for first split\n                endCursor: splitCursor\n            }\n        });\n        paginatedQuery.pageKeyToQuery.set(splitKey1, firstSubscription);\n        const secondSubscription = this.client.subscribe(paginatedQuery.canonicalizedUdfPath, {\n            ...paginatedQuery.args,\n            paginationOpts: {\n                ...paginationOpts,\n                cursor: splitCursor,\n                endCursor: continueCursor\n            }\n        });\n        paginatedQuery.pageKeyToQuery.set(splitKey2, secondSubscription);\n        paginatedQuery.ongoingSplits.set(pageKey, [\n            splitKey1,\n            splitKey2\n        ]);\n    }\n    /**\n   * @internal\n   */ addPageToPaginatedQuery(token, continueCursor, numItems) {\n        const paginatedQuery = this.mustGetPaginatedQuery(token);\n        const pageKey = paginatedQuery.nextPageKey++;\n        const paginationOpts = {\n            cursor: continueCursor,\n            numItems,\n            id: paginatedQuery.id\n        };\n        const pageArgs = {\n            ...paginatedQuery.args,\n            paginationOpts\n        };\n        const subscription = this.client.subscribe(paginatedQuery.canonicalizedUdfPath, pageArgs);\n        paginatedQuery.pageKeys.push(pageKey);\n        paginatedQuery.pageKeyToQuery.set(pageKey, subscription);\n        return subscription;\n    }\n    removePaginatedQuerySubscriber(token) {\n        const paginatedQuery = this.paginatedQuerySet.get(token);\n        if (!paginatedQuery) {\n            return;\n        }\n        paginatedQuery.numSubscribers -= 1;\n        if (paginatedQuery.numSubscribers > 0) {\n            return;\n        }\n        for (const subscription of paginatedQuery.pageKeyToQuery.values()){\n            subscription.unsubscribe();\n        }\n        this.paginatedQuerySet.delete(token);\n    }\n    completePaginatedQuerySplit(paginatedQuery, pageKey, splitKey1, splitKey2) {\n        const originalQuery = paginatedQuery.pageKeyToQuery.get(pageKey);\n        paginatedQuery.pageKeyToQuery.delete(pageKey);\n        const pageIndex = paginatedQuery.pageKeys.indexOf(pageKey);\n        paginatedQuery.pageKeys.splice(pageIndex, 1, splitKey1, splitKey2);\n        paginatedQuery.ongoingSplits.delete(pageKey);\n        originalQuery.unsubscribe();\n    }\n    /** The query tokens for all active pages, in result order */ activePageQueryTokens(paginatedQuery) {\n        return paginatedQuery.pageKeys.map((pageKey)=>paginatedQuery.pageKeyToQuery.get(pageKey).queryToken);\n    }\n    allQueryTokens(paginatedQuery) {\n        return Array.from(paginatedQuery.pageKeyToQuery.values()).map((sub)=>sub.queryToken);\n    }\n    queryTokenForLastPageOfPaginatedQuery(token) {\n        const paginatedQuery = this.mustGetPaginatedQuery(token);\n        const lastPageKey = paginatedQuery.pageKeys[paginatedQuery.pageKeys.length - 1];\n        if (lastPageKey === void 0) {\n            throw new Error(\"No pages for paginated query \".concat(token));\n        }\n        return paginatedQuery.pageKeyToQuery.get(lastPageKey).queryToken;\n    }\n    mustGetPaginatedQuery(token) {\n        const paginatedQuery = this.paginatedQuerySet.get(token);\n        if (!paginatedQuery) {\n            throw new Error(\"paginated query no longer exists for token \" + token);\n        }\n        return paginatedQuery;\n    }\n    constructor(client, onTransition){\n        this.client = client;\n        this.onTransition = onTransition;\n        __publicField(this, \"paginatedQuerySet\", /* @__PURE__ */ new Map());\n        // hold onto a real Transition so we can construct synthetic ones with that timestamp\n        __publicField(this, \"lastTransitionTs\");\n        this.lastTransitionTs = _vendor_long_js__WEBPACK_IMPORTED_MODULE_2__.Long.fromNumber(0);\n        this.client.addOnTransitionHandler((transition)=>this.onBaseTransition(transition));\n    }\n} //# sourceMappingURL=paginated_query_client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL3BhZ2luYXRlZF9xdWVyeV9jbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxrQkFBa0IsQ0FBQ0MsS0FBS0MsS0FBS0MsUUFBVUQsT0FBT0QsTUFBTUosVUFBVUksS0FBS0MsS0FBSztRQUFFRSxZQUFZO1FBQU1DLGNBQWM7UUFBTUMsVUFBVTtRQUFNSDtJQUFNLEtBQUtGLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztBQUMxSixJQUFJSSxnQkFBZ0IsQ0FBQ04sS0FBS0MsS0FBS0MsUUFBVUgsZ0JBQWdCQyxLQUFLLE9BQU9DLFFBQVEsV0FBV0EsTUFBTSxLQUFLQSxLQUFLQztBQUkzRTtBQUdKO0FBQ21CO0FBQ3JDLE1BQU1TO0lBWVg7Ozs7Ozs7R0FPQyxHQUNEQyxVQUFVQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsT0FBTyxFQUFFO1FBQzdCLE1BQU1DLHVCQUF1QlIsdUVBQW1CQSxDQUFDSztRQUNqRCxNQUFNSSxRQUFRVixpRkFBNkJBLENBQ3pDUyxzQkFDQUYsTUFDQUM7UUFFRixNQUFNRyxjQUFjLElBQU0sSUFBSSxDQUFDQyw4QkFBOEIsQ0FBQ0Y7UUFDOUQsTUFBTUcsZ0JBQWdCLElBQUksQ0FBQ0MsaUJBQWlCLENBQUNDLEdBQUcsQ0FBQ0w7UUFDakQsSUFBSUcsZUFBZTtZQUNqQkEsY0FBY0csY0FBYyxJQUFJO1lBQ2hDLE9BQU87Z0JBQ0xDLHFCQUFxQlA7Z0JBQ3JCQztZQUNGO1FBQ0Y7UUFDQSxJQUFJLENBQUNHLGlCQUFpQixDQUFDSSxHQUFHLENBQUNSLE9BQU87WUFDaENBO1lBQ0FEO1lBQ0FGO1lBQ0FTLGdCQUFnQjtZQUNoQlIsU0FBUztnQkFBRVcsaUJBQWlCWCxRQUFRVyxlQUFlO1lBQUM7WUFDcERDLGFBQWE7WUFDYkMsVUFBVSxFQUFFO1lB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RSxxQkFBcUIsYUFBYSxHQUFHLElBQUl3QjtRQUM3RCxxRkFBcUY7UUFDckZ4QixjQUFjLElBQUksRUFBRTtRQUNwQixJQUFJLENBQUNzRSxnQkFBZ0IsR0FBR2xFLGlEQUFJQSxDQUFDMEcsVUFBVSxDQUFDO1FBQ3hDLElBQUksQ0FBQ2pFLE1BQU0sQ0FBQ2tFLHNCQUFzQixDQUNoQyxDQUFDN0QsYUFBZSxJQUFJLENBQUNELGdCQUFnQixDQUFDQztJQUUxQztBQW9WRixFQUNBLGtEQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL2Jyb3dzZXIvc3luYy9wYWdpbmF0ZWRfcXVlcnlfY2xpZW50LmpzPzYzZjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuaW1wb3J0IHtcbiAgc2VyaWFsaXplUGFnaW5hdGVkUGF0aEFuZEFyZ3MsXG4gIGNhbm9uaWNhbGl6ZVVkZlBhdGhcbn0gZnJvbSBcIi4vdWRmX3BhdGhfdXRpbHMuanNcIjtcbmltcG9ydCB7XG4gIGFzUGFnaW5hdGlvblJlc3VsdFxufSBmcm9tIFwiLi9wYWdpbmF0aW9uLmpzXCI7XG5pbXBvcnQgeyBMb25nIH0gZnJvbSBcIi4uLy4uL3ZlbmRvci9sb25nLmpzXCI7XG5leHBvcnQgY2xhc3MgUGFnaW5hdGVkUXVlcnlDbGllbnQge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIG9uVHJhbnNpdGlvbikge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMub25UcmFuc2l0aW9uID0gb25UcmFuc2l0aW9uO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwYWdpbmF0ZWRRdWVyeVNldFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICAvLyBob2xkIG9udG8gYSByZWFsIFRyYW5zaXRpb24gc28gd2UgY2FuIGNvbnN0cnVjdCBzeW50aGV0aWMgb25lcyB3aXRoIHRoYXQgdGltZXN0YW1wXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxhc3RUcmFuc2l0aW9uVHNcIik7XG4gICAgdGhpcy5sYXN0VHJhbnNpdGlvblRzID0gTG9uZy5mcm9tTnVtYmVyKDApO1xuICAgIHRoaXMuY2xpZW50LmFkZE9uVHJhbnNpdGlvbkhhbmRsZXIoXG4gICAgICAodHJhbnNpdGlvbikgPT4gdGhpcy5vbkJhc2VUcmFuc2l0aW9uKHRyYW5zaXRpb24pXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIGEgcGFnaW5hdGVkIHF1ZXJ5LlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwYWdpbmF0ZWQgcXVlcnkgZnVuY3Rpb25cbiAgICogQHBhcmFtIGFyZ3MgLSBBcmd1bWVudHMgZm9yIHRoZSBxdWVyeSAoZXhjbHVkaW5nIHBhZ2luYXRpb25PcHRzKVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBhZ2luYXRpb24gb3B0aW9ucyBpbmNsdWRpbmcgaW5pdGlhbE51bUl0ZW1zXG4gICAqIEByZXR1cm5zIE9iamVjdCB3aXRoIHBhZ2luYXRlZFF1ZXJ5VG9rZW4gYW5kIHVuc3Vic2NyaWJlIGZ1bmN0aW9uXG4gICAqL1xuICBzdWJzY3JpYmUobmFtZSwgYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhbm9uaWNhbGl6ZWRVZGZQYXRoID0gY2Fub25pY2FsaXplVWRmUGF0aChuYW1lKTtcbiAgICBjb25zdCB0b2tlbiA9IHNlcmlhbGl6ZVBhZ2luYXRlZFBhdGhBbmRBcmdzKFxuICAgICAgY2Fub25pY2FsaXplZFVkZlBhdGgsXG4gICAgICBhcmdzLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB0aGlzLnJlbW92ZVBhZ2luYXRlZFF1ZXJ5U3Vic2NyaWJlcih0b2tlbik7XG4gICAgY29uc3QgZXhpc3RpbmdFbnRyeSA9IHRoaXMucGFnaW5hdGVkUXVlcnlTZXQuZ2V0KHRva2VuKTtcbiAgICBpZiAoZXhpc3RpbmdFbnRyeSkge1xuICAgICAgZXhpc3RpbmdFbnRyeS5udW1TdWJzY3JpYmVycyArPSAxO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnaW5hdGVkUXVlcnlUb2tlbjogdG9rZW4sXG4gICAgICAgIHVuc3Vic2NyaWJlXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLnBhZ2luYXRlZFF1ZXJ5U2V0LnNldCh0b2tlbiwge1xuICAgICAgdG9rZW4sXG4gICAgICBjYW5vbmljYWxpemVkVWRmUGF0aCxcbiAgICAgIGFyZ3MsXG4gICAgICBudW1TdWJzY3JpYmVyczogMSxcbiAgICAgIG9wdGlvbnM6IHsgaW5pdGlhbE51bUl0ZW1zOiBvcHRpb25zLmluaXRpYWxOdW1JdGVtcyB9LFxuICAgICAgbmV4dFBhZ2VLZXk6IDAsXG4gICAgICBwYWdlS2V5czogW10sXG4gICAgICBwYWdlS2V5VG9RdWVyeTogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIG9uZ29pbmdTcGxpdHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBza2lwOiBmYWxzZSxcbiAgICAgIGlkOiBvcHRpb25zLmlkXG4gICAgfSk7XG4gICAgdGhpcy5hZGRQYWdlVG9QYWdpbmF0ZWRRdWVyeSh0b2tlbiwgbnVsbCwgb3B0aW9ucy5pbml0aWFsTnVtSXRlbXMpO1xuICAgIHJldHVybiB7XG4gICAgICBwYWdpbmF0ZWRRdWVyeVRva2VuOiB0b2tlbixcbiAgICAgIHVuc3Vic2NyaWJlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgcmVzdWx0cyBmb3IgYSBwYWdpbmF0ZWQgcXVlcnkgYmFzZWQgb24gbG9jYWwgc3RhdGUuXG4gICAqXG4gICAqIFRocm93cyBhbiBlcnJvciB3aGVuIG9uZSBvZiB0aGUgcGFnZXMgaGFzIGVycm9yZWQuXG4gICAqL1xuICBsb2NhbFF1ZXJ5UmVzdWx0KG5hbWUsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYW5vbmljYWxpemVkVWRmUGF0aCA9IGNhbm9uaWNhbGl6ZVVkZlBhdGgobmFtZSk7XG4gICAgY29uc3QgdG9rZW4gPSBzZXJpYWxpemVQYWdpbmF0ZWRQYXRoQW5kQXJncyhcbiAgICAgIGNhbm9uaWNhbGl6ZWRVZGZQYXRoLFxuICAgICAgYXJncyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHRva2VuKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBsb2NhbFF1ZXJ5UmVzdWx0QnlUb2tlbih0b2tlbikge1xuICAgIGNvbnN0IHBhZ2luYXRlZFF1ZXJ5ID0gdGhpcy5wYWdpbmF0ZWRRdWVyeVNldC5nZXQodG9rZW4pO1xuICAgIGlmICghcGFnaW5hdGVkUXVlcnkpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZVBhZ2VzID0gdGhpcy5hY3RpdmVQYWdlUXVlcnlUb2tlbnMocGFnaW5hdGVkUXVlcnkpO1xuICAgIGlmIChhY3RpdmVQYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdHM6IFtdLFxuICAgICAgICBzdGF0dXM6IFwiTG9hZGluZ0ZpcnN0UGFnZVwiLFxuICAgICAgICBsb2FkTW9yZTogKG51bUl0ZW1zKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZE1vcmVPZlBhZ2luYXRlZFF1ZXJ5KHRva2VuLCBudW1JdGVtcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBhbGxSZXN1bHRzID0gW107XG4gICAgbGV0IGhhc1VuZGVmaW5lZCA9IGZhbHNlO1xuICAgIGxldCBpc0RvbmUgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHBhZ2VUb2tlbiBvZiBhY3RpdmVQYWdlcykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jbGllbnQubG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4ocGFnZVRva2VuKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICBoYXNVbmRlZmluZWQgPSB0cnVlO1xuICAgICAgICBpc0RvbmUgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdpbmF0aW9uUmVzdWx0ID0gYXNQYWdpbmF0aW9uUmVzdWx0KHJlc3VsdCk7XG4gICAgICBhbGxSZXN1bHRzID0gYWxsUmVzdWx0cy5jb25jYXQocGFnaW5hdGlvblJlc3VsdC5wYWdlKTtcbiAgICAgIGlzRG9uZSA9ICEhcGFnaW5hdGlvblJlc3VsdC5pc0RvbmU7XG4gICAgfVxuICAgIGxldCBzdGF0dXM7XG4gICAgaWYgKGhhc1VuZGVmaW5lZCkge1xuICAgICAgc3RhdHVzID0gYWxsUmVzdWx0cy5sZW5ndGggPT09IDAgPyBcIkxvYWRpbmdGaXJzdFBhZ2VcIiA6IFwiTG9hZGluZ01vcmVcIjtcbiAgICB9IGVsc2UgaWYgKGlzRG9uZSkge1xuICAgICAgc3RhdHVzID0gXCJFeGhhdXN0ZWRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdHVzID0gXCJDYW5Mb2FkTW9yZVwiO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0czogYWxsUmVzdWx0cyxcbiAgICAgIHN0YXR1cyxcbiAgICAgIGxvYWRNb3JlOiAobnVtSXRlbXMpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZE1vcmVPZlBhZ2luYXRlZFF1ZXJ5KHRva2VuLCBudW1JdGVtcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBvbkJhc2VUcmFuc2l0aW9uKHRyYW5zaXRpb24pIHtcbiAgICBjb25zdCBjaGFuZ2VkQmFzZVRva2VucyA9IHRyYW5zaXRpb24ucXVlcmllcy5tYXAoKHEpID0+IHEudG9rZW4pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLnF1ZXJpZXNDb250YWluaW5nVG9rZW5zKGNoYW5nZWRCYXNlVG9rZW5zKTtcbiAgICBsZXQgcGFnaW5hdGVkUXVlcmllcyA9IFtdO1xuICAgIGlmIChjaGFuZ2VkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucHJvY2Vzc1BhZ2luYXRlZFF1ZXJ5U3BsaXRzKFxuICAgICAgICBjaGFuZ2VkLFxuICAgICAgICAodG9rZW4pID0+IHRoaXMuY2xpZW50LmxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHRva2VuKVxuICAgICAgKTtcbiAgICAgIHBhZ2luYXRlZFF1ZXJpZXMgPSBjaGFuZ2VkLm1hcCgodG9rZW4pID0+ICh7XG4gICAgICAgIHRva2VuLFxuICAgICAgICBtb2RpZmljYXRpb246IHtcbiAgICAgICAgICBraW5kOiBcIlVwZGF0ZWRcIixcbiAgICAgICAgICByZXN1bHQ6IHRoaXMubG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4odG9rZW4pXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5kZWRUcmFuc2l0aW9uID0ge1xuICAgICAgLi4udHJhbnNpdGlvbixcbiAgICAgIHBhZ2luYXRlZFF1ZXJpZXNcbiAgICB9O1xuICAgIHRoaXMub25UcmFuc2l0aW9uKGV4dGVuZGVkVHJhbnNpdGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIExvYWQgbW9yZSBpdGVtcyBmb3IgYSBwYWdpbmF0ZWQgcXVlcnkuXG4gICAqXG4gICAqIFRoaXMgKmFsd2F5cyogY2F1c2VzIGEgdHJhbnNpdGlvbiwgdGhlIHN0YXR1cyBvZiB0aGUgcXVlcnlcbiAgICogaGFzIHByb2JhYmx5IGNoYW5nZWQgZnJvbSBcIkNhbkxvYWRNb3JlXCIgdG8gXCJMb2FkaW5nTW9yZVwiLlxuICAgKiBEYXRhIG1pZ2h0IGhhdmUgY2hhbmdlZCB0b286IG1heWJlIGEgc3Vic2NyaXB0aW9uIHRvIHRoaXMgcGFnZVxuICAgKiBxdWVyeSBhbHJlYWR5IGV4aXN0cyAodW5saWtlbHkgYnV0IHBvc3NpYmxlKSBvciB0aGlzIHBhZ2UgcXVlcnlcbiAgICogaGFzIGFuIG9wdGltaXN0aWMgdXBkYXRlIHByb3ZpZGluZyBzb21lIGluaXRpYWwgZGF0YS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBsb2FkTW9yZU9mUGFnaW5hdGVkUXVlcnkodG9rZW4sIG51bUl0ZW1zKSB7XG4gICAgdGhpcy5tdXN0R2V0UGFnaW5hdGVkUXVlcnkodG9rZW4pO1xuICAgIGNvbnN0IGxhc3RQYWdlVG9rZW4gPSB0aGlzLnF1ZXJ5VG9rZW5Gb3JMYXN0UGFnZU9mUGFnaW5hdGVkUXVlcnkodG9rZW4pO1xuICAgIGNvbnN0IGxhc3RQYWdlUmVzdWx0ID0gdGhpcy5jbGllbnQubG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4obGFzdFBhZ2VUb2tlbik7XG4gICAgaWYgKCFsYXN0UGFnZVJlc3VsdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwYWdpbmF0aW9uUmVzdWx0ID0gYXNQYWdpbmF0aW9uUmVzdWx0KGxhc3RQYWdlUmVzdWx0KTtcbiAgICBpZiAocGFnaW5hdGlvblJlc3VsdC5pc0RvbmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5hZGRQYWdlVG9QYWdpbmF0ZWRRdWVyeShcbiAgICAgIHRva2VuLFxuICAgICAgcGFnaW5hdGlvblJlc3VsdC5jb250aW51ZUN1cnNvcixcbiAgICAgIG51bUl0ZW1zXG4gICAgKTtcbiAgICBjb25zdCBsb2FkTW9yZVRyYW5zaXRpb24gPSB7XG4gICAgICB0aW1lc3RhbXA6IHRoaXMubGFzdFRyYW5zaXRpb25UcyxcbiAgICAgIHJlZmxlY3RlZE11dGF0aW9uczogW10sXG4gICAgICBxdWVyaWVzOiBbXSxcbiAgICAgIHBhZ2luYXRlZFF1ZXJpZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHRva2VuLFxuICAgICAgICAgIG1vZGlmaWNhdGlvbjoge1xuICAgICAgICAgICAga2luZDogXCJVcGRhdGVkXCIsXG4gICAgICAgICAgICByZXN1bHQ6IHRoaXMubG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4odG9rZW4pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgICB0aGlzLm9uVHJhbnNpdGlvbihsb2FkTW9yZVRyYW5zaXRpb24pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHF1ZXJpZXNDb250YWluaW5nVG9rZW5zKHF1ZXJ5VG9rZW5zKSB7XG4gICAgaWYgKHF1ZXJ5VG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VkID0gW107XG4gICAgY29uc3QgcXVlcnlUb2tlblNldCA9IG5ldyBTZXQocXVlcnlUb2tlbnMpO1xuICAgIGZvciAoY29uc3QgW3BhZ2luYXRlZFRva2VuLCBwYWdpbmF0ZWRRdWVyeV0gb2YgdGhpcy5wYWdpbmF0ZWRRdWVyeVNldCkge1xuICAgICAgZm9yIChjb25zdCBwYWdlVG9rZW4gb2YgdGhpcy5hbGxRdWVyeVRva2VucyhwYWdpbmF0ZWRRdWVyeSkpIHtcbiAgICAgICAgaWYgKHF1ZXJ5VG9rZW5TZXQuaGFzKHBhZ2VUb2tlbikpIHtcbiAgICAgICAgICBjaGFuZ2VkLnB1c2gocGFnaW5hdGVkVG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb2Nlc3NQYWdpbmF0ZWRRdWVyeVNwbGl0cyhjaGFuZ2VkLCBnZXRSZXN1bHQpIHtcbiAgICBmb3IgKGNvbnN0IHBhZ2luYXRlZFF1ZXJ5VG9rZW4gb2YgY2hhbmdlZCkge1xuICAgICAgY29uc3QgcGFnaW5hdGVkUXVlcnkgPSB0aGlzLm11c3RHZXRQYWdpbmF0ZWRRdWVyeShwYWdpbmF0ZWRRdWVyeVRva2VuKTtcbiAgICAgIGNvbnN0IHsgb25nb2luZ1NwbGl0cywgcGFnZUtleVRvUXVlcnksIHBhZ2VLZXlzIH0gPSBwYWdpbmF0ZWRRdWVyeTtcbiAgICAgIGZvciAoY29uc3QgW3BhZ2VLZXksIFtzcGxpdEtleTEsIHNwbGl0S2V5Ml1dIG9mIG9uZ29pbmdTcGxpdHMpIHtcbiAgICAgICAgY29uc3QgYm90aE5ld1BhZ2VzTG9hZGVkID0gZ2V0UmVzdWx0KHBhZ2VLZXlUb1F1ZXJ5LmdldChzcGxpdEtleTEpLnF1ZXJ5VG9rZW4pICE9PSB2b2lkIDAgJiYgZ2V0UmVzdWx0KHBhZ2VLZXlUb1F1ZXJ5LmdldChzcGxpdEtleTIpLnF1ZXJ5VG9rZW4pICE9PSB2b2lkIDA7XG4gICAgICAgIGlmIChib3RoTmV3UGFnZXNMb2FkZWQpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlUGFnaW5hdGVkUXVlcnlTcGxpdChcbiAgICAgICAgICAgIHBhZ2luYXRlZFF1ZXJ5LFxuICAgICAgICAgICAgcGFnZUtleSxcbiAgICAgICAgICAgIHNwbGl0S2V5MSxcbiAgICAgICAgICAgIHNwbGl0S2V5MlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgcGFnZUtleSBvZiBwYWdlS2V5cykge1xuICAgICAgICBpZiAob25nb2luZ1NwbGl0cy5oYXMocGFnZUtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWdlVG9rZW4gPSBwYWdlS2V5VG9RdWVyeS5nZXQocGFnZUtleSkucXVlcnlUb2tlbjtcbiAgICAgICAgY29uc3QgcGFnZVJlc3VsdCA9IGdldFJlc3VsdChwYWdlVG9rZW4pO1xuICAgICAgICBpZiAoIXBhZ2VSZXN1bHQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhc1BhZ2luYXRpb25SZXN1bHQocGFnZVJlc3VsdCk7XG4gICAgICAgIGNvbnN0IHNob3VsZFNwbGl0ID0gcmVzdWx0LnNwbGl0Q3Vyc29yICYmIChyZXN1bHQucGFnZVN0YXR1cyA9PT0gXCJTcGxpdFJlY29tbWVuZGVkXCIgfHwgcmVzdWx0LnBhZ2VTdGF0dXMgPT09IFwiU3BsaXRSZXF1aXJlZFwiIHx8IC8vIFRoaXMgY2xpZW50LWRyaXZlbiBwYWdlIHNwbGl0dGluZyBjb25kaXRpb24gd2lsbCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgcmVzdWx0LnBhZ2UubGVuZ3RoID4gcGFnaW5hdGVkUXVlcnkub3B0aW9ucy5pbml0aWFsTnVtSXRlbXMgKiAyKTtcbiAgICAgICAgaWYgKHNob3VsZFNwbGl0KSB7XG4gICAgICAgICAgdGhpcy5zcGxpdFBhZ2luYXRlZFF1ZXJ5UGFnZShcbiAgICAgICAgICAgIHBhZ2luYXRlZFF1ZXJ5LFxuICAgICAgICAgICAgcGFnZUtleSxcbiAgICAgICAgICAgIHJlc3VsdC5zcGxpdEN1cnNvcixcbiAgICAgICAgICAgIC8vIHdlIGp1c3QgY2hlY2tlZFxuICAgICAgICAgICAgcmVzdWx0LmNvbnRpbnVlQ3Vyc29yXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzcGxpdFBhZ2luYXRlZFF1ZXJ5UGFnZShwYWdpbmF0ZWRRdWVyeSwgcGFnZUtleSwgc3BsaXRDdXJzb3IsIGNvbnRpbnVlQ3Vyc29yKSB7XG4gICAgY29uc3Qgc3BsaXRLZXkxID0gcGFnaW5hdGVkUXVlcnkubmV4dFBhZ2VLZXkrKztcbiAgICBjb25zdCBzcGxpdEtleTIgPSBwYWdpbmF0ZWRRdWVyeS5uZXh0UGFnZUtleSsrO1xuICAgIGNvbnN0IHBhZ2luYXRpb25PcHRzID0ge1xuICAgICAgY3Vyc29yOiBjb250aW51ZUN1cnNvcixcbiAgICAgIG51bUl0ZW1zOiBwYWdpbmF0ZWRRdWVyeS5vcHRpb25zLmluaXRpYWxOdW1JdGVtcyxcbiAgICAgIGlkOiBwYWdpbmF0ZWRRdWVyeS5pZFxuICAgIH07XG4gICAgY29uc3QgZmlyc3RTdWJzY3JpcHRpb24gPSB0aGlzLmNsaWVudC5zdWJzY3JpYmUoXG4gICAgICBwYWdpbmF0ZWRRdWVyeS5jYW5vbmljYWxpemVkVWRmUGF0aCxcbiAgICAgIHtcbiAgICAgICAgLi4ucGFnaW5hdGVkUXVlcnkuYXJncyxcbiAgICAgICAgcGFnaW5hdGlvbk9wdHM6IHtcbiAgICAgICAgICAuLi5wYWdpbmF0aW9uT3B0cyxcbiAgICAgICAgICBjdXJzb3I6IG51bGwsXG4gICAgICAgICAgLy8gU3RhcnQgZnJvbSBiZWdpbm5pbmcgZm9yIGZpcnN0IHNwbGl0XG4gICAgICAgICAgZW5kQ3Vyc29yOiBzcGxpdEN1cnNvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBwYWdpbmF0ZWRRdWVyeS5wYWdlS2V5VG9RdWVyeS5zZXQoc3BsaXRLZXkxLCBmaXJzdFN1YnNjcmlwdGlvbik7XG4gICAgY29uc3Qgc2Vjb25kU3Vic2NyaXB0aW9uID0gdGhpcy5jbGllbnQuc3Vic2NyaWJlKFxuICAgICAgcGFnaW5hdGVkUXVlcnkuY2Fub25pY2FsaXplZFVkZlBhdGgsXG4gICAgICB7XG4gICAgICAgIC4uLnBhZ2luYXRlZFF1ZXJ5LmFyZ3MsXG4gICAgICAgIHBhZ2luYXRpb25PcHRzOiB7XG4gICAgICAgICAgLi4ucGFnaW5hdGlvbk9wdHMsXG4gICAgICAgICAgY3Vyc29yOiBzcGxpdEN1cnNvcixcbiAgICAgICAgICBlbmRDdXJzb3I6IGNvbnRpbnVlQ3Vyc29yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIHBhZ2luYXRlZFF1ZXJ5LnBhZ2VLZXlUb1F1ZXJ5LnNldChzcGxpdEtleTIsIHNlY29uZFN1YnNjcmlwdGlvbik7XG4gICAgcGFnaW5hdGVkUXVlcnkub25nb2luZ1NwbGl0cy5zZXQocGFnZUtleSwgW3NwbGl0S2V5MSwgc3BsaXRLZXkyXSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYWRkUGFnZVRvUGFnaW5hdGVkUXVlcnkodG9rZW4sIGNvbnRpbnVlQ3Vyc29yLCBudW1JdGVtcykge1xuICAgIGNvbnN0IHBhZ2luYXRlZFF1ZXJ5ID0gdGhpcy5tdXN0R2V0UGFnaW5hdGVkUXVlcnkodG9rZW4pO1xuICAgIGNvbnN0IHBhZ2VLZXkgPSBwYWdpbmF0ZWRRdWVyeS5uZXh0UGFnZUtleSsrO1xuICAgIGNvbnN0IHBhZ2luYXRpb25PcHRzID0ge1xuICAgICAgY3Vyc29yOiBjb250aW51ZUN1cnNvcixcbiAgICAgIG51bUl0ZW1zLFxuICAgICAgaWQ6IHBhZ2luYXRlZFF1ZXJ5LmlkXG4gICAgfTtcbiAgICBjb25zdCBwYWdlQXJncyA9IHtcbiAgICAgIC4uLnBhZ2luYXRlZFF1ZXJ5LmFyZ3MsXG4gICAgICBwYWdpbmF0aW9uT3B0c1xuICAgIH07XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5jbGllbnQuc3Vic2NyaWJlKFxuICAgICAgcGFnaW5hdGVkUXVlcnkuY2Fub25pY2FsaXplZFVkZlBhdGgsXG4gICAgICBwYWdlQXJnc1xuICAgICk7XG4gICAgcGFnaW5hdGVkUXVlcnkucGFnZUtleXMucHVzaChwYWdlS2V5KTtcbiAgICBwYWdpbmF0ZWRRdWVyeS5wYWdlS2V5VG9RdWVyeS5zZXQocGFnZUtleSwgc3Vic2NyaXB0aW9uKTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICB9XG4gIHJlbW92ZVBhZ2luYXRlZFF1ZXJ5U3Vic2NyaWJlcih0b2tlbikge1xuICAgIGNvbnN0IHBhZ2luYXRlZFF1ZXJ5ID0gdGhpcy5wYWdpbmF0ZWRRdWVyeVNldC5nZXQodG9rZW4pO1xuICAgIGlmICghcGFnaW5hdGVkUXVlcnkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGFnaW5hdGVkUXVlcnkubnVtU3Vic2NyaWJlcnMgLT0gMTtcbiAgICBpZiAocGFnaW5hdGVkUXVlcnkubnVtU3Vic2NyaWJlcnMgPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3Vic2NyaXB0aW9uIG9mIHBhZ2luYXRlZFF1ZXJ5LnBhZ2VLZXlUb1F1ZXJ5LnZhbHVlcygpKSB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgdGhpcy5wYWdpbmF0ZWRRdWVyeVNldC5kZWxldGUodG9rZW4pO1xuICB9XG4gIGNvbXBsZXRlUGFnaW5hdGVkUXVlcnlTcGxpdChwYWdpbmF0ZWRRdWVyeSwgcGFnZUtleSwgc3BsaXRLZXkxLCBzcGxpdEtleTIpIHtcbiAgICBjb25zdCBvcmlnaW5hbFF1ZXJ5ID0gcGFnaW5hdGVkUXVlcnkucGFnZUtleVRvUXVlcnkuZ2V0KHBhZ2VLZXkpO1xuICAgIHBhZ2luYXRlZFF1ZXJ5LnBhZ2VLZXlUb1F1ZXJ5LmRlbGV0ZShwYWdlS2V5KTtcbiAgICBjb25zdCBwYWdlSW5kZXggPSBwYWdpbmF0ZWRRdWVyeS5wYWdlS2V5cy5pbmRleE9mKHBhZ2VLZXkpO1xuICAgIHBhZ2luYXRlZFF1ZXJ5LnBhZ2VLZXlzLnNwbGljZShwYWdlSW5kZXgsIDEsIHNwbGl0S2V5MSwgc3BsaXRLZXkyKTtcbiAgICBwYWdpbmF0ZWRRdWVyeS5vbmdvaW5nU3BsaXRzLmRlbGV0ZShwYWdlS2V5KTtcbiAgICBvcmlnaW5hbFF1ZXJ5LnVuc3Vic2NyaWJlKCk7XG4gIH1cbiAgLyoqIFRoZSBxdWVyeSB0b2tlbnMgZm9yIGFsbCBhY3RpdmUgcGFnZXMsIGluIHJlc3VsdCBvcmRlciAqL1xuICBhY3RpdmVQYWdlUXVlcnlUb2tlbnMocGFnaW5hdGVkUXVlcnkpIHtcbiAgICByZXR1cm4gcGFnaW5hdGVkUXVlcnkucGFnZUtleXMubWFwKFxuICAgICAgKHBhZ2VLZXkpID0+IHBhZ2luYXRlZFF1ZXJ5LnBhZ2VLZXlUb1F1ZXJ5LmdldChwYWdlS2V5KS5xdWVyeVRva2VuXG4gICAgKTtcbiAgfVxuICBhbGxRdWVyeVRva2VucyhwYWdpbmF0ZWRRdWVyeSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHBhZ2luYXRlZFF1ZXJ5LnBhZ2VLZXlUb1F1ZXJ5LnZhbHVlcygpKS5tYXAoXG4gICAgICAoc3ViKSA9PiBzdWIucXVlcnlUb2tlblxuICAgICk7XG4gIH1cbiAgcXVlcnlUb2tlbkZvckxhc3RQYWdlT2ZQYWdpbmF0ZWRRdWVyeSh0b2tlbikge1xuICAgIGNvbnN0IHBhZ2luYXRlZFF1ZXJ5ID0gdGhpcy5tdXN0R2V0UGFnaW5hdGVkUXVlcnkodG9rZW4pO1xuICAgIGNvbnN0IGxhc3RQYWdlS2V5ID0gcGFnaW5hdGVkUXVlcnkucGFnZUtleXNbcGFnaW5hdGVkUXVlcnkucGFnZUtleXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RQYWdlS2V5ID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcGFnZXMgZm9yIHBhZ2luYXRlZCBxdWVyeSAke3Rva2VufWApO1xuICAgIH1cbiAgICByZXR1cm4gcGFnaW5hdGVkUXVlcnkucGFnZUtleVRvUXVlcnkuZ2V0KGxhc3RQYWdlS2V5KS5xdWVyeVRva2VuO1xuICB9XG4gIG11c3RHZXRQYWdpbmF0ZWRRdWVyeSh0b2tlbikge1xuICAgIGNvbnN0IHBhZ2luYXRlZFF1ZXJ5ID0gdGhpcy5wYWdpbmF0ZWRRdWVyeVNldC5nZXQodG9rZW4pO1xuICAgIGlmICghcGFnaW5hdGVkUXVlcnkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInBhZ2luYXRlZCBxdWVyeSBubyBsb25nZXIgZXhpc3RzIGZvciB0b2tlbiBcIiArIHRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZ2luYXRlZFF1ZXJ5O1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdpbmF0ZWRfcXVlcnlfY2xpZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19kZWZOb3JtYWxQcm9wIiwib2JqIiwia2V5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX3B1YmxpY0ZpZWxkIiwic2VyaWFsaXplUGFnaW5hdGVkUGF0aEFuZEFyZ3MiLCJjYW5vbmljYWxpemVVZGZQYXRoIiwiYXNQYWdpbmF0aW9uUmVzdWx0IiwiTG9uZyIsIlBhZ2luYXRlZFF1ZXJ5Q2xpZW50Iiwic3Vic2NyaWJlIiwibmFtZSIsImFyZ3MiLCJvcHRpb25zIiwiY2Fub25pY2FsaXplZFVkZlBhdGgiLCJ0b2tlbiIsInVuc3Vic2NyaWJlIiwicmVtb3ZlUGFnaW5hdGVkUXVlcnlTdWJzY3JpYmVyIiwiZXhpc3RpbmdFbnRyeSIsInBhZ2luYXRlZFF1ZXJ5U2V0IiwiZ2V0IiwibnVtU3Vic2NyaWJlcnMiLCJwYWdpbmF0ZWRRdWVyeVRva2VuIiwic2V0IiwiaW5pdGlhbE51bUl0ZW1zIiwibmV4dFBhZ2VLZXkiLCJwYWdlS2V5cyIsInBhZ2VLZXlUb1F1ZXJ5IiwiTWFwIiwib25nb2luZ1NwbGl0cyIsInNraXAiLCJpZCIsImFkZFBhZ2VUb1BhZ2luYXRlZFF1ZXJ5IiwibG9jYWxRdWVyeVJlc3VsdCIsImxvY2FsUXVlcnlSZXN1bHRCeVRva2VuIiwicGFnaW5hdGVkUXVlcnkiLCJhY3RpdmVQYWdlcyIsImFjdGl2ZVBhZ2VRdWVyeVRva2VucyIsImxlbmd0aCIsInJlc3VsdHMiLCJzdGF0dXMiLCJsb2FkTW9yZSIsIm51bUl0ZW1zIiwibG9hZE1vcmVPZlBhZ2luYXRlZFF1ZXJ5IiwiYWxsUmVzdWx0cyIsImhhc1VuZGVmaW5lZCIsImlzRG9uZSIsInBhZ2VUb2tlbiIsInJlc3VsdCIsImNsaWVudCIsInBhZ2luYXRpb25SZXN1bHQiLCJjb25jYXQiLCJwYWdlIiwib25CYXNlVHJhbnNpdGlvbiIsInRyYW5zaXRpb24iLCJjaGFuZ2VkQmFzZVRva2VucyIsInF1ZXJpZXMiLCJtYXAiLCJxIiwiY2hhbmdlZCIsInF1ZXJpZXNDb250YWluaW5nVG9rZW5zIiwicGFnaW5hdGVkUXVlcmllcyIsInByb2Nlc3NQYWdpbmF0ZWRRdWVyeVNwbGl0cyIsIm1vZGlmaWNhdGlvbiIsImtpbmQiLCJleHRlbmRlZFRyYW5zaXRpb24iLCJvblRyYW5zaXRpb24iLCJtdXN0R2V0UGFnaW5hdGVkUXVlcnkiLCJsYXN0UGFnZVRva2VuIiwicXVlcnlUb2tlbkZvckxhc3RQYWdlT2ZQYWdpbmF0ZWRRdWVyeSIsImxhc3RQYWdlUmVzdWx0IiwiY29udGludWVDdXJzb3IiLCJsb2FkTW9yZVRyYW5zaXRpb24iLCJ0aW1lc3RhbXAiLCJsYXN0VHJhbnNpdGlvblRzIiwicmVmbGVjdGVkTXV0YXRpb25zIiwicXVlcnlUb2tlbnMiLCJxdWVyeVRva2VuU2V0IiwiU2V0IiwicGFnaW5hdGVkVG9rZW4iLCJhbGxRdWVyeVRva2VucyIsImhhcyIsInB1c2giLCJnZXRSZXN1bHQiLCJwYWdlS2V5Iiwic3BsaXRLZXkxIiwic3BsaXRLZXkyIiwiYm90aE5ld1BhZ2VzTG9hZGVkIiwicXVlcnlUb2tlbiIsImNvbXBsZXRlUGFnaW5hdGVkUXVlcnlTcGxpdCIsInBhZ2VSZXN1bHQiLCJzaG91bGRTcGxpdCIsInNwbGl0Q3Vyc29yIiwicGFnZVN0YXR1cyIsInNwbGl0UGFnaW5hdGVkUXVlcnlQYWdlIiwicGFnaW5hdGlvbk9wdHMiLCJjdXJzb3IiLCJmaXJzdFN1YnNjcmlwdGlvbiIsImVuZEN1cnNvciIsInNlY29uZFN1YnNjcmlwdGlvbiIsInBhZ2VBcmdzIiwic3Vic2NyaXB0aW9uIiwidmFsdWVzIiwiZGVsZXRlIiwib3JpZ2luYWxRdWVyeSIsInBhZ2VJbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJBcnJheSIsImZyb20iLCJzdWIiLCJsYXN0UGFnZUtleSIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJmcm9tTnVtYmVyIiwiYWRkT25UcmFuc2l0aW9uSGFuZGxlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/paginated_query_client.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/pagination.js":
/*!*****************************************************************!*\
  !*** ./node_modules/convex/dist/esm/browser/sync/pagination.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asPaginationArgs: function() { return /* binding */ asPaginationArgs; },\n/* harmony export */   asPaginationResult: function() { return /* binding */ asPaginationResult; }\n/* harmony export */ });\n\nfunction asPaginationArgs(value) {\n    if (typeof value.paginationOpts.numItems !== \"number\") {\n        throw new Error(\"Not valid paginated query args: \".concat(JSON.stringify(value)));\n    }\n    return value;\n}\nfunction asPaginationResult(value) {\n    if (typeof value !== \"object\" || value === null || !Array.isArray(value.page) || typeof value.isDone !== \"boolean\" || typeof value.continueCursor !== \"string\") {\n        throw new Error(\"Not a valid paginated query result: \".concat(value === null || value === void 0 ? void 0 : value.toString()));\n    }\n    return value;\n} //# sourceMappingURL=pagination.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL3BhZ2luYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBYTtBQUNOLFNBQVNBLGlCQUFpQkMsS0FBSztJQUNwQyxJQUFJLE9BQU9BLE1BQU1DLGNBQWMsQ0FBQ0MsUUFBUSxLQUFLLFVBQVU7UUFDckQsTUFBTSxJQUFJQyxNQUFNLG1DQUF5RCxPQUF0QkMsS0FBS0MsU0FBUyxDQUFDTDtJQUNwRTtJQUNBLE9BQU9BO0FBQ1Q7QUFDTyxTQUFTTSxtQkFBbUJOLEtBQUs7SUFDdEMsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsUUFBUSxDQUFDTyxNQUFNQyxPQUFPLENBQUNSLE1BQU1TLElBQUksS0FBSyxPQUFPVCxNQUFNVSxNQUFNLEtBQUssYUFBYSxPQUFPVixNQUFNVyxjQUFjLEtBQUssVUFBVTtRQUM5SixNQUFNLElBQUlSLE1BQU0sdUNBQXlELE9BQWxCSCxrQkFBQUEsNEJBQUFBLE1BQU9ZLFFBQVE7SUFDeEU7SUFDQSxPQUFPWjtBQUNULEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL3BhZ2luYXRpb24uanM/NThlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydCBmdW5jdGlvbiBhc1BhZ2luYXRpb25BcmdzKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUucGFnaW5hdGlvbk9wdHMubnVtSXRlbXMgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCB2YWxpZCBwYWdpbmF0ZWQgcXVlcnkgYXJnczogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzUGFnaW5hdGlvblJlc3VsdCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KHZhbHVlLnBhZ2UpIHx8IHR5cGVvZiB2YWx1ZS5pc0RvbmUgIT09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiB2YWx1ZS5jb250aW51ZUN1cnNvciAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgdmFsaWQgcGFnaW5hdGVkIHF1ZXJ5IHJlc3VsdDogJHt2YWx1ZT8udG9TdHJpbmcoKX1gKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdpbmF0aW9uLmpzLm1hcFxuIl0sIm5hbWVzIjpbImFzUGFnaW5hdGlvbkFyZ3MiLCJ2YWx1ZSIsInBhZ2luYXRpb25PcHRzIiwibnVtSXRlbXMiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJhc1BhZ2luYXRpb25SZXN1bHQiLCJBcnJheSIsImlzQXJyYXkiLCJwYWdlIiwiaXNEb25lIiwiY29udGludWVDdXJzb3IiLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/pagination.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/protocol.js":
/*!***************************************************************!*\
  !*** ./node_modules/convex/dist/esm/browser/sync/protocol.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeClientMessage: function() { return /* binding */ encodeClientMessage; },\n/* harmony export */   longToU64: function() { return /* binding */ longToU64; },\n/* harmony export */   parseServerMessage: function() { return /* binding */ parseServerMessage; },\n/* harmony export */   u64ToLong: function() { return /* binding */ u64ToLong; }\n/* harmony export */ });\n/* harmony import */ var _values_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/index.js\");\n/* harmony import */ var _vendor_long_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../vendor/long.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/vendor/long.js\");\n\n\n\nfunction u64ToLong(encoded) {\n    const integerBytes = _values_index_js__WEBPACK_IMPORTED_MODULE_0__.Base64.toByteArray(encoded);\n    return _vendor_long_js__WEBPACK_IMPORTED_MODULE_1__.Long.fromBytesLE(Array.from(integerBytes));\n}\nfunction longToU64(raw) {\n    const integerBytes = new Uint8Array(raw.toBytesLE());\n    return _values_index_js__WEBPACK_IMPORTED_MODULE_0__.Base64.fromByteArray(integerBytes);\n}\nfunction parseServerMessage(encoded) {\n    switch(encoded.type){\n        case \"FatalError\":\n        case \"AuthError\":\n        case \"ActionResponse\":\n        case \"TransitionChunk\":\n        case \"Ping\":\n            {\n                return {\n                    ...encoded\n                };\n            }\n        case \"MutationResponse\":\n            {\n                if (encoded.success) {\n                    return {\n                        ...encoded,\n                        ts: u64ToLong(encoded.ts)\n                    };\n                } else {\n                    return {\n                        ...encoded\n                    };\n                }\n            }\n        case \"Transition\":\n            {\n                return {\n                    ...encoded,\n                    startVersion: {\n                        ...encoded.startVersion,\n                        ts: u64ToLong(encoded.startVersion.ts)\n                    },\n                    endVersion: {\n                        ...encoded.endVersion,\n                        ts: u64ToLong(encoded.endVersion.ts)\n                    }\n                };\n            }\n        default:\n            {\n                encoded;\n            }\n    }\n    return void 0;\n}\nfunction encodeClientMessage(message) {\n    switch(message.type){\n        case \"Authenticate\":\n        case \"ModifyQuerySet\":\n        case \"Mutation\":\n        case \"Action\":\n        case \"Event\":\n            {\n                return {\n                    ...message\n                };\n            }\n        case \"Connect\":\n            {\n                if (message.maxObservedTimestamp !== void 0) {\n                    return {\n                        ...message,\n                        maxObservedTimestamp: longToU64(message.maxObservedTimestamp)\n                    };\n                } else {\n                    return {\n                        ...message,\n                        maxObservedTimestamp: void 0\n                    };\n                }\n            }\n        default:\n            {\n                message;\n            }\n    }\n    return void 0;\n} //# sourceMappingURL=protocol.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL3Byb3RvY29sLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFhO0FBQ2tDO0FBQ0g7QUFDckMsU0FBU0UsVUFBVUMsT0FBTztJQUMvQixNQUFNQyxlQUFlSixnRUFBa0IsQ0FBQ0c7SUFDeEMsT0FBT0YsaURBQUlBLENBQUNLLFdBQVcsQ0FBQ0MsTUFBTUMsSUFBSSxDQUFDSjtBQUNyQztBQUNPLFNBQVNLLFVBQVVDLEdBQUc7SUFDM0IsTUFBTU4sZUFBZSxJQUFJTyxXQUFXRCxJQUFJRSxTQUFTO0lBQ2pELE9BQU9aLGtFQUFvQixDQUFDSTtBQUM5QjtBQUNPLFNBQVNVLG1CQUFtQlgsT0FBTztJQUN4QyxPQUFRQSxRQUFRWSxJQUFJO1FBQ2xCLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQVE7Z0JBQ1gsT0FBTztvQkFBRSxHQUFHWixPQUFPO2dCQUFDO1lBQ3RCO1FBQ0EsS0FBSztZQUFvQjtnQkFDdkIsSUFBSUEsUUFBUWEsT0FBTyxFQUFFO29CQUNuQixPQUFPO3dCQUFFLEdBQUdiLE9BQU87d0JBQUVjLElBQUlmLFVBQVVDLFFBQVFjLEVBQUU7b0JBQUU7Z0JBQ2pELE9BQU87b0JBQ0wsT0FBTzt3QkFBRSxHQUFHZCxPQUFPO29CQUFDO2dCQUN0QjtZQUNGO1FBQ0EsS0FBSztZQUFjO2dCQUNqQixPQUFPO29CQUNMLEdBQUdBLE9BQU87b0JBQ1ZlLGNBQWM7d0JBQ1osR0FBR2YsUUFBUWUsWUFBWTt3QkFDdkJELElBQUlmLFVBQVVDLFFBQVFlLFlBQVksQ0FBQ0QsRUFBRTtvQkFDdkM7b0JBQ0FFLFlBQVk7d0JBQ1YsR0FBR2hCLFFBQVFnQixVQUFVO3dCQUNyQkYsSUFBSWYsVUFBVUMsUUFBUWdCLFVBQVUsQ0FBQ0YsRUFBRTtvQkFDckM7Z0JBQ0Y7WUFDRjtRQUNBO1lBQVM7Z0JBQ1BkO1lBQ0Y7SUFDRjtJQUNBLE9BQU8sS0FBSztBQUNkO0FBQ08sU0FBU2lCLG9CQUFvQkMsT0FBTztJQUN6QyxPQUFRQSxRQUFRTixJQUFJO1FBQ2xCLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQVM7Z0JBQ1osT0FBTztvQkFBRSxHQUFHTSxPQUFPO2dCQUFDO1lBQ3RCO1FBQ0EsS0FBSztZQUFXO2dCQUNkLElBQUlBLFFBQVFDLG9CQUFvQixLQUFLLEtBQUssR0FBRztvQkFDM0MsT0FBTzt3QkFDTCxHQUFHRCxPQUFPO3dCQUNWQyxzQkFBc0JiLFVBQVVZLFFBQVFDLG9CQUFvQjtvQkFDOUQ7Z0JBQ0YsT0FBTztvQkFDTCxPQUFPO3dCQUFFLEdBQUdELE9BQU87d0JBQUVDLHNCQUFzQixLQUFLO29CQUFFO2dCQUNwRDtZQUNGO1FBQ0E7WUFBUztnQkFDUEQ7WUFDRjtJQUNGO0lBQ0EsT0FBTyxLQUFLO0FBQ2QsRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9icm93c2VyL3N5bmMvcHJvdG9jb2wuanM/MjUyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IEJhc2U2NCB9IGZyb20gXCIuLi8uLi92YWx1ZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IExvbmcgfSBmcm9tIFwiLi4vLi4vdmVuZG9yL2xvbmcuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB1NjRUb0xvbmcoZW5jb2RlZCkge1xuICBjb25zdCBpbnRlZ2VyQnl0ZXMgPSBCYXNlNjQudG9CeXRlQXJyYXkoZW5jb2RlZCk7XG4gIHJldHVybiBMb25nLmZyb21CeXRlc0xFKEFycmF5LmZyb20oaW50ZWdlckJ5dGVzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbG9uZ1RvVTY0KHJhdykge1xuICBjb25zdCBpbnRlZ2VyQnl0ZXMgPSBuZXcgVWludDhBcnJheShyYXcudG9CeXRlc0xFKCkpO1xuICByZXR1cm4gQmFzZTY0LmZyb21CeXRlQXJyYXkoaW50ZWdlckJ5dGVzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNlcnZlck1lc3NhZ2UoZW5jb2RlZCkge1xuICBzd2l0Y2ggKGVuY29kZWQudHlwZSkge1xuICAgIGNhc2UgXCJGYXRhbEVycm9yXCI6XG4gICAgY2FzZSBcIkF1dGhFcnJvclwiOlxuICAgIGNhc2UgXCJBY3Rpb25SZXNwb25zZVwiOlxuICAgIGNhc2UgXCJUcmFuc2l0aW9uQ2h1bmtcIjpcbiAgICBjYXNlIFwiUGluZ1wiOiB7XG4gICAgICByZXR1cm4geyAuLi5lbmNvZGVkIH07XG4gICAgfVxuICAgIGNhc2UgXCJNdXRhdGlvblJlc3BvbnNlXCI6IHtcbiAgICAgIGlmIChlbmNvZGVkLnN1Y2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4uZW5jb2RlZCwgdHM6IHU2NFRvTG9uZyhlbmNvZGVkLnRzKSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgLi4uZW5jb2RlZCB9O1xuICAgICAgfVxuICAgIH1cbiAgICBjYXNlIFwiVHJhbnNpdGlvblwiOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5lbmNvZGVkLFxuICAgICAgICBzdGFydFZlcnNpb246IHtcbiAgICAgICAgICAuLi5lbmNvZGVkLnN0YXJ0VmVyc2lvbixcbiAgICAgICAgICB0czogdTY0VG9Mb25nKGVuY29kZWQuc3RhcnRWZXJzaW9uLnRzKVxuICAgICAgICB9LFxuICAgICAgICBlbmRWZXJzaW9uOiB7XG4gICAgICAgICAgLi4uZW5jb2RlZC5lbmRWZXJzaW9uLFxuICAgICAgICAgIHRzOiB1NjRUb0xvbmcoZW5jb2RlZC5lbmRWZXJzaW9uLnRzKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBlbmNvZGVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUNsaWVudE1lc3NhZ2UobWVzc2FnZSkge1xuICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgIGNhc2UgXCJBdXRoZW50aWNhdGVcIjpcbiAgICBjYXNlIFwiTW9kaWZ5UXVlcnlTZXRcIjpcbiAgICBjYXNlIFwiTXV0YXRpb25cIjpcbiAgICBjYXNlIFwiQWN0aW9uXCI6XG4gICAgY2FzZSBcIkV2ZW50XCI6IHtcbiAgICAgIHJldHVybiB7IC4uLm1lc3NhZ2UgfTtcbiAgICB9XG4gICAgY2FzZSBcIkNvbm5lY3RcIjoge1xuICAgICAgaWYgKG1lc3NhZ2UubWF4T2JzZXJ2ZWRUaW1lc3RhbXAgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICAgICAgbWF4T2JzZXJ2ZWRUaW1lc3RhbXA6IGxvbmdUb1U2NChtZXNzYWdlLm1heE9ic2VydmVkVGltZXN0YW1wKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ubWVzc2FnZSwgbWF4T2JzZXJ2ZWRUaW1lc3RhbXA6IHZvaWQgMCB9O1xuICAgICAgfVxuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBtZXNzYWdlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdG9jb2wuanMubWFwXG4iXSwibmFtZXMiOlsiQmFzZTY0IiwiTG9uZyIsInU2NFRvTG9uZyIsImVuY29kZWQiLCJpbnRlZ2VyQnl0ZXMiLCJ0b0J5dGVBcnJheSIsImZyb21CeXRlc0xFIiwiQXJyYXkiLCJmcm9tIiwibG9uZ1RvVTY0IiwicmF3IiwiVWludDhBcnJheSIsInRvQnl0ZXNMRSIsImZyb21CeXRlQXJyYXkiLCJwYXJzZVNlcnZlck1lc3NhZ2UiLCJ0eXBlIiwic3VjY2VzcyIsInRzIiwic3RhcnRWZXJzaW9uIiwiZW5kVmVyc2lvbiIsImVuY29kZUNsaWVudE1lc3NhZ2UiLCJtZXNzYWdlIiwibWF4T2JzZXJ2ZWRUaW1lc3RhbXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/protocol.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/remote_query_set.js":
/*!***********************************************************************!*\
  !*** ./node_modules/convex/dist/esm/browser/sync/remote_query_set.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RemoteQuerySet: function() { return /* binding */ RemoteQuerySet; }\n/* harmony export */ });\n/* harmony import */ var _values_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/index.js\");\n/* harmony import */ var _vendor_long_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../vendor/long.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/vendor/long.js\");\n/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../logging.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/logging.js\");\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n\n\nclass RemoteQuerySet {\n    transition(transition) {\n        const start = transition.startVersion;\n        if (this.version.querySet !== start.querySet || this.version.ts.notEquals(start.ts) || this.version.identity !== start.identity) {\n            throw new Error(\"Invalid start version: \".concat(start.ts.toString(), \":\").concat(start.querySet, \":\").concat(start.identity, \", transitioning from \").concat(this.version.ts.toString(), \":\").concat(this.version.querySet, \":\").concat(this.version.identity));\n        }\n        for (const modification of transition.modifications){\n            switch(modification.type){\n                case \"QueryUpdated\":\n                    {\n                        const queryPath = this.queryPath(modification.queryId);\n                        if (queryPath) {\n                            for (const line of modification.logLines){\n                                (0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.logForFunction)(this.logger, \"info\", \"query\", queryPath, line);\n                            }\n                        }\n                        var _modification_value;\n                        const value = (0,_values_index_js__WEBPACK_IMPORTED_MODULE_0__.jsonToConvex)((_modification_value = modification.value) !== null && _modification_value !== void 0 ? _modification_value : null);\n                        this.remoteQuerySet.set(modification.queryId, {\n                            success: true,\n                            value,\n                            logLines: modification.logLines\n                        });\n                        break;\n                    }\n                case \"QueryFailed\":\n                    {\n                        const queryPath = this.queryPath(modification.queryId);\n                        if (queryPath) {\n                            for (const line of modification.logLines){\n                                (0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.logForFunction)(this.logger, \"info\", \"query\", queryPath, line);\n                            }\n                        }\n                        const { errorData } = modification;\n                        this.remoteQuerySet.set(modification.queryId, {\n                            success: false,\n                            errorMessage: modification.errorMessage,\n                            errorData: errorData !== void 0 ? (0,_values_index_js__WEBPACK_IMPORTED_MODULE_0__.jsonToConvex)(errorData) : void 0,\n                            logLines: modification.logLines\n                        });\n                        break;\n                    }\n                case \"QueryRemoved\":\n                    {\n                        this.remoteQuerySet.delete(modification.queryId);\n                        break;\n                    }\n                default:\n                    {\n                        modification;\n                        throw new Error(\"Invalid modification \".concat(modification.type));\n                    }\n            }\n        }\n        this.version = transition.endVersion;\n    }\n    remoteQueryResults() {\n        return this.remoteQuerySet;\n    }\n    timestamp() {\n        return this.version.ts;\n    }\n    constructor(queryPath, logger){\n        __publicField(this, \"version\");\n        __publicField(this, \"remoteQuerySet\");\n        __publicField(this, \"queryPath\");\n        __publicField(this, \"logger\");\n        this.version = {\n            querySet: 0,\n            ts: _vendor_long_js__WEBPACK_IMPORTED_MODULE_1__.Long.fromNumber(0),\n            identity: 0\n        };\n        this.remoteQuerySet = /* @__PURE__ */ new Map();\n        this.queryPath = queryPath;\n        this.logger = logger;\n    }\n} //# sourceMappingURL=remote_query_set.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL3JlbW90ZV9xdWVyeV9zZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxrQkFBa0IsQ0FBQ0MsS0FBS0MsS0FBS0MsUUFBVUQsT0FBT0QsTUFBTUosVUFBVUksS0FBS0MsS0FBSztRQUFFRSxZQUFZO1FBQU1DLGNBQWM7UUFBTUMsVUFBVTtRQUFNSDtJQUFNLEtBQUtGLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztBQUMxSixJQUFJSSxnQkFBZ0IsQ0FBQ04sS0FBS0MsS0FBS0MsUUFBVUgsZ0JBQWdCQyxLQUFLLE9BQU9DLFFBQVEsV0FBV0EsTUFBTSxLQUFLQSxLQUFLQztBQUNuRDtBQUNUO0FBQ0c7QUFDeEMsTUFBTVE7SUFXWEMsV0FBV0EsVUFBVSxFQUFFO1FBQ3JCLE1BQU1DLFFBQVFELFdBQVdFLFlBQVk7UUFDckMsSUFBSSxJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsUUFBUSxLQUFLSCxNQUFNRyxRQUFRLElBQUksSUFBSSxDQUFDRCxPQUFPLENBQUNFLEVBQUUsQ0FBQ0MsU0FBUyxDQUFDTCxNQUFNSSxFQUFFLEtBQUssSUFBSSxDQUFDRixPQUFPLENBQUNJLFFBQVEsS0FBS04sTUFBTU0sUUFBUSxFQUFFO1lBQy9ILE1BQU0sSUFBSUMsTUFDUiwwQkFBaURQLE9BQXZCQSxNQUFNSSxFQUFFLENBQUNJLFFBQVEsSUFBRyxLQUFxQlIsT0FBbEJBLE1BQU1HLFFBQVEsRUFBQyxLQUF5QyxPQUF0Q0gsTUFBTU0sUUFBUSxFQUFDLHlCQUFxRCxPQUE5QixJQUFJLENBQUNKLE9BQU8sQ0FBQ0UsRUFBRSxDQUFDSSxRQUFRLElBQUcsS0FBNEIsT0FBekIsSUFBSSxDQUFDTixPQUFPLENBQUNDLFFBQVEsRUFBQyxLQUF5QixPQUF0QixJQUFJLENBQUNELE9BQU8sQ0FBQ0ksUUFBUTtRQUV6TDtRQUNBLEtBQUssTUFBTUcsZ0JBQWdCVixXQUFXVyxhQUFhLENBQUU7WUFDbkQsT0FBUUQsYUFBYUUsSUFBSTtnQkFDdkIsS0FBSztvQkFBZ0I7d0JBQ25CLE1BQU1DLFlBQVksSUFBSSxDQUFDQSxTQUFTLENBQUNILGFBQWFJLE9BQU87d0JBQ3JELElBQUlELFdBQVc7NEJBQ2IsS0FBSyxNQUFNRSxRQUFRTCxhQUFhTSxRQUFRLENBQUU7Z0NBQ3hDbEIsMkRBQWNBLENBQUMsSUFBSSxDQUFDbUIsTUFBTSxFQUFFLFFBQVEsU0FBU0osV0FBV0U7NEJBQzFEO3dCQUNGOzRCQUMyQkw7d0JBQTNCLE1BQU1uQixRQUFRSyw4REFBWUEsQ0FBQ2MsQ0FBQUEsc0JBQUFBLGFBQWFuQixLQUFLLGNBQWxCbUIsaUNBQUFBLHNCQUFzQjt3QkFDakQsSUFBSSxDQUFDUSxjQUFjLENBQUNDLEdBQUcsQ0FBQ1QsYUFBYUksT0FBTyxFQUFFOzRCQUM1Q00sU0FBUzs0QkFDVDdCOzRCQUNBeUIsVUFBVU4sYUFBYU0sUUFBUTt3QkFDakM7d0JBQ0E7b0JBQ0Y7Z0JBQ0EsS0FBSztvQkFBZTt3QkFDbEIsTUFBTUgsWUFBWSxJQUFJLENBQUNBLFNBQVMsQ0FBQ0gsYUFBYUksT0FBTzt3QkFDckQsSUFBSUQsV0FBVzs0QkFDYixLQUFLLE1BQU1FLFFBQVFMLGFBQWFNLFFBQVEsQ0FBRTtnQ0FDeENsQiwyREFBY0EsQ0FBQyxJQUFJLENBQUNtQixNQUFNLEVBQUUsUUFBUSxTQUFTSixXQUFXRTs0QkFDMUQ7d0JBQ0Y7d0JBQ0EsTUFBTSxFQUFFTSxTQUFTLEVBQUUsR0FBR1g7d0JBQ3RCLElBQUksQ0FBQ1EsY0FBYyxDQUFDQyxHQUFHLENBQUNULGFBQWFJLE9BQU8sRUFBRTs0QkFDNUNNLFNBQVM7NEJBQ1RFLGNBQWNaLGFBQWFZLFlBQVk7NEJBQ3ZDRCxXQUFXQSxjQUFjLEtBQUssSUFBSXpCLDhEQUFZQSxDQUFDeUIsYUFBYSxLQUFLOzRCQUNqRUwsVUFBVU4sYUFBYU0sUUFBUTt3QkFDakM7d0JBQ0E7b0JBQ0Y7Z0JBQ0EsS0FBSztvQkFBZ0I7d0JBQ25CLElBQUksQ0FBQ0UsY0FBYyxDQUFDSyxNQUFNLENBQUNiLGFBQWFJLE9BQU87d0JBQy9DO29CQUNGO2dCQUNBO29CQUFTO3dCQUNQSjt3QkFDQSxNQUFNLElBQUlGLE1BQU0sd0JBQTBDLE9BQWxCRSxhQUFhRSxJQUFJO29CQUMzRDtZQUNGO1FBQ0Y7UUFDQSxJQUFJLENBQUNULE9BQU8sR0FBR0gsV0FBV3dCLFVBQVU7SUFDdEM7SUFDQUMscUJBQXFCO1FBQ25CLE9BQU8sSUFBSSxDQUFDUCxjQUFjO0lBQzVCO0lBQ0FRLFlBQVk7UUFDVixPQUFPLElBQUksQ0FBQ3ZCLE9BQU8sQ0FBQ0UsRUFBRTtJQUN4QjtJQW5FQXNCLFlBQVlkLFNBQVMsRUFBRUksTUFBTSxDQUFFO1FBQzdCdEIsY0FBYyxJQUFJLEVBQUU7UUFDcEJBLGNBQWMsSUFBSSxFQUFFO1FBQ3BCQSxjQUFjLElBQUksRUFBRTtRQUNwQkEsY0FBYyxJQUFJLEVBQUU7UUFDcEIsSUFBSSxDQUFDUSxPQUFPLEdBQUc7WUFBRUMsVUFBVTtZQUFHQyxJQUFJUixpREFBSUEsQ0FBQytCLFVBQVUsQ0FBQztZQUFJckIsVUFBVTtRQUFFO1FBQ2xFLElBQUksQ0FBQ1csY0FBYyxHQUFHLGFBQWEsR0FBRyxJQUFJVztRQUMxQyxJQUFJLENBQUNoQixTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0ksTUFBTSxHQUFHQTtJQUNoQjtBQTJERixFQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL2Jyb3dzZXIvc3luYy9yZW1vdGVfcXVlcnlfc2V0LmpzP2FjYTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuaW1wb3J0IHsganNvblRvQ29udmV4IH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgTG9uZyB9IGZyb20gXCIuLi8uLi92ZW5kb3IvbG9uZy5qc1wiO1xuaW1wb3J0IHsgbG9nRm9yRnVuY3Rpb24gfSBmcm9tIFwiLi4vbG9nZ2luZy5qc1wiO1xuZXhwb3J0IGNsYXNzIFJlbW90ZVF1ZXJ5U2V0IHtcbiAgY29uc3RydWN0b3IocXVlcnlQYXRoLCBsb2dnZXIpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmVyc2lvblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVtb3RlUXVlcnlTZXRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInF1ZXJ5UGF0aFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibG9nZ2VyXCIpO1xuICAgIHRoaXMudmVyc2lvbiA9IHsgcXVlcnlTZXQ6IDAsIHRzOiBMb25nLmZyb21OdW1iZXIoMCksIGlkZW50aXR5OiAwIH07XG4gICAgdGhpcy5yZW1vdGVRdWVyeVNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5xdWVyeVBhdGggPSBxdWVyeVBhdGg7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIH1cbiAgdHJhbnNpdGlvbih0cmFuc2l0aW9uKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0cmFuc2l0aW9uLnN0YXJ0VmVyc2lvbjtcbiAgICBpZiAodGhpcy52ZXJzaW9uLnF1ZXJ5U2V0ICE9PSBzdGFydC5xdWVyeVNldCB8fCB0aGlzLnZlcnNpb24udHMubm90RXF1YWxzKHN0YXJ0LnRzKSB8fCB0aGlzLnZlcnNpb24uaWRlbnRpdHkgIT09IHN0YXJ0LmlkZW50aXR5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHN0YXJ0IHZlcnNpb246ICR7c3RhcnQudHMudG9TdHJpbmcoKX06JHtzdGFydC5xdWVyeVNldH06JHtzdGFydC5pZGVudGl0eX0sIHRyYW5zaXRpb25pbmcgZnJvbSAke3RoaXMudmVyc2lvbi50cy50b1N0cmluZygpfToke3RoaXMudmVyc2lvbi5xdWVyeVNldH06JHt0aGlzLnZlcnNpb24uaWRlbnRpdHl9YFxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtb2RpZmljYXRpb24gb2YgdHJhbnNpdGlvbi5tb2RpZmljYXRpb25zKSB7XG4gICAgICBzd2l0Y2ggKG1vZGlmaWNhdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJRdWVyeVVwZGF0ZWRcIjoge1xuICAgICAgICAgIGNvbnN0IHF1ZXJ5UGF0aCA9IHRoaXMucXVlcnlQYXRoKG1vZGlmaWNhdGlvbi5xdWVyeUlkKTtcbiAgICAgICAgICBpZiAocXVlcnlQYXRoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbW9kaWZpY2F0aW9uLmxvZ0xpbmVzKSB7XG4gICAgICAgICAgICAgIGxvZ0ZvckZ1bmN0aW9uKHRoaXMubG9nZ2VyLCBcImluZm9cIiwgXCJxdWVyeVwiLCBxdWVyeVBhdGgsIGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGpzb25Ub0NvbnZleChtb2RpZmljYXRpb24udmFsdWUgPz8gbnVsbCk7XG4gICAgICAgICAgdGhpcy5yZW1vdGVRdWVyeVNldC5zZXQobW9kaWZpY2F0aW9uLnF1ZXJ5SWQsIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGxvZ0xpbmVzOiBtb2RpZmljYXRpb24ubG9nTGluZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiUXVlcnlGYWlsZWRcIjoge1xuICAgICAgICAgIGNvbnN0IHF1ZXJ5UGF0aCA9IHRoaXMucXVlcnlQYXRoKG1vZGlmaWNhdGlvbi5xdWVyeUlkKTtcbiAgICAgICAgICBpZiAocXVlcnlQYXRoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbW9kaWZpY2F0aW9uLmxvZ0xpbmVzKSB7XG4gICAgICAgICAgICAgIGxvZ0ZvckZ1bmN0aW9uKHRoaXMubG9nZ2VyLCBcImluZm9cIiwgXCJxdWVyeVwiLCBxdWVyeVBhdGgsIGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IGVycm9yRGF0YSB9ID0gbW9kaWZpY2F0aW9uO1xuICAgICAgICAgIHRoaXMucmVtb3RlUXVlcnlTZXQuc2V0KG1vZGlmaWNhdGlvbi5xdWVyeUlkLCB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZTogbW9kaWZpY2F0aW9uLmVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgIGVycm9yRGF0YTogZXJyb3JEYXRhICE9PSB2b2lkIDAgPyBqc29uVG9Db252ZXgoZXJyb3JEYXRhKSA6IHZvaWQgMCxcbiAgICAgICAgICAgIGxvZ0xpbmVzOiBtb2RpZmljYXRpb24ubG9nTGluZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiUXVlcnlSZW1vdmVkXCI6IHtcbiAgICAgICAgICB0aGlzLnJlbW90ZVF1ZXJ5U2V0LmRlbGV0ZShtb2RpZmljYXRpb24ucXVlcnlJZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIG1vZGlmaWNhdGlvbjtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbW9kaWZpY2F0aW9uICR7bW9kaWZpY2F0aW9uLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy52ZXJzaW9uID0gdHJhbnNpdGlvbi5lbmRWZXJzaW9uO1xuICB9XG4gIHJlbW90ZVF1ZXJ5UmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdGVRdWVyeVNldDtcbiAgfVxuICB0aW1lc3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvbi50cztcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3RlX3F1ZXJ5X3NldC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX19wdWJsaWNGaWVsZCIsImpzb25Ub0NvbnZleCIsIkxvbmciLCJsb2dGb3JGdW5jdGlvbiIsIlJlbW90ZVF1ZXJ5U2V0IiwidHJhbnNpdGlvbiIsInN0YXJ0Iiwic3RhcnRWZXJzaW9uIiwidmVyc2lvbiIsInF1ZXJ5U2V0IiwidHMiLCJub3RFcXVhbHMiLCJpZGVudGl0eSIsIkVycm9yIiwidG9TdHJpbmciLCJtb2RpZmljYXRpb24iLCJtb2RpZmljYXRpb25zIiwidHlwZSIsInF1ZXJ5UGF0aCIsInF1ZXJ5SWQiLCJsaW5lIiwibG9nTGluZXMiLCJsb2dnZXIiLCJyZW1vdGVRdWVyeVNldCIsInNldCIsInN1Y2Nlc3MiLCJlcnJvckRhdGEiLCJlcnJvck1lc3NhZ2UiLCJkZWxldGUiLCJlbmRWZXJzaW9uIiwicmVtb3RlUXVlcnlSZXN1bHRzIiwidGltZXN0YW1wIiwiY29uc3RydWN0b3IiLCJmcm9tTnVtYmVyIiwiTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/remote_query_set.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/request_manager.js":
/*!**********************************************************************!*\
  !*** ./node_modules/convex/dist/esm/browser/sync/request_manager.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RequestManager: function() { return /* binding */ RequestManager; }\n/* harmony export */ });\n/* harmony import */ var _values_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/index.js\");\n/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logging.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/logging.js\");\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n\nclass RequestManager {\n    request(message, sent) {\n        const result = new Promise((resolve)=>{\n            const status = sent ? \"Requested\" : \"NotSent\";\n            this.inflightRequests.set(message.requestId, {\n                message,\n                status: {\n                    status,\n                    requestedAt: /* @__PURE__ */ new Date(),\n                    onResult: resolve\n                }\n            });\n            if (message.type === \"Mutation\") {\n                this.inflightMutationsCount++;\n            } else if (message.type === \"Action\") {\n                this.inflightActionsCount++;\n            }\n        });\n        this.markConnectionStateDirty();\n        return result;\n    }\n    /**\n   * Update the state after receiving a response.\n   *\n   * @returns A RequestId if the request is complete and its optimistic update\n   * can be dropped, null otherwise.\n   */ onResponse(response) {\n        const requestInfo = this.inflightRequests.get(response.requestId);\n        if (requestInfo === void 0) {\n            return null;\n        }\n        if (requestInfo.status.status === \"Completed\") {\n            return null;\n        }\n        const udfType = requestInfo.message.type === \"Mutation\" ? \"mutation\" : \"action\";\n        const udfPath = requestInfo.message.udfPath;\n        for (const line of response.logLines){\n            (0,_logging_js__WEBPACK_IMPORTED_MODULE_1__.logForFunction)(this.logger, \"info\", udfType, udfPath, line);\n        }\n        const status = requestInfo.status;\n        let result;\n        let onResolve;\n        if (response.success) {\n            result = {\n                success: true,\n                logLines: response.logLines,\n                value: (0,_values_index_js__WEBPACK_IMPORTED_MODULE_0__.jsonToConvex)(response.result)\n            };\n            onResolve = ()=>status.onResult(result);\n        } else {\n            const errorMessage = response.result;\n            const { errorData } = response;\n            (0,_logging_js__WEBPACK_IMPORTED_MODULE_1__.logForFunction)(this.logger, \"error\", udfType, udfPath, errorMessage);\n            result = {\n                success: false,\n                errorMessage,\n                errorData: errorData !== void 0 ? (0,_values_index_js__WEBPACK_IMPORTED_MODULE_0__.jsonToConvex)(errorData) : void 0,\n                logLines: response.logLines\n            };\n            onResolve = ()=>status.onResult(result);\n        }\n        if (response.type === \"ActionResponse\" || !response.success) {\n            onResolve();\n            this.inflightRequests.delete(response.requestId);\n            this.requestsOlderThanRestart.delete(response.requestId);\n            if (requestInfo.message.type === \"Action\") {\n                this.inflightActionsCount--;\n            } else if (requestInfo.message.type === \"Mutation\") {\n                this.inflightMutationsCount--;\n            }\n            this.markConnectionStateDirty();\n            return {\n                requestId: response.requestId,\n                result\n            };\n        }\n        requestInfo.status = {\n            status: \"Completed\",\n            result,\n            ts: response.ts,\n            onResolve\n        };\n        return null;\n    }\n    // Remove and returns completed requests.\n    removeCompleted(ts) {\n        const completeRequests = /* @__PURE__ */ new Map();\n        for (const [requestId, requestInfo] of this.inflightRequests.entries()){\n            const status = requestInfo.status;\n            if (status.status === \"Completed\" && status.ts.lessThanOrEqual(ts)) {\n                status.onResolve();\n                completeRequests.set(requestId, status.result);\n                if (requestInfo.message.type === \"Mutation\") {\n                    this.inflightMutationsCount--;\n                } else if (requestInfo.message.type === \"Action\") {\n                    this.inflightActionsCount--;\n                }\n                this.inflightRequests.delete(requestId);\n                this.requestsOlderThanRestart.delete(requestId);\n            }\n        }\n        if (completeRequests.size > 0) {\n            this.markConnectionStateDirty();\n        }\n        return completeRequests;\n    }\n    restart() {\n        this.requestsOlderThanRestart = new Set(this.inflightRequests.keys());\n        const allMessages = [];\n        for (const [requestId, value] of this.inflightRequests){\n            if (value.status.status === \"NotSent\") {\n                value.status.status = \"Requested\";\n                allMessages.push(value.message);\n                continue;\n            }\n            if (value.message.type === \"Mutation\") {\n                allMessages.push(value.message);\n            } else if (value.message.type === \"Action\") {\n                this.inflightRequests.delete(requestId);\n                this.requestsOlderThanRestart.delete(requestId);\n                this.inflightActionsCount--;\n                if (value.status.status === \"Completed\") {\n                    throw new Error(\"Action should never be in 'Completed' state\");\n                }\n                value.status.onResult({\n                    success: false,\n                    errorMessage: \"Connection lost while action was in flight\",\n                    logLines: []\n                });\n            }\n        }\n        this.markConnectionStateDirty();\n        return allMessages;\n    }\n    resume() {\n        const allMessages = [];\n        for (const [, value] of this.inflightRequests){\n            if (value.status.status === \"NotSent\") {\n                value.status.status = \"Requested\";\n                allMessages.push(value.message);\n                continue;\n            }\n        }\n        return allMessages;\n    }\n    /**\n   * @returns true if there are any requests that have been requested but have\n   * not be completed yet.\n   */ hasIncompleteRequests() {\n        for (const requestInfo of this.inflightRequests.values()){\n            if (requestInfo.status.status === \"Requested\") {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n   * @returns true if there are any inflight requests, including ones that have\n   * completed on the server, but have not been applied.\n   */ hasInflightRequests() {\n        return this.inflightRequests.size > 0;\n    }\n    /**\n   * @returns true if there are any inflight requests, that have been hanging around\n   * since prior to the most recent restart.\n   */ hasSyncedPastLastReconnect() {\n        return this.requestsOlderThanRestart.size === 0;\n    }\n    timeOfOldestInflightRequest() {\n        if (this.inflightRequests.size === 0) {\n            return null;\n        }\n        let oldestInflightRequest = Date.now();\n        for (const request of this.inflightRequests.values()){\n            if (request.status.status !== \"Completed\") {\n                if (request.status.requestedAt.getTime() < oldestInflightRequest) {\n                    oldestInflightRequest = request.status.requestedAt.getTime();\n                }\n            }\n        }\n        return new Date(oldestInflightRequest);\n    }\n    /**\n   * @returns The number of mutations currently in flight.\n   */ inflightMutations() {\n        return this.inflightMutationsCount;\n    }\n    /**\n   * @returns The number of actions currently in flight.\n   */ inflightActions() {\n        return this.inflightActionsCount;\n    }\n    constructor(logger, markConnectionStateDirty){\n        this.logger = logger;\n        this.markConnectionStateDirty = markConnectionStateDirty;\n        __publicField(this, \"inflightRequests\");\n        __publicField(this, \"requestsOlderThanRestart\");\n        __publicField(this, \"inflightMutationsCount\", 0);\n        __publicField(this, \"inflightActionsCount\", 0);\n        this.inflightRequests = /* @__PURE__ */ new Map();\n        this.requestsOlderThanRestart = /* @__PURE__ */ new Set();\n    }\n} //# sourceMappingURL=request_manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL3JlcXVlc3RfbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBYTtBQUNiLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsa0JBQWtCLENBQUNDLEtBQUtDLEtBQUtDLFFBQVVELE9BQU9ELE1BQU1KLFVBQVVJLEtBQUtDLEtBQUs7UUFBRUUsWUFBWTtRQUFNQyxjQUFjO1FBQU1DLFVBQVU7UUFBTUg7SUFBTSxLQUFLRixHQUFHLENBQUNDLElBQUksR0FBR0M7QUFDMUosSUFBSUksZ0JBQWdCLENBQUNOLEtBQUtDLEtBQUtDLFFBQVVILGdCQUFnQkMsS0FBSyxPQUFPQyxRQUFRLFdBQVdBLE1BQU0sS0FBS0EsS0FBS0M7QUFDbkQ7QUFDTjtBQUN4QyxNQUFNTztJQVdYQyxRQUFRQyxPQUFPLEVBQUVDLElBQUksRUFBRTtRQUNyQixNQUFNQyxTQUFTLElBQUlDLFFBQVEsQ0FBQ0M7WUFDMUIsTUFBTUMsU0FBU0osT0FBTyxjQUFjO1lBQ3BDLElBQUksQ0FBQ0ssZ0JBQWdCLENBQUNDLEdBQUcsQ0FBQ1AsUUFBUVEsU0FBUyxFQUFFO2dCQUMzQ1I7Z0JBQ0FLLFFBQVE7b0JBQUVBO29CQUFRSSxhQUFhLGFBQWEsR0FBRyxJQUFJQztvQkFBUUMsVUFBVVA7Z0JBQVE7WUFDL0U7WUFDQSxJQUFJSixRQUFRWSxJQUFJLEtBQUssWUFBWTtnQkFDL0IsSUFBSSxDQUFDQyxzQkFBc0I7WUFDN0IsT0FBTyxJQUFJYixRQUFRWSxJQUFJLEtBQUssVUFBVTtnQkFDcEMsSUFBSSxDQUFDRSxvQkFBb0I7WUFDM0I7UUFDRjtRQUNBLElBQUksQ0FBQ0Msd0JBQXdCO1FBQzdCLE9BQU9iO0lBQ1Q7SUFDQTs7Ozs7R0FLQyxHQUNEYyxXQUFXQyxRQUFRLEVBQUU7UUFDbkIsTUFBTUMsY0FBYyxJQUFJLENBQUNaLGdCQUFnQixDQUFDYSxHQUFHLENB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RDtZQUNGO1FBQ0Y7UUFDQSxPQUFPLElBQUkxQyxLQUFLd0M7SUFDbEI7SUFDQTs7R0FFQyxHQUNERyxvQkFBb0I7UUFDbEIsT0FBTyxJQUFJLENBQUN4QyxzQkFBc0I7SUFDcEM7SUFDQTs7R0FFQyxHQUNEeUMsa0JBQWtCO1FBQ2hCLE9BQU8sSUFBSSxDQUFDeEMsb0JBQW9CO0lBQ2xDO0lBdk1BeUMsWUFBWS9CLE1BQU0sRUFBRVQsd0JBQXdCLENBQUU7UUFDNUMsSUFBSSxDQUFDUyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDVCx3QkFBd0IsR0FBR0E7UUFDaENwQixjQUFjLElBQUksRUFBRTtRQUNwQkEsY0FBYyxJQUFJLEVBQUU7UUFDcEJBLGNBQWMsSUFBSSxFQUFFLDBCQUEwQjtRQUM5Q0EsY0FBYyxJQUFJLEVBQUUsd0JBQXdCO1FBQzVDLElBQUksQ0FBQ1csZ0JBQWdCLEdBQUcsYUFBYSxHQUFHLElBQUk0QjtRQUM1QyxJQUFJLENBQUNKLHdCQUF3QixHQUFHLGFBQWEsR0FBRyxJQUFJUztJQUN0RDtBQStMRixFQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL2Jyb3dzZXIvc3luYy9yZXF1ZXN0X21hbmFnZXIuanM/Mjc2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5pbXBvcnQgeyBqc29uVG9Db252ZXggfSBmcm9tIFwiLi4vLi4vdmFsdWVzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBsb2dGb3JGdW5jdGlvbiB9IGZyb20gXCIuLi9sb2dnaW5nLmpzXCI7XG5leHBvcnQgY2xhc3MgUmVxdWVzdE1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIsIG1hcmtDb25uZWN0aW9uU3RhdGVEaXJ0eSkge1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMubWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5ID0gbWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5O1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpbmZsaWdodFJlcXVlc3RzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXF1ZXN0c09sZGVyVGhhblJlc3RhcnRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImluZmxpZ2h0TXV0YXRpb25zQ291bnRcIiwgMCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImluZmxpZ2h0QWN0aW9uc0NvdW50XCIsIDApO1xuICAgIHRoaXMuaW5mbGlnaHRSZXF1ZXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5yZXF1ZXN0c09sZGVyVGhhblJlc3RhcnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG4gIHJlcXVlc3QobWVzc2FnZSwgc2VudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBzdGF0dXMgPSBzZW50ID8gXCJSZXF1ZXN0ZWRcIiA6IFwiTm90U2VudFwiO1xuICAgICAgdGhpcy5pbmZsaWdodFJlcXVlc3RzLnNldChtZXNzYWdlLnJlcXVlc3RJZCwge1xuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBzdGF0dXM6IHsgc3RhdHVzLCByZXF1ZXN0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIG9uUmVzdWx0OiByZXNvbHZlIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJNdXRhdGlvblwiKSB7XG4gICAgICAgIHRoaXMuaW5mbGlnaHRNdXRhdGlvbnNDb3VudCsrO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiQWN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5pbmZsaWdodEFjdGlvbnNDb3VudCsrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMubWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBzdGF0ZSBhZnRlciByZWNlaXZpbmcgYSByZXNwb25zZS5cbiAgICpcbiAgICogQHJldHVybnMgQSBSZXF1ZXN0SWQgaWYgdGhlIHJlcXVlc3QgaXMgY29tcGxldGUgYW5kIGl0cyBvcHRpbWlzdGljIHVwZGF0ZVxuICAgKiBjYW4gYmUgZHJvcHBlZCwgbnVsbCBvdGhlcndpc2UuXG4gICAqL1xuICBvblJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSB0aGlzLmluZmxpZ2h0UmVxdWVzdHMuZ2V0KHJlc3BvbnNlLnJlcXVlc3RJZCk7XG4gICAgaWYgKHJlcXVlc3RJbmZvID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocmVxdWVzdEluZm8uc3RhdHVzLnN0YXR1cyA9PT0gXCJDb21wbGV0ZWRcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHVkZlR5cGUgPSByZXF1ZXN0SW5mby5tZXNzYWdlLnR5cGUgPT09IFwiTXV0YXRpb25cIiA/IFwibXV0YXRpb25cIiA6IFwiYWN0aW9uXCI7XG4gICAgY29uc3QgdWRmUGF0aCA9IHJlcXVlc3RJbmZvLm1lc3NhZ2UudWRmUGF0aDtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgcmVzcG9uc2UubG9nTGluZXMpIHtcbiAgICAgIGxvZ0ZvckZ1bmN0aW9uKHRoaXMubG9nZ2VyLCBcImluZm9cIiwgdWRmVHlwZSwgdWRmUGF0aCwgbGluZSk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXR1cyA9IHJlcXVlc3RJbmZvLnN0YXR1cztcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBvblJlc29sdmU7XG4gICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgbG9nTGluZXM6IHJlc3BvbnNlLmxvZ0xpbmVzLFxuICAgICAgICB2YWx1ZToganNvblRvQ29udmV4KHJlc3BvbnNlLnJlc3VsdClcbiAgICAgIH07XG4gICAgICBvblJlc29sdmUgPSAoKSA9PiBzdGF0dXMub25SZXN1bHQocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gcmVzcG9uc2UucmVzdWx0O1xuICAgICAgY29uc3QgeyBlcnJvckRhdGEgfSA9IHJlc3BvbnNlO1xuICAgICAgbG9nRm9yRnVuY3Rpb24odGhpcy5sb2dnZXIsIFwiZXJyb3JcIiwgdWRmVHlwZSwgdWRmUGF0aCwgZXJyb3JNZXNzYWdlKTtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yTWVzc2FnZSxcbiAgICAgICAgZXJyb3JEYXRhOiBlcnJvckRhdGEgIT09IHZvaWQgMCA/IGpzb25Ub0NvbnZleChlcnJvckRhdGEpIDogdm9pZCAwLFxuICAgICAgICBsb2dMaW5lczogcmVzcG9uc2UubG9nTGluZXNcbiAgICAgIH07XG4gICAgICBvblJlc29sdmUgPSAoKSA9PiBzdGF0dXMub25SZXN1bHQocmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09IFwiQWN0aW9uUmVzcG9uc2VcIiB8fCAhcmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgb25SZXNvbHZlKCk7XG4gICAgICB0aGlzLmluZmxpZ2h0UmVxdWVzdHMuZGVsZXRlKHJlc3BvbnNlLnJlcXVlc3RJZCk7XG4gICAgICB0aGlzLnJlcXVlc3RzT2xkZXJUaGFuUmVzdGFydC5kZWxldGUocmVzcG9uc2UucmVxdWVzdElkKTtcbiAgICAgIGlmIChyZXF1ZXN0SW5mby5tZXNzYWdlLnR5cGUgPT09IFwiQWN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5pbmZsaWdodEFjdGlvbnNDb3VudC0tO1xuICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0SW5mby5tZXNzYWdlLnR5cGUgPT09IFwiTXV0YXRpb25cIikge1xuICAgICAgICB0aGlzLmluZmxpZ2h0TXV0YXRpb25zQ291bnQtLTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5KCk7XG4gICAgICByZXR1cm4geyByZXF1ZXN0SWQ6IHJlc3BvbnNlLnJlcXVlc3RJZCwgcmVzdWx0IH07XG4gICAgfVxuICAgIHJlcXVlc3RJbmZvLnN0YXR1cyA9IHtcbiAgICAgIHN0YXR1czogXCJDb21wbGV0ZWRcIixcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRzOiByZXNwb25zZS50cyxcbiAgICAgIG9uUmVzb2x2ZVxuICAgIH07XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gUmVtb3ZlIGFuZCByZXR1cm5zIGNvbXBsZXRlZCByZXF1ZXN0cy5cbiAgcmVtb3ZlQ29tcGxldGVkKHRzKSB7XG4gICAgY29uc3QgY29tcGxldGVSZXF1ZXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbcmVxdWVzdElkLCByZXF1ZXN0SW5mb10gb2YgdGhpcy5pbmZsaWdodFJlcXVlc3RzLmVudHJpZXMoKSkge1xuICAgICAgY29uc3Qgc3RhdHVzID0gcmVxdWVzdEluZm8uc3RhdHVzO1xuICAgICAgaWYgKHN0YXR1cy5zdGF0dXMgPT09IFwiQ29tcGxldGVkXCIgJiYgc3RhdHVzLnRzLmxlc3NUaGFuT3JFcXVhbCh0cykpIHtcbiAgICAgICAgc3RhdHVzLm9uUmVzb2x2ZSgpO1xuICAgICAgICBjb21wbGV0ZVJlcXVlc3RzLnNldChyZXF1ZXN0SWQsIHN0YXR1cy5yZXN1bHQpO1xuICAgICAgICBpZiAocmVxdWVzdEluZm8ubWVzc2FnZS50eXBlID09PSBcIk11dGF0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLmluZmxpZ2h0TXV0YXRpb25zQ291bnQtLTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0SW5mby5tZXNzYWdlLnR5cGUgPT09IFwiQWN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLmluZmxpZ2h0QWN0aW9uc0NvdW50LS07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmZsaWdodFJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICB0aGlzLnJlcXVlc3RzT2xkZXJUaGFuUmVzdGFydC5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbXBsZXRlUmVxdWVzdHMuc2l6ZSA+IDApIHtcbiAgICAgIHRoaXMubWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5KCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wbGV0ZVJlcXVlc3RzO1xuICB9XG4gIHJlc3RhcnQoKSB7XG4gICAgdGhpcy5yZXF1ZXN0c09sZGVyVGhhblJlc3RhcnQgPSBuZXcgU2V0KHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5rZXlzKCkpO1xuICAgIGNvbnN0IGFsbE1lc3NhZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBbcmVxdWVzdElkLCB2YWx1ZV0gb2YgdGhpcy5pbmZsaWdodFJlcXVlc3RzKSB7XG4gICAgICBpZiAodmFsdWUuc3RhdHVzLnN0YXR1cyA9PT0gXCJOb3RTZW50XCIpIHtcbiAgICAgICAgdmFsdWUuc3RhdHVzLnN0YXR1cyA9IFwiUmVxdWVzdGVkXCI7XG4gICAgICAgIGFsbE1lc3NhZ2VzLnB1c2godmFsdWUubWVzc2FnZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlLm1lc3NhZ2UudHlwZSA9PT0gXCJNdXRhdGlvblwiKSB7XG4gICAgICAgIGFsbE1lc3NhZ2VzLnB1c2godmFsdWUubWVzc2FnZSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLm1lc3NhZ2UudHlwZSA9PT0gXCJBY3Rpb25cIikge1xuICAgICAgICB0aGlzLmluZmxpZ2h0UmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgIHRoaXMucmVxdWVzdHNPbGRlclRoYW5SZXN0YXJ0LmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICB0aGlzLmluZmxpZ2h0QWN0aW9uc0NvdW50LS07XG4gICAgICAgIGlmICh2YWx1ZS5zdGF0dXMuc3RhdHVzID09PSBcIkNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWN0aW9uIHNob3VsZCBuZXZlciBiZSBpbiAnQ29tcGxldGVkJyBzdGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZS5zdGF0dXMub25SZXN1bHQoe1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yTWVzc2FnZTogXCJDb25uZWN0aW9uIGxvc3Qgd2hpbGUgYWN0aW9uIHdhcyBpbiBmbGlnaHRcIixcbiAgICAgICAgICBsb2dMaW5lczogW11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5KCk7XG4gICAgcmV0dXJuIGFsbE1lc3NhZ2VzO1xuICB9XG4gIHJlc3VtZSgpIHtcbiAgICBjb25zdCBhbGxNZXNzYWdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgWywgdmFsdWVdIG9mIHRoaXMuaW5mbGlnaHRSZXF1ZXN0cykge1xuICAgICAgaWYgKHZhbHVlLnN0YXR1cy5zdGF0dXMgPT09IFwiTm90U2VudFwiKSB7XG4gICAgICAgIHZhbHVlLnN0YXR1cy5zdGF0dXMgPSBcIlJlcXVlc3RlZFwiO1xuICAgICAgICBhbGxNZXNzYWdlcy5wdXNoKHZhbHVlLm1lc3NhZ2UpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsbE1lc3NhZ2VzO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBhbnkgcmVxdWVzdHMgdGhhdCBoYXZlIGJlZW4gcmVxdWVzdGVkIGJ1dCBoYXZlXG4gICAqIG5vdCBiZSBjb21wbGV0ZWQgeWV0LlxuICAgKi9cbiAgaGFzSW5jb21wbGV0ZVJlcXVlc3RzKCkge1xuICAgIGZvciAoY29uc3QgcmVxdWVzdEluZm8gb2YgdGhpcy5pbmZsaWdodFJlcXVlc3RzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocmVxdWVzdEluZm8uc3RhdHVzLnN0YXR1cyA9PT0gXCJSZXF1ZXN0ZWRcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBhbnkgaW5mbGlnaHQgcmVxdWVzdHMsIGluY2x1ZGluZyBvbmVzIHRoYXQgaGF2ZVxuICAgKiBjb21wbGV0ZWQgb24gdGhlIHNlcnZlciwgYnV0IGhhdmUgbm90IGJlZW4gYXBwbGllZC5cbiAgICovXG4gIGhhc0luZmxpZ2h0UmVxdWVzdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5zaXplID4gMDtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgYW55IGluZmxpZ2h0IHJlcXVlc3RzLCB0aGF0IGhhdmUgYmVlbiBoYW5naW5nIGFyb3VuZFxuICAgKiBzaW5jZSBwcmlvciB0byB0aGUgbW9zdCByZWNlbnQgcmVzdGFydC5cbiAgICovXG4gIGhhc1N5bmNlZFBhc3RMYXN0UmVjb25uZWN0KCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RzT2xkZXJUaGFuUmVzdGFydC5zaXplID09PSAwO1xuICB9XG4gIHRpbWVPZk9sZGVzdEluZmxpZ2h0UmVxdWVzdCgpIHtcbiAgICBpZiAodGhpcy5pbmZsaWdodFJlcXVlc3RzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgb2xkZXN0SW5mbGlnaHRSZXF1ZXN0ID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgdGhpcy5pbmZsaWdodFJlcXVlc3RzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMuc3RhdHVzICE9PSBcIkNvbXBsZXRlZFwiKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cy5yZXF1ZXN0ZWRBdC5nZXRUaW1lKCkgPCBvbGRlc3RJbmZsaWdodFJlcXVlc3QpIHtcbiAgICAgICAgICBvbGRlc3RJbmZsaWdodFJlcXVlc3QgPSByZXF1ZXN0LnN0YXR1cy5yZXF1ZXN0ZWRBdC5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKG9sZGVzdEluZmxpZ2h0UmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgbXV0YXRpb25zIGN1cnJlbnRseSBpbiBmbGlnaHQuXG4gICAqL1xuICBpbmZsaWdodE11dGF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5pbmZsaWdodE11dGF0aW9uc0NvdW50O1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGFjdGlvbnMgY3VycmVudGx5IGluIGZsaWdodC5cbiAgICovXG4gIGluZmxpZ2h0QWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5pbmZsaWdodEFjdGlvbnNDb3VudDtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdF9tYW5hZ2VyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19kZWZOb3JtYWxQcm9wIiwib2JqIiwia2V5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX3B1YmxpY0ZpZWxkIiwianNvblRvQ29udmV4IiwibG9nRm9yRnVuY3Rpb24iLCJSZXF1ZXN0TWFuYWdlciIsInJlcXVlc3QiLCJtZXNzYWdlIiwic2VudCIsInJlc3VsdCIsIlByb21pc2UiLCJyZXNvbHZlIiwic3RhdHVzIiwiaW5mbGlnaHRSZXF1ZXN0cyIsInNldCIsInJlcXVlc3RJZCIsInJlcXVlc3RlZEF0IiwiRGF0ZSIsIm9uUmVzdWx0IiwidHlwZSIsImluZmxpZ2h0TXV0YXRpb25zQ291bnQiLCJpbmZsaWdodEFjdGlvbnNDb3VudCIsIm1hcmtDb25uZWN0aW9uU3RhdGVEaXJ0eSIsIm9uUmVzcG9uc2UiLCJyZXNwb25zZSIsInJlcXVlc3RJbmZvIiwiZ2V0IiwidWRmVHlwZSIsInVkZlBhdGgiLCJsaW5lIiwibG9nTGluZXMiLCJsb2dnZXIiLCJvblJlc29sdmUiLCJzdWNjZXNzIiwiZXJyb3JNZXNzYWdlIiwiZXJyb3JEYXRhIiwiZGVsZXRlIiwicmVxdWVzdHNPbGRlclRoYW5SZXN0YXJ0IiwidHMiLCJyZW1vdmVDb21wbGV0ZWQiLCJjb21wbGV0ZVJlcXVlc3RzIiwiTWFwIiwiZW50cmllcyIsImxlc3NUaGFuT3JFcXVhbCIsInNpemUiLCJyZXN0YXJ0IiwiU2V0Iiwia2V5cyIsImFsbE1lc3NhZ2VzIiwicHVzaCIsIkVycm9yIiwicmVzdW1lIiwiaGFzSW5jb21wbGV0ZVJlcXVlc3RzIiwidmFsdWVzIiwiaGFzSW5mbGlnaHRSZXF1ZXN0cyIsImhhc1N5bmNlZFBhc3RMYXN0UmVjb25uZWN0IiwidGltZU9mT2xkZXN0SW5mbGlnaHRSZXF1ZXN0Iiwib2xkZXN0SW5mbGlnaHRSZXF1ZXN0Iiwibm93IiwiZ2V0VGltZSIsImluZmxpZ2h0TXV0YXRpb25zIiwiaW5mbGlnaHRBY3Rpb25zIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/request_manager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/session.js":
/*!**************************************************************!*\
  !*** ./node_modules/convex/dist/esm/browser/sync/session.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   newSessionId: function() { return /* binding */ newSessionId; }\n/* harmony export */ });\n\nfunction newSessionId() {\n    return uuidv4();\n}\nfunction uuidv4() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n        const r = Math.random() * 16 | 0, v = c === \"x\" ? r : r & 3 | 8;\n        return v.toString(16);\n    });\n} //# sourceMappingURL=session.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL3Nlc3Npb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFhO0FBQ04sU0FBU0E7SUFDZCxPQUFPQztBQUNUO0FBQ0EsU0FBU0E7SUFDUCxPQUFPLHVDQUF1Q0MsT0FBTyxDQUFDLFNBQVMsQ0FBQ0M7UUFDOUQsTUFBTUMsSUFBSUMsS0FBS0MsTUFBTSxLQUFLLEtBQUssR0FBR0MsSUFBSUosTUFBTSxNQUFNQyxJQUFJQSxJQUFJLElBQUk7UUFDOUQsT0FBT0csRUFBRUMsUUFBUSxDQUFDO0lBQ3BCO0FBQ0YsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9icm93c2VyL3N5bmMvc2Vzc2lvbi5qcz9lMTAyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0IGZ1bmN0aW9uIG5ld1Nlc3Npb25JZCgpIHtcbiAgcmV0dXJuIHV1aWR2NCgpO1xufVxuZnVuY3Rpb24gdXVpZHY0KCkge1xuICByZXR1cm4gXCJ4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHhcIi5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIHYgPSBjID09PSBcInhcIiA/IHIgOiByICYgMyB8IDg7XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlc3Npb24uanMubWFwXG4iXSwibmFtZXMiOlsibmV3U2Vzc2lvbklkIiwidXVpZHY0IiwicmVwbGFjZSIsImMiLCJyIiwiTWF0aCIsInJhbmRvbSIsInYiLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/session.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/udf_path_utils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/convex/dist/esm/browser/sync/udf_path_utils.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canonicalizeUdfPath: function() { return /* binding */ canonicalizeUdfPath; },\n/* harmony export */   serializePaginatedPathAndArgs: function() { return /* binding */ serializePaginatedPathAndArgs; },\n/* harmony export */   serializePathAndArgs: function() { return /* binding */ serializePathAndArgs; },\n/* harmony export */   serializedQueryTokenIsPaginated: function() { return /* binding */ serializedQueryTokenIsPaginated; }\n/* harmony export */ });\n/* harmony import */ var _values_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/index.js\");\n\n\nfunction canonicalizeUdfPath(udfPath) {\n    const pieces = udfPath.split(\":\");\n    let moduleName;\n    let functionName;\n    if (pieces.length === 1) {\n        moduleName = pieces[0];\n        functionName = \"default\";\n    } else {\n        moduleName = pieces.slice(0, pieces.length - 1).join(\":\");\n        functionName = pieces[pieces.length - 1];\n    }\n    if (moduleName.endsWith(\".js\")) {\n        moduleName = moduleName.slice(0, -3);\n    }\n    return \"\".concat(moduleName, \":\").concat(functionName);\n}\nfunction serializePathAndArgs(udfPath, args) {\n    return JSON.stringify({\n        udfPath: canonicalizeUdfPath(udfPath),\n        args: (0,_values_index_js__WEBPACK_IMPORTED_MODULE_0__.convexToJson)(args)\n    });\n}\nfunction serializePaginatedPathAndArgs(udfPath, args, options) {\n    const { initialNumItems, id } = options;\n    const result = JSON.stringify({\n        type: \"paginated\",\n        udfPath: canonicalizeUdfPath(udfPath),\n        args: (0,_values_index_js__WEBPACK_IMPORTED_MODULE_0__.convexToJson)(args),\n        options: (0,_values_index_js__WEBPACK_IMPORTED_MODULE_0__.convexToJson)({\n            initialNumItems,\n            id\n        })\n    });\n    return result;\n}\nfunction serializedQueryTokenIsPaginated(token) {\n    return JSON.parse(token).type === \"paginated\";\n} //# sourceMappingURL=udf_path_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL3VkZl9wYXRoX3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWE7QUFDd0M7QUFDOUMsU0FBU0Msb0JBQW9CQyxPQUFPO0lBQ3pDLE1BQU1DLFNBQVNELFFBQVFFLEtBQUssQ0FBQztJQUM3QixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUgsT0FBT0ksTUFBTSxLQUFLLEdBQUc7UUFDdkJGLGFBQWFGLE1BQU0sQ0FBQyxFQUFFO1FBQ3RCRyxlQUFlO0lBQ2pCLE9BQU87UUFDTEQsYUFBYUYsT0FBT0ssS0FBSyxDQUFDLEdBQUdMLE9BQU9JLE1BQU0sR0FBRyxHQUFHRSxJQUFJLENBQUM7UUFDckRILGVBQWVILE1BQU0sQ0FBQ0EsT0FBT0ksTUFBTSxHQUFHLEVBQUU7SUFDMUM7SUFDQSxJQUFJRixXQUFXSyxRQUFRLENBQUMsUUFBUTtRQUM5QkwsYUFBYUEsV0FBV0csS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUNwQztJQUNBLE9BQU8sR0FBaUJGLE9BQWRELFlBQVcsS0FBZ0IsT0FBYkM7QUFDMUI7QUFDTyxTQUFTSyxxQkFBcUJULE9BQU8sRUFBRVUsSUFBSTtJQUNoRCxPQUFPQyxLQUFLQyxTQUFTLENBQUM7UUFDcEJaLFNBQVNELG9CQUFvQkM7UUFDN0JVLE1BQU1aLDhEQUFZQSxDQUFDWTtJQUNyQjtBQUNGO0FBQ08sU0FBU0csOEJBQThCYixPQUFPLEVBQUVVLElBQUksRUFBRUksT0FBTztJQUNsRSxNQUFNLEVBQUVDLGVBQWUsRUFBRUMsRUFBRSxFQUFFLEdBQUdGO0lBQ2hDLE1BQU1HLFNBQVNOLEtBQUtDLFNBQVMsQ0FBQztRQUM1Qk0sTUFBTTtRQUNObEIsU0FBU0Qsb0JBQW9CQztRQUM3QlUsTUFBTVosOERBQVlBLENBQUNZO1FBQ25CSSxTQUFTaEIsOERBQVlBLENBQUM7WUFBRWlCO1lBQWlCQztRQUFHO0lBQzlDO0lBQ0EsT0FBT0M7QUFDVDtBQUNPLFNBQVNFLGdDQUFnQ0MsS0FBSztJQUNuRCxPQUFPVCxLQUFLVSxLQUFLLENBQUNELE9BQU9GLElBQUksS0FBSztBQUNwQyxFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL2Jyb3dzZXIvc3luYy91ZGZfcGF0aF91dGlscy5qcz8wNWEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgY29udmV4VG9Kc29uIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZVVkZlBhdGgodWRmUGF0aCkge1xuICBjb25zdCBwaWVjZXMgPSB1ZGZQYXRoLnNwbGl0KFwiOlwiKTtcbiAgbGV0IG1vZHVsZU5hbWU7XG4gIGxldCBmdW5jdGlvbk5hbWU7XG4gIGlmIChwaWVjZXMubGVuZ3RoID09PSAxKSB7XG4gICAgbW9kdWxlTmFtZSA9IHBpZWNlc1swXTtcbiAgICBmdW5jdGlvbk5hbWUgPSBcImRlZmF1bHRcIjtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGVOYW1lID0gcGllY2VzLnNsaWNlKDAsIHBpZWNlcy5sZW5ndGggLSAxKS5qb2luKFwiOlwiKTtcbiAgICBmdW5jdGlvbk5hbWUgPSBwaWVjZXNbcGllY2VzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGlmIChtb2R1bGVOYW1lLmVuZHNXaXRoKFwiLmpzXCIpKSB7XG4gICAgbW9kdWxlTmFtZSA9IG1vZHVsZU5hbWUuc2xpY2UoMCwgLTMpO1xuICB9XG4gIHJldHVybiBgJHttb2R1bGVOYW1lfToke2Z1bmN0aW9uTmFtZX1gO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZVBhdGhBbmRBcmdzKHVkZlBhdGgsIGFyZ3MpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICB1ZGZQYXRoOiBjYW5vbmljYWxpemVVZGZQYXRoKHVkZlBhdGgpLFxuICAgIGFyZ3M6IGNvbnZleFRvSnNvbihhcmdzKVxuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVQYWdpbmF0ZWRQYXRoQW5kQXJncyh1ZGZQYXRoLCBhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgaW5pdGlhbE51bUl0ZW1zLCBpZCB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgIHR5cGU6IFwicGFnaW5hdGVkXCIsXG4gICAgdWRmUGF0aDogY2Fub25pY2FsaXplVWRmUGF0aCh1ZGZQYXRoKSxcbiAgICBhcmdzOiBjb252ZXhUb0pzb24oYXJncyksXG4gICAgb3B0aW9uczogY29udmV4VG9Kc29uKHsgaW5pdGlhbE51bUl0ZW1zLCBpZCB9KVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVkUXVlcnlUb2tlbklzUGFnaW5hdGVkKHRva2VuKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKHRva2VuKS50eXBlID09PSBcInBhZ2luYXRlZFwiO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWRmX3BhdGhfdXRpbHMuanMubWFwXG4iXSwibmFtZXMiOlsiY29udmV4VG9Kc29uIiwiY2Fub25pY2FsaXplVWRmUGF0aCIsInVkZlBhdGgiLCJwaWVjZXMiLCJzcGxpdCIsIm1vZHVsZU5hbWUiLCJmdW5jdGlvbk5hbWUiLCJsZW5ndGgiLCJzbGljZSIsImpvaW4iLCJlbmRzV2l0aCIsInNlcmlhbGl6ZVBhdGhBbmRBcmdzIiwiYXJncyIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZXJpYWxpemVQYWdpbmF0ZWRQYXRoQW5kQXJncyIsIm9wdGlvbnMiLCJpbml0aWFsTnVtSXRlbXMiLCJpZCIsInJlc3VsdCIsInR5cGUiLCJzZXJpYWxpemVkUXVlcnlUb2tlbklzUGFnaW5hdGVkIiwidG9rZW4iLCJwYXJzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/udf_path_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/web_socket_manager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/convex/dist/esm/browser/sync/web_socket_manager.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocketManager: function() { return /* binding */ WebSocketManager; }\n/* harmony export */ });\n/* harmony import */ var _protocol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./protocol.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/protocol.js\");\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\nconst CLOSE_NORMAL = 1e3;\nconst CLOSE_GOING_AWAY = 1001;\nconst CLOSE_NO_STATUS = 1005;\nconst CLOSE_NOT_FOUND = 4040;\nlet firstTime;\nfunction monotonicMillis() {\n    if (firstTime === void 0) {\n        firstTime = Date.now();\n    }\n    if (typeof performance === \"undefined\" || !performance.now) {\n        return Date.now();\n    }\n    return Math.round(firstTime + performance.now());\n}\nfunction prettyNow() {\n    return \"t=\".concat(Math.round((monotonicMillis() - firstTime) / 100) / 10, \"s\");\n}\nconst serverDisconnectErrors = {\n    // A known error, e.g. during a restart or push\n    InternalServerError: {\n        timeout: 1e3\n    },\n    // ErrorMetadata::overloaded() messages that we realy should back off\n    SubscriptionsWorkerFullError: {\n        timeout: 3e3\n    },\n    TooManyConcurrentRequests: {\n        timeout: 3e3\n    },\n    CommitterFullError: {\n        timeout: 3e3\n    },\n    AwsTooManyRequestsException: {\n        timeout: 3e3\n    },\n    ExecuteFullError: {\n        timeout: 3e3\n    },\n    SystemTimeoutError: {\n        timeout: 3e3\n    },\n    ExpiredInQueue: {\n        timeout: 3e3\n    },\n    // ErrorMetadata::feature_temporarily_unavailable() that typically indicate a deploy just happened\n    VectorIndexesUnavailable: {\n        timeout: 1e3\n    },\n    SearchIndexesUnavailable: {\n        timeout: 1e3\n    },\n    TableSummariesUnavailable: {\n        timeout: 1e3\n    },\n    // More ErrorMetadata::overloaded()\n    VectorIndexTooLarge: {\n        timeout: 3e3\n    },\n    SearchIndexTooLarge: {\n        timeout: 3e3\n    },\n    TooManyWritesInTimePeriod: {\n        timeout: 3e3\n    }\n};\nfunction classifyDisconnectError(s) {\n    if (s === void 0) return \"Unknown\";\n    for (const prefix of Object.keys(serverDisconnectErrors)){\n        if (s.startsWith(prefix)) {\n            return prefix;\n        }\n    }\n    return \"Unknown\";\n}\nclass WebSocketManager {\n    setSocketState(state) {\n        this.socket = state;\n        this._logVerbose(\"socket state changed: \".concat(this.socket.state, \", paused: \").concat(\"paused\" in this.socket ? this.socket.paused : void 0));\n        this.markConnectionStateDirty();\n    }\n    assembleTransition(chunk) {\n        if (chunk.partNumber < 0 || chunk.partNumber >= chunk.totalParts || chunk.totalParts === 0 || this.transitionChunkBuffer && (this.transitionChunkBuffer.totalParts !== chunk.totalParts || this.transitionChunkBuffer.transitionId !== chunk.transitionId)) {\n            this.transitionChunkBuffer = null;\n            throw new Error(\"Invalid TransitionChunk\");\n        }\n        if (this.transitionChunkBuffer === null) {\n            this.transitionChunkBuffer = {\n                chunks: [],\n                totalParts: chunk.totalParts,\n                transitionId: chunk.transitionId\n            };\n        }\n        if (chunk.partNumber !== this.transitionChunkBuffer.chunks.length) {\n            const expectedLength = this.transitionChunkBuffer.chunks.length;\n            this.transitionChunkBuffer = null;\n            throw new Error(\"TransitionChunk received out of order: expected part \".concat(expectedLength, \", got \").concat(chunk.partNumber));\n        }\n        this.transitionChunkBuffer.chunks.push(chunk.chunk);\n        if (this.transitionChunkBuffer.chunks.length === chunk.totalParts) {\n            const fullJson = this.transitionChunkBuffer.chunks.join(\"\");\n            this.transitionChunkBuffer = null;\n            const transition = (0,_protocol_js__WEBPACK_IMPORTED_MODULE_0__.parseServerMessage)(JSON.parse(fullJson));\n            if (transition.type !== \"Transition\") {\n                throw new Error(\"Expected Transition, got \".concat(transition.type, \" after assembling chunks\"));\n            }\n            return transition;\n        }\n        return null;\n    }\n    connect() {\n        if (this.socket.state === \"terminated\") {\n            return;\n        }\n        if (this.socket.state !== \"disconnected\" && this.socket.state !== \"stopped\") {\n            throw new Error(\"Didn't start connection from disconnected state: \" + this.socket.state);\n        }\n        const ws = new this.webSocketConstructor(this.uri);\n        this._logVerbose(\"constructed WebSocket\");\n        this.setSocketState({\n            state: \"connecting\",\n            ws,\n            paused: \"no\"\n        });\n        this.resetServerInactivityTimeout();\n        ws.onopen = ()=>{\n            this.logger.logVerbose(\"begin ws.onopen\");\n            if (this.socket.state !== \"connecting\") {\n                throw new Error(\"onopen called with socket not in connecting state\");\n            }\n            this.setSocketState({\n                state: \"ready\",\n                ws,\n                paused: this.socket.paused === \"yes\" ? \"uninitialized\" : \"no\"\n            });\n            this.resetServerInactivityTimeout();\n            if (this.socket.paused === \"no\") {\n                this._hasEverConnected = true;\n                this.onOpen({\n                    connectionCount: this.connectionCount,\n                    lastCloseReason: this.lastCloseReason,\n                    clientTs: monotonicMillis()\n                });\n            }\n            if (this.lastCloseReason !== \"InitialConnect\") {\n                if (this.lastCloseReason) {\n                    this.logger.log(\"WebSocket reconnected at\", prettyNow(), \"after disconnect due to\", this.lastCloseReason);\n                } else {\n                    this.logger.log(\"WebSocket reconnected at\", prettyNow());\n                }\n            }\n            this.connectionCount += 1;\n            this.lastCloseReason = null;\n        };\n        ws.onerror = (error)=>{\n            this.transitionChunkBuffer = null;\n            const message = error.message;\n            if (message) {\n                this.logger.log(\"WebSocket error message: \".concat(message));\n            }\n        };\n        ws.onmessage = (message)=>{\n            this.resetServerInactivityTimeout();\n            const messageLength = message.data.length;\n            let serverMessage = (0,_protocol_js__WEBPACK_IMPORTED_MODULE_0__.parseServerMessage)(JSON.parse(message.data));\n            this._logVerbose(\"received ws message with type \".concat(serverMessage.type));\n            if (serverMessage.type === \"Ping\") {\n                return;\n            }\n            if (serverMessage.type === \"TransitionChunk\") {\n                const transition = this.assembleTransition(serverMessage);\n                if (!transition) {\n                    return;\n                }\n                serverMessage = transition;\n                this._logVerbose(\"assembled full ws message of type \".concat(serverMessage.type));\n            }\n            if (this.transitionChunkBuffer !== null) {\n                this.transitionChunkBuffer = null;\n                this.logger.log(\"Received unexpected \".concat(serverMessage.type, \" while buffering TransitionChunks\"));\n            }\n            if (serverMessage.type === \"Transition\") {\n                this.reportLargeTransition({\n                    messageLength,\n                    transition: serverMessage\n                });\n            }\n            const response = this.onMessage(serverMessage);\n            if (response.hasSyncedPastLastReconnect) {\n                this.retries = 0;\n                this.markConnectionStateDirty();\n            }\n        };\n        ws.onclose = (event)=>{\n            this._logVerbose(\"begin ws.onclose\");\n            this.transitionChunkBuffer = null;\n            if (this.lastCloseReason === null) {\n                this.lastCloseReason = event.reason || \"closed with code \".concat(event.code);\n            }\n            if (event.code !== CLOSE_NORMAL && event.code !== CLOSE_GOING_AWAY && // This commonly gets fired on mobile apps when the app is backgrounded\n            event.code !== CLOSE_NO_STATUS && event.code !== CLOSE_NOT_FOUND) {\n                let msg = \"WebSocket closed with code \".concat(event.code);\n                if (event.reason) {\n                    msg += \": \".concat(event.reason);\n                }\n                this.logger.log(msg);\n                if (this.onServerDisconnectError && event.reason) {\n                    this.onServerDisconnectError(msg);\n                }\n            }\n            const reason = classifyDisconnectError(event.reason);\n            this.scheduleReconnect(reason);\n            return;\n        };\n    }\n    /**\n   * @returns The state of the {@link Socket}.\n   */ socketState() {\n        return this.socket.state;\n    }\n    /**\n   * @param message - A ClientMessage to send.\n   * @returns Whether the message (might have been) sent.\n   */ sendMessage(message) {\n        const messageForLog = {\n            type: message.type,\n            ...message.type === \"Authenticate\" && message.tokenType === \"User\" ? {\n                value: \"...\".concat(message.value.slice(-7))\n            } : {}\n        };\n        if (this.socket.state === \"ready\" && this.socket.paused === \"no\") {\n            const encodedMessage = (0,_protocol_js__WEBPACK_IMPORTED_MODULE_0__.encodeClientMessage)(message);\n            const request = JSON.stringify(encodedMessage);\n            let sent = false;\n            try {\n                this.socket.ws.send(request);\n                sent = true;\n            } catch (error) {\n                this.logger.log(\"Failed to send message on WebSocket, reconnecting: \".concat(error));\n                this.closeAndReconnect(\"FailedToSendMessage\");\n            }\n            this._logVerbose(\"\".concat(sent ? \"sent\" : \"failed to send\", \" message with type \").concat(message.type, \": \").concat(JSON.stringify(messageForLog)));\n            return true;\n        }\n        this._logVerbose(\"message not sent (socket state: \".concat(this.socket.state, \", paused: \").concat(\"paused\" in this.socket ? this.socket.paused : void 0, \"): \").concat(JSON.stringify(messageForLog)));\n        return false;\n    }\n    resetServerInactivityTimeout() {\n        if (this.socket.state === \"terminated\") {\n            return;\n        }\n        if (this.reconnectDueToServerInactivityTimeout !== null) {\n            clearTimeout(this.reconnectDueToServerInactivityTimeout);\n            this.reconnectDueToServerInactivityTimeout = null;\n        }\n        this.reconnectDueToServerInactivityTimeout = setTimeout(()=>{\n            this.closeAndReconnect(\"InactiveServer\");\n        }, this.serverInactivityThreshold);\n    }\n    scheduleReconnect(reason) {\n        this.socket = {\n            state: \"disconnected\"\n        };\n        const backoff = this.nextBackoff(reason);\n        this.markConnectionStateDirty();\n        this.logger.log(\"Attempting reconnect in \".concat(Math.round(backoff), \"ms\"));\n        setTimeout(()=>this.connect(), backoff);\n    }\n    /**\n   * Close the WebSocket and schedule a reconnect.\n   *\n   * This should be used when we hit an error and would like to restart the session.\n   */ closeAndReconnect(closeReason) {\n        this._logVerbose(\"begin closeAndReconnect with reason \".concat(closeReason));\n        switch(this.socket.state){\n            case \"disconnected\":\n            case \"terminated\":\n            case \"stopped\":\n                return;\n            case \"connecting\":\n            case \"ready\":\n                {\n                    this.lastCloseReason = closeReason;\n                    void this.close();\n                    this.scheduleReconnect(\"client\");\n                    return;\n                }\n            default:\n                {\n                    this.socket;\n                }\n        }\n    }\n    /**\n   * Close the WebSocket, being careful to clear the onclose handler to avoid re-entrant\n   * calls. Use this instead of directly calling `ws.close()`\n   *\n   * It is the callers responsibility to update the state after this method is called so that the\n   * closed socket is not accessible or used again after this method is called\n   */ close() {\n        this.transitionChunkBuffer = null;\n        switch(this.socket.state){\n            case \"disconnected\":\n            case \"terminated\":\n            case \"stopped\":\n                return Promise.resolve();\n            case \"connecting\":\n                {\n                    const ws = this.socket.ws;\n                    ws.onmessage = (_message)=>{\n                        this._logVerbose(\"Ignoring message received after close\");\n                    };\n                    return new Promise((r)=>{\n                        ws.onclose = ()=>{\n                            this._logVerbose(\"Closed after connecting\");\n                            r();\n                        };\n                        ws.onopen = ()=>{\n                            this._logVerbose(\"Opened after connecting\");\n                            ws.close();\n                        };\n                    });\n                }\n            case \"ready\":\n                {\n                    this._logVerbose(\"ws.close called\");\n                    const ws = this.socket.ws;\n                    ws.onmessage = (_message)=>{\n                        this._logVerbose(\"Ignoring message received after close\");\n                    };\n                    const result = new Promise((r)=>{\n                        ws.onclose = ()=>{\n                            r();\n                        };\n                    });\n                    ws.close();\n                    return result;\n                }\n            default:\n                {\n                    this.socket;\n                    return Promise.resolve();\n                }\n        }\n    }\n    /**\n   * Close the WebSocket and do not reconnect.\n   * @returns A Promise that resolves when the WebSocket `onClose` callback is called.\n   */ terminate() {\n        if (this.reconnectDueToServerInactivityTimeout) {\n            clearTimeout(this.reconnectDueToServerInactivityTimeout);\n        }\n        switch(this.socket.state){\n            case \"terminated\":\n            case \"stopped\":\n            case \"disconnected\":\n            case \"connecting\":\n            case \"ready\":\n                {\n                    const result = this.close();\n                    this.setSocketState({\n                        state: \"terminated\"\n                    });\n                    return result;\n                }\n            default:\n                {\n                    this.socket;\n                    throw new Error(\"Invalid websocket state: \".concat(this.socket.state));\n                }\n        }\n    }\n    stop() {\n        switch(this.socket.state){\n            case \"terminated\":\n                return Promise.resolve();\n            case \"connecting\":\n            case \"stopped\":\n            case \"disconnected\":\n            case \"ready\":\n                {\n                    const result = this.close();\n                    this.socket = {\n                        state: \"stopped\"\n                    };\n                    return result;\n                }\n            default:\n                {\n                    this.socket;\n                    return Promise.resolve();\n                }\n        }\n    }\n    /**\n   * Create a new WebSocket after a previous `stop()`, unless `terminate()` was\n   * called before.\n   */ tryRestart() {\n        switch(this.socket.state){\n            case \"stopped\":\n                break;\n            case \"terminated\":\n            case \"connecting\":\n            case \"ready\":\n            case \"disconnected\":\n                this.logger.logVerbose(\"Restart called without stopping first\");\n                return;\n            default:\n                {\n                    this.socket;\n                }\n        }\n        this.connect();\n    }\n    pause() {\n        switch(this.socket.state){\n            case \"disconnected\":\n            case \"stopped\":\n            case \"terminated\":\n                return;\n            case \"connecting\":\n            case \"ready\":\n                {\n                    this.socket = {\n                        ...this.socket,\n                        paused: \"yes\"\n                    };\n                    return;\n                }\n            default:\n                {\n                    this.socket;\n                    return;\n                }\n        }\n    }\n    /**\n   * Resume the state machine if previously paused.\n   */ resume() {\n        switch(this.socket.state){\n            case \"connecting\":\n                this.socket = {\n                    ...this.socket,\n                    paused: \"no\"\n                };\n                return;\n            case \"ready\":\n                if (this.socket.paused === \"uninitialized\") {\n                    this.socket = {\n                        ...this.socket,\n                        paused: \"no\"\n                    };\n                    this.onOpen({\n                        connectionCount: this.connectionCount,\n                        lastCloseReason: this.lastCloseReason,\n                        clientTs: monotonicMillis()\n                    });\n                } else if (this.socket.paused === \"yes\") {\n                    this.socket = {\n                        ...this.socket,\n                        paused: \"no\"\n                    };\n                    this.onResume();\n                }\n                return;\n            case \"terminated\":\n            case \"stopped\":\n            case \"disconnected\":\n                return;\n            default:\n                {\n                    this.socket;\n                }\n        }\n        this.connect();\n    }\n    connectionState() {\n        return {\n            isConnected: this.socket.state === \"ready\",\n            hasEverConnected: this._hasEverConnected,\n            connectionCount: this.connectionCount,\n            connectionRetries: this.retries\n        };\n    }\n    _logVerbose(message) {\n        this.logger.logVerbose(message);\n    }\n    nextBackoff(reason) {\n        const initialBackoff = reason === \"client\" ? 100 : reason === \"Unknown\" ? this.defaultInitialBackoff : serverDisconnectErrors[reason].timeout;\n        const baseBackoff = initialBackoff * Math.pow(2, this.retries);\n        this.retries += 1;\n        const actualBackoff = Math.min(baseBackoff, this.maxBackoff);\n        const jitter = actualBackoff * (Math.random() - 0.5);\n        return actualBackoff + jitter;\n    }\n    reportLargeTransition(param) {\n        let { transition, messageLength } = param;\n        if (transition.clientClockSkew === void 0 || transition.serverTs === void 0) {\n            return;\n        }\n        const transitionTransitTime = monotonicMillis() - // client time now\n        // clientClockSkew = (server time + upstream latency) - client time\n        // clientClockSkew is \"how many milliseconds behind (slow) is the client clock\"\n        // but the latency of the Connect message inflates this, making it appear further behind\n        transition.clientClockSkew - transition.serverTs / 1e6;\n        const prettyTransitionTime = \"\".concat(Math.round(transitionTransitTime), \"ms\");\n        const prettyMessageMB = \"\".concat(Math.round(messageLength / 1e4) / 100, \"MB\");\n        const bytesPerSecond = messageLength / (transitionTransitTime / 1e3);\n        const prettyBytesPerSecond = \"\".concat(Math.round(bytesPerSecond / 1e4) / 100, \"MB per second\");\n        this._logVerbose(\"received \".concat(prettyMessageMB, \" transition in \").concat(prettyTransitionTime, \" at \").concat(prettyBytesPerSecond));\n        if (messageLength > 2e7) {\n            this.logger.log(\"received query results totaling more that 20MB (\".concat(prettyMessageMB, \") which will take a long time to download on slower connections\"));\n        } else if (transitionTransitTime > 2e4) {\n            this.logger.log(\"received query results totaling \".concat(prettyMessageMB, \" which took more than 20s to arrive (\").concat(prettyTransitionTime, \")\"));\n        }\n        if (this.debug) {\n            this.sendMessage({\n                type: \"Event\",\n                eventType: \"ClientReceivedTransition\",\n                event: {\n                    transitionTransitTime,\n                    messageLength\n                }\n            });\n        }\n    }\n    constructor(uri, callbacks, webSocketConstructor, logger, markConnectionStateDirty, debug){\n        this.markConnectionStateDirty = markConnectionStateDirty;\n        this.debug = debug;\n        __publicField(this, \"socket\");\n        __publicField(this, \"connectionCount\");\n        __publicField(this, \"_hasEverConnected\", false);\n        __publicField(this, \"lastCloseReason\");\n        // State for assembling the split-up Transition currently being received.\n        __publicField(this, \"transitionChunkBuffer\", null);\n        /** Upon HTTPS/WSS failure, the first jittered backoff duration, in ms. */ __publicField(this, \"defaultInitialBackoff\");\n        /** We backoff exponentially, but we need to cap that--this is the jittered max. */ __publicField(this, \"maxBackoff\");\n        /** How many times have we failed consecutively? */ __publicField(this, \"retries\");\n        /** How long before lack of server response causes us to initiate a reconnect,\n     * in ms */ __publicField(this, \"serverInactivityThreshold\");\n        __publicField(this, \"reconnectDueToServerInactivityTimeout\");\n        __publicField(this, \"uri\");\n        __publicField(this, \"onOpen\");\n        __publicField(this, \"onResume\");\n        __publicField(this, \"onMessage\");\n        __publicField(this, \"webSocketConstructor\");\n        __publicField(this, \"logger\");\n        __publicField(this, \"onServerDisconnectError\");\n        this.webSocketConstructor = webSocketConstructor;\n        this.socket = {\n            state: \"disconnected\"\n        };\n        this.connectionCount = 0;\n        this.lastCloseReason = \"InitialConnect\";\n        this.defaultInitialBackoff = 1e3;\n        this.maxBackoff = 16e3;\n        this.retries = 0;\n        this.serverInactivityThreshold = 6e4;\n        this.reconnectDueToServerInactivityTimeout = null;\n        this.uri = uri;\n        this.onOpen = callbacks.onOpen;\n        this.onResume = callbacks.onResume;\n        this.onMessage = callbacks.onMessage;\n        this.onServerDisconnectError = callbacks.onServerDisconnectError;\n        this.logger = logger;\n        this.connect();\n    }\n} //# sourceMappingURL=web_socket_manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL3dlYl9zb2NrZXRfbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxrQkFBa0IsQ0FBQ0MsS0FBS0MsS0FBS0MsUUFBVUQsT0FBT0QsTUFBTUosVUFBVUksS0FBS0MsS0FBSztRQUFFRSxZQUFZO1FBQU1DLGNBQWM7UUFBTUMsVUFBVTtRQUFNSDtJQUFNLEtBQUtGLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztBQUMxSixJQUFJSSxnQkFBZ0IsQ0FBQ04sS0FBS0MsS0FBS0MsUUFBVUgsZ0JBQWdCQyxLQUFLLE9BQU9DLFFBQVEsV0FBV0EsTUFBTSxLQUFLQSxLQUFLQztBQUlqRjtBQUN2QixNQUFNTyxlQUFlO0FBQ3JCLE1BQU1DLG1CQUFtQjtBQUN6QixNQUFNQyxrQkFBa0I7QUFDeEIsTUFBTUMsa0JBQWtCO0FBQ3hCLElBQUlDO0FBQ0osU0FBU0M7SUFDUCxJQUFJRCxjQUFjLEtBQUssR0FBRztRQUN4QkEsWUFBWUUsS0FBS0MsR0FBRztJQUN0QjtJQUNBLElBQUksT0FBT0MsZ0JBQWdCLGVBQWUsQ0FBQ0EsWUFBWUQsR0FBRyxFQUFFO1FBQzFELE9BQU9ELEtBQUtDLEdBQUc7SUFDakI7SUFDQSxPQUFPRSxLQUFLQyxLQUFLLENBQUNOLFlBQVlJLFlBQVlELEdBQUc7QUFDL0M7QUFDQSxTQUFTSTtJQUNQLE9BQU8sS0FBNEQsT0FBdkRGLEtBQUtDLEtBQUssQ0FBQyxDQUFDTCxvQkFBb0JELFNBQVEsSUFBSyxPQUFPLElBQUc7QUFDckU7QUFDQSxNQUFNUSx5QkFBeUI7SUFDN0IsK0NBQStDO0lBQy9DQyxxQkFBcUI7UUFBRUMsU0FBUztJQUFJO0lBQ3BDLHFFQUFxRTtJQUNyRUMsOEJBQThCO1FBQUVELFNBQVM7SUFBSTtJQUM3Q0UsMkJBQTJCO1FBQUVGLFNBQVM7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QixJQUFJLENBQUNxRCxRQUFRLEdBQUd3QixVQUFVeEIsUUFBUTtRQUNsQyxJQUFJLENBQUN2QyxTQUFTLEdBQUcrRCxVQUFVL0QsU0FBUztRQUNwQyxJQUFJLENBQUNRLHVCQUF1QixHQUFHdUQsVUFBVXZELHVCQUF1QjtRQUNoRSxJQUFJLENBQUN6QixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDTixPQUFPO0lBQ2Q7QUE2Y0YsRUFDQSw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9icm93c2VyL3N5bmMvd2ViX3NvY2tldF9tYW5hZ2VyLmpzPzEzYjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuaW1wb3J0IHtcbiAgZW5jb2RlQ2xpZW50TWVzc2FnZSxcbiAgcGFyc2VTZXJ2ZXJNZXNzYWdlXG59IGZyb20gXCIuL3Byb3RvY29sLmpzXCI7XG5jb25zdCBDTE9TRV9OT1JNQUwgPSAxZTM7XG5jb25zdCBDTE9TRV9HT0lOR19BV0FZID0gMTAwMTtcbmNvbnN0IENMT1NFX05PX1NUQVRVUyA9IDEwMDU7XG5jb25zdCBDTE9TRV9OT1RfRk9VTkQgPSA0MDQwO1xubGV0IGZpcnN0VGltZTtcbmZ1bmN0aW9uIG1vbm90b25pY01pbGxpcygpIHtcbiAgaWYgKGZpcnN0VGltZSA9PT0gdm9pZCAwKSB7XG4gICAgZmlyc3RUaW1lID0gRGF0ZS5ub3coKTtcbiAgfVxuICBpZiAodHlwZW9mIHBlcmZvcm1hbmNlID09PSBcInVuZGVmaW5lZFwiIHx8ICFwZXJmb3JtYW5jZS5ub3cpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfVxuICByZXR1cm4gTWF0aC5yb3VuZChmaXJzdFRpbWUgKyBwZXJmb3JtYW5jZS5ub3coKSk7XG59XG5mdW5jdGlvbiBwcmV0dHlOb3coKSB7XG4gIHJldHVybiBgdD0ke01hdGgucm91bmQoKG1vbm90b25pY01pbGxpcygpIC0gZmlyc3RUaW1lKSAvIDEwMCkgLyAxMH1zYDtcbn1cbmNvbnN0IHNlcnZlckRpc2Nvbm5lY3RFcnJvcnMgPSB7XG4gIC8vIEEga25vd24gZXJyb3IsIGUuZy4gZHVyaW5nIGEgcmVzdGFydCBvciBwdXNoXG4gIEludGVybmFsU2VydmVyRXJyb3I6IHsgdGltZW91dDogMWUzIH0sXG4gIC8vIEVycm9yTWV0YWRhdGE6Om92ZXJsb2FkZWQoKSBtZXNzYWdlcyB0aGF0IHdlIHJlYWx5IHNob3VsZCBiYWNrIG9mZlxuICBTdWJzY3JpcHRpb25zV29ya2VyRnVsbEVycm9yOiB7IHRpbWVvdXQ6IDNlMyB9LFxuICBUb29NYW55Q29uY3VycmVudFJlcXVlc3RzOiB7IHRpbWVvdXQ6IDNlMyB9LFxuICBDb21taXR0ZXJGdWxsRXJyb3I6IHsgdGltZW91dDogM2UzIH0sXG4gIEF3c1Rvb01hbnlSZXF1ZXN0c0V4Y2VwdGlvbjogeyB0aW1lb3V0OiAzZTMgfSxcbiAgRXhlY3V0ZUZ1bGxFcnJvcjogeyB0aW1lb3V0OiAzZTMgfSxcbiAgU3lzdGVtVGltZW91dEVycm9yOiB7IHRpbWVvdXQ6IDNlMyB9LFxuICBFeHBpcmVkSW5RdWV1ZTogeyB0aW1lb3V0OiAzZTMgfSxcbiAgLy8gRXJyb3JNZXRhZGF0YTo6ZmVhdHVyZV90ZW1wb3JhcmlseV91bmF2YWlsYWJsZSgpIHRoYXQgdHlwaWNhbGx5IGluZGljYXRlIGEgZGVwbG95IGp1c3QgaGFwcGVuZWRcbiAgVmVjdG9ySW5kZXhlc1VuYXZhaWxhYmxlOiB7IHRpbWVvdXQ6IDFlMyB9LFxuICBTZWFyY2hJbmRleGVzVW5hdmFpbGFibGU6IHsgdGltZW91dDogMWUzIH0sXG4gIFRhYmxlU3VtbWFyaWVzVW5hdmFpbGFibGU6IHsgdGltZW91dDogMWUzIH0sXG4gIC8vIE1vcmUgRXJyb3JNZXRhZGF0YTo6b3ZlcmxvYWRlZCgpXG4gIFZlY3RvckluZGV4VG9vTGFyZ2U6IHsgdGltZW91dDogM2UzIH0sXG4gIFNlYXJjaEluZGV4VG9vTGFyZ2U6IHsgdGltZW91dDogM2UzIH0sXG4gIFRvb01hbnlXcml0ZXNJblRpbWVQZXJpb2Q6IHsgdGltZW91dDogM2UzIH1cbn07XG5mdW5jdGlvbiBjbGFzc2lmeURpc2Nvbm5lY3RFcnJvcihzKSB7XG4gIGlmIChzID09PSB2b2lkIDApIHJldHVybiBcIlVua25vd25cIjtcbiAgZm9yIChjb25zdCBwcmVmaXggb2YgT2JqZWN0LmtleXMoXG4gICAgc2VydmVyRGlzY29ubmVjdEVycm9yc1xuICApKSB7XG4gICAgaWYgKHMuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICByZXR1cm4gcHJlZml4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gXCJVbmtub3duXCI7XG59XG5leHBvcnQgY2xhc3MgV2ViU29ja2V0TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKHVyaSwgY2FsbGJhY2tzLCB3ZWJTb2NrZXRDb25zdHJ1Y3RvciwgbG9nZ2VyLCBtYXJrQ29ubmVjdGlvblN0YXRlRGlydHksIGRlYnVnKSB7XG4gICAgdGhpcy5tYXJrQ29ubmVjdGlvblN0YXRlRGlydHkgPSBtYXJrQ29ubmVjdGlvblN0YXRlRGlydHk7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzb2NrZXRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbm5lY3Rpb25Db3VudFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2hhc0V2ZXJDb25uZWN0ZWRcIiwgZmFsc2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsYXN0Q2xvc2VSZWFzb25cIik7XG4gICAgLy8gU3RhdGUgZm9yIGFzc2VtYmxpbmcgdGhlIHNwbGl0LXVwIFRyYW5zaXRpb24gY3VycmVudGx5IGJlaW5nIHJlY2VpdmVkLlxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0cmFuc2l0aW9uQ2h1bmtCdWZmZXJcIiwgbnVsbCk7XG4gICAgLyoqIFVwb24gSFRUUFMvV1NTIGZhaWx1cmUsIHRoZSBmaXJzdCBqaXR0ZXJlZCBiYWNrb2ZmIGR1cmF0aW9uLCBpbiBtcy4gKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGVmYXVsdEluaXRpYWxCYWNrb2ZmXCIpO1xuICAgIC8qKiBXZSBiYWNrb2ZmIGV4cG9uZW50aWFsbHksIGJ1dCB3ZSBuZWVkIHRvIGNhcCB0aGF0LS10aGlzIGlzIHRoZSBqaXR0ZXJlZCBtYXguICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1heEJhY2tvZmZcIik7XG4gICAgLyoqIEhvdyBtYW55IHRpbWVzIGhhdmUgd2UgZmFpbGVkIGNvbnNlY3V0aXZlbHk/ICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJldHJpZXNcIik7XG4gICAgLyoqIEhvdyBsb25nIGJlZm9yZSBsYWNrIG9mIHNlcnZlciByZXNwb25zZSBjYXVzZXMgdXMgdG8gaW5pdGlhdGUgYSByZWNvbm5lY3QsXG4gICAgICogaW4gbXMgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2VydmVySW5hY3Rpdml0eVRocmVzaG9sZFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVjb25uZWN0RHVlVG9TZXJ2ZXJJbmFjdGl2aXR5VGltZW91dFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidXJpXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvbk9wZW5cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9uUmVzdW1lXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvbk1lc3NhZ2VcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIndlYlNvY2tldENvbnN0cnVjdG9yXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsb2dnZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9uU2VydmVyRGlzY29ubmVjdEVycm9yXCIpO1xuICAgIHRoaXMud2ViU29ja2V0Q29uc3RydWN0b3IgPSB3ZWJTb2NrZXRDb25zdHJ1Y3RvcjtcbiAgICB0aGlzLnNvY2tldCA9IHsgc3RhdGU6IFwiZGlzY29ubmVjdGVkXCIgfTtcbiAgICB0aGlzLmNvbm5lY3Rpb25Db3VudCA9IDA7XG4gICAgdGhpcy5sYXN0Q2xvc2VSZWFzb24gPSBcIkluaXRpYWxDb25uZWN0XCI7XG4gICAgdGhpcy5kZWZhdWx0SW5pdGlhbEJhY2tvZmYgPSAxZTM7XG4gICAgdGhpcy5tYXhCYWNrb2ZmID0gMTZlMztcbiAgICB0aGlzLnJldHJpZXMgPSAwO1xuICAgIHRoaXMuc2VydmVySW5hY3Rpdml0eVRocmVzaG9sZCA9IDZlNDtcbiAgICB0aGlzLnJlY29ubmVjdER1ZVRvU2VydmVySW5hY3Rpdml0eVRpbWVvdXQgPSBudWxsO1xuICAgIHRoaXMudXJpID0gdXJpO1xuICAgIHRoaXMub25PcGVuID0gY2FsbGJhY2tzLm9uT3BlbjtcbiAgICB0aGlzLm9uUmVzdW1lID0gY2FsbGJhY2tzLm9uUmVzdW1lO1xuICAgIHRoaXMub25NZXNzYWdlID0gY2FsbGJhY2tzLm9uTWVzc2FnZTtcbiAgICB0aGlzLm9uU2VydmVyRGlzY29ubmVjdEVycm9yID0gY2FsbGJhY2tzLm9uU2VydmVyRGlzY29ubmVjdEVycm9yO1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMuY29ubmVjdCgpO1xuICB9XG4gIHNldFNvY2tldFN0YXRlKHN0YXRlKSB7XG4gICAgdGhpcy5zb2NrZXQgPSBzdGF0ZTtcbiAgICB0aGlzLl9sb2dWZXJib3NlKFxuICAgICAgYHNvY2tldCBzdGF0ZSBjaGFuZ2VkOiAke3RoaXMuc29ja2V0LnN0YXRlfSwgcGF1c2VkOiAke1wicGF1c2VkXCIgaW4gdGhpcy5zb2NrZXQgPyB0aGlzLnNvY2tldC5wYXVzZWQgOiB2b2lkIDB9YFxuICAgICk7XG4gICAgdGhpcy5tYXJrQ29ubmVjdGlvblN0YXRlRGlydHkoKTtcbiAgfVxuICBhc3NlbWJsZVRyYW5zaXRpb24oY2h1bmspIHtcbiAgICBpZiAoY2h1bmsucGFydE51bWJlciA8IDAgfHwgY2h1bmsucGFydE51bWJlciA+PSBjaHVuay50b3RhbFBhcnRzIHx8IGNodW5rLnRvdGFsUGFydHMgPT09IDAgfHwgdGhpcy50cmFuc2l0aW9uQ2h1bmtCdWZmZXIgJiYgKHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyLnRvdGFsUGFydHMgIT09IGNodW5rLnRvdGFsUGFydHMgfHwgdGhpcy50cmFuc2l0aW9uQ2h1bmtCdWZmZXIudHJhbnNpdGlvbklkICE9PSBjaHVuay50cmFuc2l0aW9uSWQpKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlciA9IG51bGw7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFRyYW5zaXRpb25DaHVua1wiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyID09PSBudWxsKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlciA9IHtcbiAgICAgICAgY2h1bmtzOiBbXSxcbiAgICAgICAgdG90YWxQYXJ0czogY2h1bmsudG90YWxQYXJ0cyxcbiAgICAgICAgdHJhbnNpdGlvbklkOiBjaHVuay50cmFuc2l0aW9uSWRcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChjaHVuay5wYXJ0TnVtYmVyICE9PSB0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlci5jaHVua3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBleHBlY3RlZExlbmd0aCA9IHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyLmNodW5rcy5sZW5ndGg7XG4gICAgICB0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlciA9IG51bGw7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUcmFuc2l0aW9uQ2h1bmsgcmVjZWl2ZWQgb3V0IG9mIG9yZGVyOiBleHBlY3RlZCBwYXJ0ICR7ZXhwZWN0ZWRMZW5ndGh9LCBnb3QgJHtjaHVuay5wYXJ0TnVtYmVyfWBcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyLmNodW5rcy5wdXNoKGNodW5rLmNodW5rKTtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uQ2h1bmtCdWZmZXIuY2h1bmtzLmxlbmd0aCA9PT0gY2h1bmsudG90YWxQYXJ0cykge1xuICAgICAgY29uc3QgZnVsbEpzb24gPSB0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlci5jaHVua3Muam9pbihcIlwiKTtcbiAgICAgIHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyID0gbnVsbDtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSBwYXJzZVNlcnZlck1lc3NhZ2UoSlNPTi5wYXJzZShmdWxsSnNvbikpO1xuICAgICAgaWYgKHRyYW5zaXRpb24udHlwZSAhPT0gXCJUcmFuc2l0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCBUcmFuc2l0aW9uLCBnb3QgJHt0cmFuc2l0aW9uLnR5cGV9IGFmdGVyIGFzc2VtYmxpbmcgY2h1bmtzYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zaXRpb247XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuc29ja2V0LnN0YXRlID09PSBcInRlcm1pbmF0ZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zb2NrZXQuc3RhdGUgIT09IFwiZGlzY29ubmVjdGVkXCIgJiYgdGhpcy5zb2NrZXQuc3RhdGUgIT09IFwic3RvcHBlZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRGlkbid0IHN0YXJ0IGNvbm5lY3Rpb24gZnJvbSBkaXNjb25uZWN0ZWQgc3RhdGU6IFwiICsgdGhpcy5zb2NrZXQuc3RhdGVcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHdzID0gbmV3IHRoaXMud2ViU29ja2V0Q29uc3RydWN0b3IodGhpcy51cmkpO1xuICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXCJjb25zdHJ1Y3RlZCBXZWJTb2NrZXRcIik7XG4gICAgdGhpcy5zZXRTb2NrZXRTdGF0ZSh7XG4gICAgICBzdGF0ZTogXCJjb25uZWN0aW5nXCIsXG4gICAgICB3cyxcbiAgICAgIHBhdXNlZDogXCJub1wiXG4gICAgfSk7XG4gICAgdGhpcy5yZXNldFNlcnZlckluYWN0aXZpdHlUaW1lb3V0KCk7XG4gICAgd3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgdGhpcy5sb2dnZXIubG9nVmVyYm9zZShcImJlZ2luIHdzLm9ub3BlblwiKTtcbiAgICAgIGlmICh0aGlzLnNvY2tldC5zdGF0ZSAhPT0gXCJjb25uZWN0aW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25vcGVuIGNhbGxlZCB3aXRoIHNvY2tldCBub3QgaW4gY29ubmVjdGluZyBzdGF0ZVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U29ja2V0U3RhdGUoe1xuICAgICAgICBzdGF0ZTogXCJyZWFkeVwiLFxuICAgICAgICB3cyxcbiAgICAgICAgcGF1c2VkOiB0aGlzLnNvY2tldC5wYXVzZWQgPT09IFwieWVzXCIgPyBcInVuaW5pdGlhbGl6ZWRcIiA6IFwibm9cIlxuICAgICAgfSk7XG4gICAgICB0aGlzLnJlc2V0U2VydmVySW5hY3Rpdml0eVRpbWVvdXQoKTtcbiAgICAgIGlmICh0aGlzLnNvY2tldC5wYXVzZWQgPT09IFwibm9cIikge1xuICAgICAgICB0aGlzLl9oYXNFdmVyQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbk9wZW4oe1xuICAgICAgICAgIGNvbm5lY3Rpb25Db3VudDogdGhpcy5jb25uZWN0aW9uQ291bnQsXG4gICAgICAgICAgbGFzdENsb3NlUmVhc29uOiB0aGlzLmxhc3RDbG9zZVJlYXNvbixcbiAgICAgICAgICBjbGllbnRUczogbW9ub3RvbmljTWlsbGlzKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5sYXN0Q2xvc2VSZWFzb24gIT09IFwiSW5pdGlhbENvbm5lY3RcIikge1xuICAgICAgICBpZiAodGhpcy5sYXN0Q2xvc2VSZWFzb24pIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXG4gICAgICAgICAgICBcIldlYlNvY2tldCByZWNvbm5lY3RlZCBhdFwiLFxuICAgICAgICAgICAgcHJldHR5Tm93KCksXG4gICAgICAgICAgICBcImFmdGVyIGRpc2Nvbm5lY3QgZHVlIHRvXCIsXG4gICAgICAgICAgICB0aGlzLmxhc3RDbG9zZVJlYXNvblxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiV2ViU29ja2V0IHJlY29ubmVjdGVkIGF0XCIsIHByZXR0eU5vdygpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5jb25uZWN0aW9uQ291bnQgKz0gMTtcbiAgICAgIHRoaXMubGFzdENsb3NlUmVhc29uID0gbnVsbDtcbiAgICB9O1xuICAgIHdzLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyID0gbnVsbDtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKGBXZWJTb2NrZXQgZXJyb3IgbWVzc2FnZTogJHttZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH07XG4gICAgd3Mub25tZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgIHRoaXMucmVzZXRTZXJ2ZXJJbmFjdGl2aXR5VGltZW91dCgpO1xuICAgICAgY29uc3QgbWVzc2FnZUxlbmd0aCA9IG1lc3NhZ2UuZGF0YS5sZW5ndGg7XG4gICAgICBsZXQgc2VydmVyTWVzc2FnZSA9IHBhcnNlU2VydmVyTWVzc2FnZShKU09OLnBhcnNlKG1lc3NhZ2UuZGF0YSkpO1xuICAgICAgdGhpcy5fbG9nVmVyYm9zZShgcmVjZWl2ZWQgd3MgbWVzc2FnZSB3aXRoIHR5cGUgJHtzZXJ2ZXJNZXNzYWdlLnR5cGV9YCk7XG4gICAgICBpZiAoc2VydmVyTWVzc2FnZS50eXBlID09PSBcIlBpbmdcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2VydmVyTWVzc2FnZS50eXBlID09PSBcIlRyYW5zaXRpb25DaHVua1wiKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSB0aGlzLmFzc2VtYmxlVHJhbnNpdGlvbihzZXJ2ZXJNZXNzYWdlKTtcbiAgICAgICAgaWYgKCF0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlcnZlck1lc3NhZ2UgPSB0cmFuc2l0aW9uO1xuICAgICAgICB0aGlzLl9sb2dWZXJib3NlKFxuICAgICAgICAgIGBhc3NlbWJsZWQgZnVsbCB3cyBtZXNzYWdlIG9mIHR5cGUgJHtzZXJ2ZXJNZXNzYWdlLnR5cGV9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgICAgIGBSZWNlaXZlZCB1bmV4cGVjdGVkICR7c2VydmVyTWVzc2FnZS50eXBlfSB3aGlsZSBidWZmZXJpbmcgVHJhbnNpdGlvbkNodW5rc2BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXJ2ZXJNZXNzYWdlLnR5cGUgPT09IFwiVHJhbnNpdGlvblwiKSB7XG4gICAgICAgIHRoaXMucmVwb3J0TGFyZ2VUcmFuc2l0aW9uKHtcbiAgICAgICAgICBtZXNzYWdlTGVuZ3RoLFxuICAgICAgICAgIHRyYW5zaXRpb246IHNlcnZlck1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMub25NZXNzYWdlKHNlcnZlck1lc3NhZ2UpO1xuICAgICAgaWYgKHJlc3BvbnNlLmhhc1N5bmNlZFBhc3RMYXN0UmVjb25uZWN0KSB7XG4gICAgICAgIHRoaXMucmV0cmllcyA9IDA7XG4gICAgICAgIHRoaXMubWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3cy5vbmNsb3NlID0gKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLl9sb2dWZXJib3NlKFwiYmVnaW4gd3Mub25jbG9zZVwiKTtcbiAgICAgIHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLmxhc3RDbG9zZVJlYXNvbiA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmxhc3RDbG9zZVJlYXNvbiA9IGV2ZW50LnJlYXNvbiB8fCBgY2xvc2VkIHdpdGggY29kZSAke2V2ZW50LmNvZGV9YDtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5jb2RlICE9PSBDTE9TRV9OT1JNQUwgJiYgZXZlbnQuY29kZSAhPT0gQ0xPU0VfR09JTkdfQVdBWSAmJiAvLyBUaGlzIGNvbW1vbmx5IGdldHMgZmlyZWQgb24gbW9iaWxlIGFwcHMgd2hlbiB0aGUgYXBwIGlzIGJhY2tncm91bmRlZFxuICAgICAgZXZlbnQuY29kZSAhPT0gQ0xPU0VfTk9fU1RBVFVTICYmIGV2ZW50LmNvZGUgIT09IENMT1NFX05PVF9GT1VORCkge1xuICAgICAgICBsZXQgbXNnID0gYFdlYlNvY2tldCBjbG9zZWQgd2l0aCBjb2RlICR7ZXZlbnQuY29kZX1gO1xuICAgICAgICBpZiAoZXZlbnQucmVhc29uKSB7XG4gICAgICAgICAgbXNnICs9IGA6ICR7ZXZlbnQucmVhc29ufWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKG1zZyk7XG4gICAgICAgIGlmICh0aGlzLm9uU2VydmVyRGlzY29ubmVjdEVycm9yICYmIGV2ZW50LnJlYXNvbikge1xuICAgICAgICAgIHRoaXMub25TZXJ2ZXJEaXNjb25uZWN0RXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcmVhc29uID0gY2xhc3NpZnlEaXNjb25uZWN0RXJyb3IoZXZlbnQucmVhc29uKTtcbiAgICAgIHRoaXMuc2NoZWR1bGVSZWNvbm5lY3QocmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyBUaGUgc3RhdGUgb2YgdGhlIHtAbGluayBTb2NrZXR9LlxuICAgKi9cbiAgc29ja2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc29ja2V0LnN0YXRlO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gbWVzc2FnZSAtIEEgQ2xpZW50TWVzc2FnZSB0byBzZW5kLlxuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBtZXNzYWdlIChtaWdodCBoYXZlIGJlZW4pIHNlbnQuXG4gICAqL1xuICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgbWVzc2FnZUZvckxvZyA9IHtcbiAgICAgIHR5cGU6IG1lc3NhZ2UudHlwZSxcbiAgICAgIC4uLm1lc3NhZ2UudHlwZSA9PT0gXCJBdXRoZW50aWNhdGVcIiAmJiBtZXNzYWdlLnRva2VuVHlwZSA9PT0gXCJVc2VyXCIgPyB7XG4gICAgICAgIHZhbHVlOiBgLi4uJHttZXNzYWdlLnZhbHVlLnNsaWNlKC03KX1gXG4gICAgICB9IDoge31cbiAgICB9O1xuICAgIGlmICh0aGlzLnNvY2tldC5zdGF0ZSA9PT0gXCJyZWFkeVwiICYmIHRoaXMuc29ja2V0LnBhdXNlZCA9PT0gXCJub1wiKSB7XG4gICAgICBjb25zdCBlbmNvZGVkTWVzc2FnZSA9IGVuY29kZUNsaWVudE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gSlNPTi5zdHJpbmdpZnkoZW5jb2RlZE1lc3NhZ2UpO1xuICAgICAgbGV0IHNlbnQgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc29ja2V0LndzLnNlbmQocmVxdWVzdCk7XG4gICAgICAgIHNlbnQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgICAgIGBGYWlsZWQgdG8gc2VuZCBtZXNzYWdlIG9uIFdlYlNvY2tldCwgcmVjb25uZWN0aW5nOiAke2Vycm9yfWBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jbG9zZUFuZFJlY29ubmVjdChcIkZhaWxlZFRvU2VuZE1lc3NhZ2VcIik7XG4gICAgICB9XG4gICAgICB0aGlzLl9sb2dWZXJib3NlKFxuICAgICAgICBgJHtzZW50ID8gXCJzZW50XCIgOiBcImZhaWxlZCB0byBzZW5kXCJ9IG1lc3NhZ2Ugd2l0aCB0eXBlICR7bWVzc2FnZS50eXBlfTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBtZXNzYWdlRm9yTG9nXG4gICAgICAgICl9YFxuICAgICAgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9sb2dWZXJib3NlKFxuICAgICAgYG1lc3NhZ2Ugbm90IHNlbnQgKHNvY2tldCBzdGF0ZTogJHt0aGlzLnNvY2tldC5zdGF0ZX0sIHBhdXNlZDogJHtcInBhdXNlZFwiIGluIHRoaXMuc29ja2V0ID8gdGhpcy5zb2NrZXQucGF1c2VkIDogdm9pZCAwfSk6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIG1lc3NhZ2VGb3JMb2dcbiAgICAgICl9YFxuICAgICk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJlc2V0U2VydmVySW5hY3Rpdml0eVRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMuc29ja2V0LnN0YXRlID09PSBcInRlcm1pbmF0ZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWNvbm5lY3REdWVUb1NlcnZlckluYWN0aXZpdHlUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3REdWVUb1NlcnZlckluYWN0aXZpdHlUaW1lb3V0KTtcbiAgICAgIHRoaXMucmVjb25uZWN0RHVlVG9TZXJ2ZXJJbmFjdGl2aXR5VGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucmVjb25uZWN0RHVlVG9TZXJ2ZXJJbmFjdGl2aXR5VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZUFuZFJlY29ubmVjdChcIkluYWN0aXZlU2VydmVyXCIpO1xuICAgIH0sIHRoaXMuc2VydmVySW5hY3Rpdml0eVRocmVzaG9sZCk7XG4gIH1cbiAgc2NoZWR1bGVSZWNvbm5lY3QocmVhc29uKSB7XG4gICAgdGhpcy5zb2NrZXQgPSB7IHN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiIH07XG4gICAgY29uc3QgYmFja29mZiA9IHRoaXMubmV4dEJhY2tvZmYocmVhc29uKTtcbiAgICB0aGlzLm1hcmtDb25uZWN0aW9uU3RhdGVEaXJ0eSgpO1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgQXR0ZW1wdGluZyByZWNvbm5lY3QgaW4gJHtNYXRoLnJvdW5kKGJhY2tvZmYpfW1zYCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmNvbm5lY3QoKSwgYmFja29mZik7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIHRoZSBXZWJTb2NrZXQgYW5kIHNjaGVkdWxlIGEgcmVjb25uZWN0LlxuICAgKlxuICAgKiBUaGlzIHNob3VsZCBiZSB1c2VkIHdoZW4gd2UgaGl0IGFuIGVycm9yIGFuZCB3b3VsZCBsaWtlIHRvIHJlc3RhcnQgdGhlIHNlc3Npb24uXG4gICAqL1xuICBjbG9zZUFuZFJlY29ubmVjdChjbG9zZVJlYXNvbikge1xuICAgIHRoaXMuX2xvZ1ZlcmJvc2UoYGJlZ2luIGNsb3NlQW5kUmVjb25uZWN0IHdpdGggcmVhc29uICR7Y2xvc2VSZWFzb259YCk7XG4gICAgc3dpdGNoICh0aGlzLnNvY2tldC5zdGF0ZSkge1xuICAgICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgY2FzZSBcInRlcm1pbmF0ZWRcIjpcbiAgICAgIGNhc2UgXCJzdG9wcGVkXCI6XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJjb25uZWN0aW5nXCI6XG4gICAgICBjYXNlIFwicmVhZHlcIjoge1xuICAgICAgICB0aGlzLmxhc3RDbG9zZVJlYXNvbiA9IGNsb3NlUmVhc29uO1xuICAgICAgICB2b2lkIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlY29ubmVjdChcImNsaWVudFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aGlzLnNvY2tldDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIHRoZSBXZWJTb2NrZXQsIGJlaW5nIGNhcmVmdWwgdG8gY2xlYXIgdGhlIG9uY2xvc2UgaGFuZGxlciB0byBhdm9pZCByZS1lbnRyYW50XG4gICAqIGNhbGxzLiBVc2UgdGhpcyBpbnN0ZWFkIG9mIGRpcmVjdGx5IGNhbGxpbmcgYHdzLmNsb3NlKClgXG4gICAqXG4gICAqIEl0IGlzIHRoZSBjYWxsZXJzIHJlc3BvbnNpYmlsaXR5IHRvIHVwZGF0ZSB0aGUgc3RhdGUgYWZ0ZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkIHNvIHRoYXQgdGhlXG4gICAqIGNsb3NlZCBzb2NrZXQgaXMgbm90IGFjY2Vzc2libGUgb3IgdXNlZCBhZ2FpbiBhZnRlciB0aGlzIG1ldGhvZCBpcyBjYWxsZWRcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyID0gbnVsbDtcbiAgICBzd2l0Y2ggKHRoaXMuc29ja2V0LnN0YXRlKSB7XG4gICAgICBjYXNlIFwiZGlzY29ubmVjdGVkXCI6XG4gICAgICBjYXNlIFwidGVybWluYXRlZFwiOlxuICAgICAgY2FzZSBcInN0b3BwZWRcIjpcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgY2FzZSBcImNvbm5lY3RpbmdcIjoge1xuICAgICAgICBjb25zdCB3cyA9IHRoaXMuc29ja2V0LndzO1xuICAgICAgICB3cy5vbm1lc3NhZ2UgPSAoX21lc3NhZ2UpID0+IHtcbiAgICAgICAgICB0aGlzLl9sb2dWZXJib3NlKFwiSWdub3JpbmcgbWVzc2FnZSByZWNlaXZlZCBhZnRlciBjbG9zZVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyKSA9PiB7XG4gICAgICAgICAgd3Mub25jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXCJDbG9zZWQgYWZ0ZXIgY29ubmVjdGluZ1wiKTtcbiAgICAgICAgICAgIHIoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXCJPcGVuZWQgYWZ0ZXIgY29ubmVjdGluZ1wiKTtcbiAgICAgICAgICAgIHdzLmNsb3NlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjYXNlIFwicmVhZHlcIjoge1xuICAgICAgICB0aGlzLl9sb2dWZXJib3NlKFwid3MuY2xvc2UgY2FsbGVkXCIpO1xuICAgICAgICBjb25zdCB3cyA9IHRoaXMuc29ja2V0LndzO1xuICAgICAgICB3cy5vbm1lc3NhZ2UgPSAoX21lc3NhZ2UpID0+IHtcbiAgICAgICAgICB0aGlzLl9sb2dWZXJib3NlKFwiSWdub3JpbmcgbWVzc2FnZSByZWNlaXZlZCBhZnRlciBjbG9zZVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFByb21pc2UoKHIpID0+IHtcbiAgICAgICAgICB3cy5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgcigpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB3cy5jbG9zZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aGlzLnNvY2tldDtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2xvc2UgdGhlIFdlYlNvY2tldCBhbmQgZG8gbm90IHJlY29ubmVjdC5cbiAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgV2ViU29ja2V0IGBvbkNsb3NlYCBjYWxsYmFjayBpcyBjYWxsZWQuXG4gICAqL1xuICB0ZXJtaW5hdGUoKSB7XG4gICAgaWYgKHRoaXMucmVjb25uZWN0RHVlVG9TZXJ2ZXJJbmFjdGl2aXR5VGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0RHVlVG9TZXJ2ZXJJbmFjdGl2aXR5VGltZW91dCk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5zb2NrZXQuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJ0ZXJtaW5hdGVkXCI6XG4gICAgICBjYXNlIFwic3RvcHBlZFwiOlxuICAgICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgY2FzZSBcImNvbm5lY3RpbmdcIjpcbiAgICAgIGNhc2UgXCJyZWFkeVwiOiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5zZXRTb2NrZXRTdGF0ZSh7IHN0YXRlOiBcInRlcm1pbmF0ZWRcIiB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhpcy5zb2NrZXQ7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgSW52YWxpZCB3ZWJzb2NrZXQgc3RhdGU6ICR7dGhpcy5zb2NrZXQuc3RhdGV9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdG9wKCkge1xuICAgIHN3aXRjaCAodGhpcy5zb2NrZXQuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJ0ZXJtaW5hdGVkXCI6XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIGNhc2UgXCJjb25uZWN0aW5nXCI6XG4gICAgICBjYXNlIFwic3RvcHBlZFwiOlxuICAgICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgY2FzZSBcInJlYWR5XCI6IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jbG9zZSgpO1xuICAgICAgICB0aGlzLnNvY2tldCA9IHsgc3RhdGU6IFwic3RvcHBlZFwiIH07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRoaXMuc29ja2V0O1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgV2ViU29ja2V0IGFmdGVyIGEgcHJldmlvdXMgYHN0b3AoKWAsIHVubGVzcyBgdGVybWluYXRlKClgIHdhc1xuICAgKiBjYWxsZWQgYmVmb3JlLlxuICAgKi9cbiAgdHJ5UmVzdGFydCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc29ja2V0LnN0YXRlKSB7XG4gICAgICBjYXNlIFwic3RvcHBlZFwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0ZXJtaW5hdGVkXCI6XG4gICAgICBjYXNlIFwiY29ubmVjdGluZ1wiOlxuICAgICAgY2FzZSBcInJlYWR5XCI6XG4gICAgICBjYXNlIFwiZGlzY29ubmVjdGVkXCI6XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZ1ZlcmJvc2UoXCJSZXN0YXJ0IGNhbGxlZCB3aXRob3V0IHN0b3BwaW5nIGZpcnN0XCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRoaXMuc29ja2V0O1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbm5lY3QoKTtcbiAgfVxuICBwYXVzZSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc29ja2V0LnN0YXRlKSB7XG4gICAgICBjYXNlIFwiZGlzY29ubmVjdGVkXCI6XG4gICAgICBjYXNlIFwic3RvcHBlZFwiOlxuICAgICAgY2FzZSBcInRlcm1pbmF0ZWRcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImNvbm5lY3RpbmdcIjpcbiAgICAgIGNhc2UgXCJyZWFkeVwiOiB7XG4gICAgICAgIHRoaXMuc29ja2V0ID0geyAuLi50aGlzLnNvY2tldCwgcGF1c2VkOiBcInllc1wiIH07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhpcy5zb2NrZXQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlc3VtZSB0aGUgc3RhdGUgbWFjaGluZSBpZiBwcmV2aW91c2x5IHBhdXNlZC5cbiAgICovXG4gIHJlc3VtZSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc29ja2V0LnN0YXRlKSB7XG4gICAgICBjYXNlIFwiY29ubmVjdGluZ1wiOlxuICAgICAgICB0aGlzLnNvY2tldCA9IHsgLi4udGhpcy5zb2NrZXQsIHBhdXNlZDogXCJub1wiIH07XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJyZWFkeVwiOlxuICAgICAgICBpZiAodGhpcy5zb2NrZXQucGF1c2VkID09PSBcInVuaW5pdGlhbGl6ZWRcIikge1xuICAgICAgICAgIHRoaXMuc29ja2V0ID0geyAuLi50aGlzLnNvY2tldCwgcGF1c2VkOiBcIm5vXCIgfTtcbiAgICAgICAgICB0aGlzLm9uT3Blbih7XG4gICAgICAgICAgICBjb25uZWN0aW9uQ291bnQ6IHRoaXMuY29ubmVjdGlvbkNvdW50LFxuICAgICAgICAgICAgbGFzdENsb3NlUmVhc29uOiB0aGlzLmxhc3RDbG9zZVJlYXNvbixcbiAgICAgICAgICAgIGNsaWVudFRzOiBtb25vdG9uaWNNaWxsaXMoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc29ja2V0LnBhdXNlZCA9PT0gXCJ5ZXNcIikge1xuICAgICAgICAgIHRoaXMuc29ja2V0ID0geyAuLi50aGlzLnNvY2tldCwgcGF1c2VkOiBcIm5vXCIgfTtcbiAgICAgICAgICB0aGlzLm9uUmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcInRlcm1pbmF0ZWRcIjpcbiAgICAgIGNhc2UgXCJzdG9wcGVkXCI6XG4gICAgICBjYXNlIFwiZGlzY29ubmVjdGVkXCI6XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhpcy5zb2NrZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29ubmVjdCgpO1xuICB9XG4gIGNvbm5lY3Rpb25TdGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNDb25uZWN0ZWQ6IHRoaXMuc29ja2V0LnN0YXRlID09PSBcInJlYWR5XCIsXG4gICAgICBoYXNFdmVyQ29ubmVjdGVkOiB0aGlzLl9oYXNFdmVyQ29ubmVjdGVkLFxuICAgICAgY29ubmVjdGlvbkNvdW50OiB0aGlzLmNvbm5lY3Rpb25Db3VudCxcbiAgICAgIGNvbm5lY3Rpb25SZXRyaWVzOiB0aGlzLnJldHJpZXNcbiAgICB9O1xuICB9XG4gIF9sb2dWZXJib3NlKG1lc3NhZ2UpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2dWZXJib3NlKG1lc3NhZ2UpO1xuICB9XG4gIG5leHRCYWNrb2ZmKHJlYXNvbikge1xuICAgIGNvbnN0IGluaXRpYWxCYWNrb2ZmID0gcmVhc29uID09PSBcImNsaWVudFwiID8gMTAwIDogcmVhc29uID09PSBcIlVua25vd25cIiA/IHRoaXMuZGVmYXVsdEluaXRpYWxCYWNrb2ZmIDogc2VydmVyRGlzY29ubmVjdEVycm9yc1tyZWFzb25dLnRpbWVvdXQ7XG4gICAgY29uc3QgYmFzZUJhY2tvZmYgPSBpbml0aWFsQmFja29mZiAqIE1hdGgucG93KDIsIHRoaXMucmV0cmllcyk7XG4gICAgdGhpcy5yZXRyaWVzICs9IDE7XG4gICAgY29uc3QgYWN0dWFsQmFja29mZiA9IE1hdGgubWluKGJhc2VCYWNrb2ZmLCB0aGlzLm1heEJhY2tvZmYpO1xuICAgIGNvbnN0IGppdHRlciA9IGFjdHVhbEJhY2tvZmYgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSk7XG4gICAgcmV0dXJuIGFjdHVhbEJhY2tvZmYgKyBqaXR0ZXI7XG4gIH1cbiAgcmVwb3J0TGFyZ2VUcmFuc2l0aW9uKHtcbiAgICB0cmFuc2l0aW9uLFxuICAgIG1lc3NhZ2VMZW5ndGhcbiAgfSkge1xuICAgIGlmICh0cmFuc2l0aW9uLmNsaWVudENsb2NrU2tldyA9PT0gdm9pZCAwIHx8IHRyYW5zaXRpb24uc2VydmVyVHMgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2l0aW9uVHJhbnNpdFRpbWUgPSBtb25vdG9uaWNNaWxsaXMoKSAtIC8vIGNsaWVudCB0aW1lIG5vd1xuICAgIC8vIGNsaWVudENsb2NrU2tldyA9IChzZXJ2ZXIgdGltZSArIHVwc3RyZWFtIGxhdGVuY3kpIC0gY2xpZW50IHRpbWVcbiAgICAvLyBjbGllbnRDbG9ja1NrZXcgaXMgXCJob3cgbWFueSBtaWxsaXNlY29uZHMgYmVoaW5kIChzbG93KSBpcyB0aGUgY2xpZW50IGNsb2NrXCJcbiAgICAvLyBidXQgdGhlIGxhdGVuY3kgb2YgdGhlIENvbm5lY3QgbWVzc2FnZSBpbmZsYXRlcyB0aGlzLCBtYWtpbmcgaXQgYXBwZWFyIGZ1cnRoZXIgYmVoaW5kXG4gICAgdHJhbnNpdGlvbi5jbGllbnRDbG9ja1NrZXcgLSB0cmFuc2l0aW9uLnNlcnZlclRzIC8gMWU2O1xuICAgIGNvbnN0IHByZXR0eVRyYW5zaXRpb25UaW1lID0gYCR7TWF0aC5yb3VuZCh0cmFuc2l0aW9uVHJhbnNpdFRpbWUpfW1zYDtcbiAgICBjb25zdCBwcmV0dHlNZXNzYWdlTUIgPSBgJHtNYXRoLnJvdW5kKG1lc3NhZ2VMZW5ndGggLyAxZTQpIC8gMTAwfU1CYDtcbiAgICBjb25zdCBieXRlc1BlclNlY29uZCA9IG1lc3NhZ2VMZW5ndGggLyAodHJhbnNpdGlvblRyYW5zaXRUaW1lIC8gMWUzKTtcbiAgICBjb25zdCBwcmV0dHlCeXRlc1BlclNlY29uZCA9IGAke01hdGgucm91bmQoYnl0ZXNQZXJTZWNvbmQgLyAxZTQpIC8gMTAwfU1CIHBlciBzZWNvbmRgO1xuICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXG4gICAgICBgcmVjZWl2ZWQgJHtwcmV0dHlNZXNzYWdlTUJ9IHRyYW5zaXRpb24gaW4gJHtwcmV0dHlUcmFuc2l0aW9uVGltZX0gYXQgJHtwcmV0dHlCeXRlc1BlclNlY29uZH1gXG4gICAgKTtcbiAgICBpZiAobWVzc2FnZUxlbmd0aCA+IDJlNykge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgICBgcmVjZWl2ZWQgcXVlcnkgcmVzdWx0cyB0b3RhbGluZyBtb3JlIHRoYXQgMjBNQiAoJHtwcmV0dHlNZXNzYWdlTUJ9KSB3aGljaCB3aWxsIHRha2UgYSBsb25nIHRpbWUgdG8gZG93bmxvYWQgb24gc2xvd2VyIGNvbm5lY3Rpb25zYFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zaXRpb25UcmFuc2l0VGltZSA+IDJlNCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgICBgcmVjZWl2ZWQgcXVlcnkgcmVzdWx0cyB0b3RhbGluZyAke3ByZXR0eU1lc3NhZ2VNQn0gd2hpY2ggdG9vayBtb3JlIHRoYW4gMjBzIHRvIGFycml2ZSAoJHtwcmV0dHlUcmFuc2l0aW9uVGltZX0pYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBcIkV2ZW50XCIsXG4gICAgICAgIGV2ZW50VHlwZTogXCJDbGllbnRSZWNlaXZlZFRyYW5zaXRpb25cIixcbiAgICAgICAgZXZlbnQ6IHsgdHJhbnNpdGlvblRyYW5zaXRUaW1lLCBtZXNzYWdlTGVuZ3RoIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViX3NvY2tldF9tYW5hZ2VyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19kZWZOb3JtYWxQcm9wIiwib2JqIiwia2V5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX3B1YmxpY0ZpZWxkIiwiZW5jb2RlQ2xpZW50TWVzc2FnZSIsInBhcnNlU2VydmVyTWVzc2FnZSIsIkNMT1NFX05PUk1BTCIsIkNMT1NFX0dPSU5HX0FXQVkiLCJDTE9TRV9OT19TVEFUVVMiLCJDTE9TRV9OT1RfRk9VTkQiLCJmaXJzdFRpbWUiLCJtb25vdG9uaWNNaWxsaXMiLCJEYXRlIiwibm93IiwicGVyZm9ybWFuY2UiLCJNYXRoIiwicm91bmQiLCJwcmV0dHlOb3ciLCJzZXJ2ZXJEaXNjb25uZWN0RXJyb3JzIiwiSW50ZXJuYWxTZXJ2ZXJFcnJvciIsInRpbWVvdXQiLCJTdWJzY3JpcHRpb25zV29ya2VyRnVsbEVycm9yIiwiVG9vTWFueUNvbmN1cnJlbnRSZXF1ZXN0cyIsIkNvbW1pdHRlckZ1bGxFcnJvciIsIkF3c1Rvb01hbnlSZXF1ZXN0c0V4Y2VwdGlvbiIsIkV4ZWN1dGVGdWxsRXJyb3IiLCJTeXN0ZW1UaW1lb3V0RXJyb3IiLCJFeHBpcmVkSW5RdWV1ZSIsIlZlY3RvckluZGV4ZXNVbmF2YWlsYWJsZSIsIlNlYXJjaEluZGV4ZXNVbmF2YWlsYWJsZSIsIlRhYmxlU3VtbWFyaWVzVW5hdmFpbGFibGUiLCJWZWN0b3JJbmRleFRvb0xhcmdlIiwiU2VhcmNoSW5kZXhUb29MYXJnZSIsIlRvb01hbnlXcml0ZXNJblRpbWVQZXJpb2QiLCJjbGFzc2lmeURpc2Nvbm5lY3RFcnJvciIsInMiLCJwcmVmaXgiLCJrZXlzIiwic3RhcnRzV2l0aCIsIldlYlNvY2tldE1hbmFnZXIiLCJzZXRTb2NrZXRTdGF0ZSIsInN0YXRlIiwic29ja2V0IiwiX2xvZ1ZlcmJvc2UiLCJwYXVzZWQiLCJtYXJrQ29ubmVjdGlvblN0YXRlRGlydHkiLCJhc3NlbWJsZVRyYW5zaXRpb24iLCJjaHVuayIsInBhcnROdW1iZXIiLCJ0b3RhbFBhcnRzIiwidHJhbnNpdGlvbkNodW5rQnVmZmVyIiwidHJhbnNpdGlvbklkIiwiRXJyb3IiLCJjaHVua3MiLCJsZW5ndGgiLCJleHBlY3RlZExlbmd0aCIsInB1c2giLCJmdWxsSnNvbiIsImpvaW4iLCJ0cmFuc2l0aW9uIiwiSlNPTiIsInBhcnNlIiwidHlwZSIsImNvbm5lY3QiLCJ3cyIsIndlYlNvY2tldENvbnN0cnVjdG9yIiwidXJpIiwicmVzZXRTZXJ2ZXJJbmFjdGl2aXR5VGltZW91dCIsIm9ub3BlbiIsImxvZ2dlciIsImxvZ1ZlcmJvc2UiLCJfaGFzRXZlckNvbm5lY3RlZCIsIm9uT3BlbiIsImNvbm5lY3Rpb25Db3VudCIsImxhc3RDbG9zZVJlYXNvbiIsImNsaWVudFRzIiwibG9nIiwib25lcnJvciIsImVycm9yIiwibWVzc2FnZSIsIm9ubWVzc2FnZSIsIm1lc3NhZ2VMZW5ndGgiLCJkYXRhIiwic2VydmVyTWVzc2FnZSIsInJlcG9ydExhcmdlVHJhbnNpdGlvbiIsInJlc3BvbnNlIiwib25NZXNzYWdlIiwiaGFzU3luY2VkUGFzdExhc3RSZWNvbm5lY3QiLCJyZXRyaWVzIiwib25jbG9zZSIsImV2ZW50IiwicmVhc29uIiwiY29kZSIsIm1zZyIsIm9uU2VydmVyRGlzY29ubmVjdEVycm9yIiwic2NoZWR1bGVSZWNvbm5lY3QiLCJzb2NrZXRTdGF0ZSIsInNlbmRNZXNzYWdlIiwibWVzc2FnZUZvckxvZyIsInRva2VuVHlwZSIsInNsaWNlIiwiZW5jb2RlZE1lc3NhZ2UiLCJyZXF1ZXN0Iiwic3RyaW5naWZ5Iiwic2VudCIsInNlbmQiLCJjbG9zZUFuZFJlY29ubmVjdCIsInJlY29ubmVjdER1ZVRvU2VydmVySW5hY3Rpdml0eVRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0Iiwic2VydmVySW5hY3Rpdml0eVRocmVzaG9sZCIsImJhY2tvZmYiLCJuZXh0QmFja29mZiIsImNsb3NlUmVhc29uIiwiY2xvc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsIl9tZXNzYWdlIiwiciIsInJlc3VsdCIsInRlcm1pbmF0ZSIsInN0b3AiLCJ0cnlSZXN0YXJ0IiwicGF1c2UiLCJyZXN1bWUiLCJvblJlc3VtZSIsImNvbm5lY3Rpb25TdGF0ZSIsImlzQ29ubmVjdGVkIiwiaGFzRXZlckNvbm5lY3RlZCIsImNvbm5lY3Rpb25SZXRyaWVzIiwiaW5pdGlhbEJhY2tvZmYiLCJkZWZhdWx0SW5pdGlhbEJhY2tvZmYiLCJiYXNlQmFja29mZiIsInBvdyIsImFjdHVhbEJhY2tvZmYiLCJtaW4iLCJtYXhCYWNrb2ZmIiwiaml0dGVyIiwicmFuZG9tIiwiY2xpZW50Q2xvY2tTa2V3Iiwic2VydmVyVHMiLCJ0cmFuc2l0aW9uVHJhbnNpdFRpbWUiLCJwcmV0dHlUcmFuc2l0aW9uVGltZSIsInByZXR0eU1lc3NhZ2VNQiIsImJ5dGVzUGVyU2Vjb25kIiwicHJldHR5Qnl0ZXNQZXJTZWNvbmQiLCJkZWJ1ZyIsImV2ZW50VHlwZSIsImNvbnN0cnVjdG9yIiwiY2FsbGJhY2tzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/web_socket_manager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/common/index.js":
/*!******************************************************!*\
  !*** ./node_modules/convex/dist/esm/common/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isSimpleObject: function() { return /* binding */ isSimpleObject; },\n/* harmony export */   parseArgs: function() { return /* binding */ parseArgs; },\n/* harmony export */   validateDeploymentUrl: function() { return /* binding */ validateDeploymentUrl; }\n/* harmony export */ });\n\nfunction parseArgs(args) {\n    if (args === void 0) {\n        return {};\n    }\n    if (!isSimpleObject(args)) {\n        throw new Error(\"The arguments to a Convex function must be an object. Received: \".concat(args));\n    }\n    return args;\n}\nfunction validateDeploymentUrl(deploymentUrl) {\n    if (typeof deploymentUrl === \"undefined\") {\n        throw new Error(\"Client created with undefined deployment address. If you used an environment variable, check that it's set.\");\n    }\n    if (typeof deploymentUrl !== \"string\") {\n        throw new Error(\"Invalid deployment address: found \".concat(deploymentUrl, '\".'));\n    }\n    if (!(deploymentUrl.startsWith(\"http:\") || deploymentUrl.startsWith(\"https:\"))) {\n        throw new Error('Invalid deployment address: Must start with \"https://\" or \"http://\". Found \"'.concat(deploymentUrl, '\".'));\n    }\n    try {\n        new URL(deploymentUrl);\n    } catch (e) {\n        throw new Error('Invalid deployment address: \"'.concat(deploymentUrl, '\" is not a valid URL. If you believe this URL is correct, use the `skipConvexDeploymentUrlCheck` option to bypass this.'));\n    }\n    if (deploymentUrl.endsWith(\".convex.site\")) {\n        throw new Error('Invalid deployment address: \"'.concat(deploymentUrl, '\" ends with .convex.site, which is used for HTTP Actions. Convex deployment URLs typically end with .convex.cloud? If you believe this URL is correct, use the `skipConvexDeploymentUrlCheck` option to bypass this.'));\n    }\n}\nfunction isSimpleObject(value) {\n    var // Objects generated from other contexts (e.g. across Node.js `vm` modules) will not satisfy the previous\n    // conditions but are still simple objects.\n    _prototype_constructor;\n    const isObject = typeof value === \"object\";\n    const prototype = Object.getPrototypeOf(value);\n    const isSimple = prototype === null || prototype === Object.prototype || (prototype === null || prototype === void 0 ? void 0 : (_prototype_constructor = prototype.constructor) === null || _prototype_constructor === void 0 ? void 0 : _prototype_constructor.name) === \"Object\";\n    return isObject && isSimple;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vY29tbW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFhO0FBQ04sU0FBU0EsVUFBVUMsSUFBSTtJQUM1QixJQUFJQSxTQUFTLEtBQUssR0FBRztRQUNuQixPQUFPLENBQUM7SUFDVjtJQUNBLElBQUksQ0FBQ0MsZUFBZUQsT0FBTztRQUN6QixNQUFNLElBQUlFLE1BQ1IsbUVBQXdFLE9BQUxGO0lBRXZFO0lBQ0EsT0FBT0E7QUFDVDtBQUNPLFNBQVNHLHNCQUFzQkMsYUFBYTtJQUNqRCxJQUFJLE9BQU9BLGtCQUFrQixhQUFhO1FBQ3hDLE1BQU0sSUFBSUYsTUFDUDtJQUVMO0lBQ0EsSUFBSSxPQUFPRSxrQkFBa0IsVUFBVTtRQUNyQyxNQUFNLElBQUlGLE1BQ1IscUNBQW1ELE9BQWRFLGVBQWM7SUFFdkQ7SUFDQSxJQUFJLENBQUVBLENBQUFBLGNBQWNDLFVBQVUsQ0FBQyxZQUFZRCxjQUFjQyxVQUFVLENBQUMsU0FBUSxHQUFJO1FBQzlFLE1BQU0sSUFBSUgsTUFDUiwrRUFBNkYsT0FBZEUsZUFBYztJQUVqRztJQUNBLElBQUk7UUFDRixJQUFJRSxJQUFJRjtJQUNWLEVBQUUsVUFBTTtRQUNOLE1BQU0sSUFBSUYsTUFDUixnQ0FBOEMsT0FBZEUsZUFBYztJQUVsRDtJQUNBLElBQUlBLGNBQWNHLFFBQVEsQ0FBQyxpQkFBaUI7UUFDMUMsTUFBTSxJQUFJTCxNQUNSLGdDQUE4QyxPQUFkRSxlQUFjO0lBRWxEO0FBQ0Y7QUFDTyxTQUFTSCxlQUFlTyxLQUFLO1FBR3VDLHlHQUF5RztJQUNsTCwyQ0FBMkM7SUFDM0NDO0lBSkEsTUFBTUMsV0FBVyxPQUFPRixVQUFVO0lBQ2xDLE1BQU1DLFlBQVlFLE9BQU9DLGNBQWMsQ0FBQ0o7SUFDeEMsTUFBTUssV0FBV0osY0FBYyxRQUFRQSxjQUFjRSxPQUFPRixTQUFTLElBRXJFQSxDQUFBQSxzQkFBQUEsaUNBQUFBLHlCQUFBQSxVQUFXSyxXQUFXLGNBQXRCTCw2Q0FBQUEsdUJBQXdCTSxJQUFJLE1BQUs7SUFDakMsT0FBT0wsWUFBWUc7QUFDckIsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9jb21tb24vaW5kZXguanM/YjMxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUFyZ3MoYXJncykge1xuICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGlmICghaXNTaW1wbGVPYmplY3QoYXJncykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVGhlIGFyZ3VtZW50cyB0byBhIENvbnZleCBmdW5jdGlvbiBtdXN0IGJlIGFuIG9iamVjdC4gUmVjZWl2ZWQ6ICR7YXJnc31gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYXJncztcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZURlcGxveW1lbnRVcmwoZGVwbG95bWVudFVybCkge1xuICBpZiAodHlwZW9mIGRlcGxveW1lbnRVcmwgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2xpZW50IGNyZWF0ZWQgd2l0aCB1bmRlZmluZWQgZGVwbG95bWVudCBhZGRyZXNzLiBJZiB5b3UgdXNlZCBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZSwgY2hlY2sgdGhhdCBpdCdzIHNldC5gXG4gICAgKTtcbiAgfVxuICBpZiAodHlwZW9mIGRlcGxveW1lbnRVcmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBkZXBsb3ltZW50IGFkZHJlc3M6IGZvdW5kICR7ZGVwbG95bWVudFVybH1cIi5gXG4gICAgKTtcbiAgfVxuICBpZiAoIShkZXBsb3ltZW50VXJsLnN0YXJ0c1dpdGgoXCJodHRwOlwiKSB8fCBkZXBsb3ltZW50VXJsLnN0YXJ0c1dpdGgoXCJodHRwczpcIikpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgZGVwbG95bWVudCBhZGRyZXNzOiBNdXN0IHN0YXJ0IHdpdGggXCJodHRwczovL1wiIG9yIFwiaHR0cDovL1wiLiBGb3VuZCBcIiR7ZGVwbG95bWVudFVybH1cIi5gXG4gICAgKTtcbiAgfVxuICB0cnkge1xuICAgIG5ldyBVUkwoZGVwbG95bWVudFVybCk7XG4gIH0gY2F0Y2gge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIGRlcGxveW1lbnQgYWRkcmVzczogXCIke2RlcGxveW1lbnRVcmx9XCIgaXMgbm90IGEgdmFsaWQgVVJMLiBJZiB5b3UgYmVsaWV2ZSB0aGlzIFVSTCBpcyBjb3JyZWN0LCB1c2UgdGhlIFxcYHNraXBDb252ZXhEZXBsb3ltZW50VXJsQ2hlY2tcXGAgb3B0aW9uIHRvIGJ5cGFzcyB0aGlzLmBcbiAgICApO1xuICB9XG4gIGlmIChkZXBsb3ltZW50VXJsLmVuZHNXaXRoKFwiLmNvbnZleC5zaXRlXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgZGVwbG95bWVudCBhZGRyZXNzOiBcIiR7ZGVwbG95bWVudFVybH1cIiBlbmRzIHdpdGggLmNvbnZleC5zaXRlLCB3aGljaCBpcyB1c2VkIGZvciBIVFRQIEFjdGlvbnMuIENvbnZleCBkZXBsb3ltZW50IFVSTHMgdHlwaWNhbGx5IGVuZCB3aXRoIC5jb252ZXguY2xvdWQ/IElmIHlvdSBiZWxpZXZlIHRoaXMgVVJMIGlzIGNvcnJlY3QsIHVzZSB0aGUgXFxgc2tpcENvbnZleERlcGxveW1lbnRVcmxDaGVja1xcYCBvcHRpb24gdG8gYnlwYXNzIHRoaXMuYFxuICAgICk7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1NpbXBsZU9iamVjdCh2YWx1ZSkge1xuICBjb25zdCBpc09iamVjdCA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgY29uc3QgaXNTaW1wbGUgPSBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlIHx8IC8vIE9iamVjdHMgZ2VuZXJhdGVkIGZyb20gb3RoZXIgY29udGV4dHMgKGUuZy4gYWNyb3NzIE5vZGUuanMgYHZtYCBtb2R1bGVzKSB3aWxsIG5vdCBzYXRpc2Z5IHRoZSBwcmV2aW91c1xuICAvLyBjb25kaXRpb25zIGJ1dCBhcmUgc3RpbGwgc2ltcGxlIG9iamVjdHMuXG4gIHByb3RvdHlwZT8uY29uc3RydWN0b3I/Lm5hbWUgPT09IFwiT2JqZWN0XCI7XG4gIHJldHVybiBpc09iamVjdCAmJiBpc1NpbXBsZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbInBhcnNlQXJncyIsImFyZ3MiLCJpc1NpbXBsZU9iamVjdCIsIkVycm9yIiwidmFsaWRhdGVEZXBsb3ltZW50VXJsIiwiZGVwbG95bWVudFVybCIsInN0YXJ0c1dpdGgiLCJVUkwiLCJlbmRzV2l0aCIsInZhbHVlIiwicHJvdG90eXBlIiwiaXNPYmplY3QiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsImlzU2ltcGxlIiwiY29uc3RydWN0b3IiLCJuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/common/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/index.js":
/*!***********************************************!*\
  !*** ./node_modules/convex/dist/esm/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: function() { return /* binding */ version; }\n/* harmony export */ });\n\nconst version = \"1.30.0\"; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFhO0FBQ04sTUFBTUEsVUFBVSxTQUFTLENBQ2hDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL2luZGV4LmpzP2RhODQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiMS4zMC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/react/ConvexAuthState.js":
/*!***************************************************************!*\
  !*** ./node_modules/convex/dist/esm/react/ConvexAuthState.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConvexProviderWithAuth: function() { return /* binding */ ConvexProviderWithAuth; },\n/* harmony export */   useConvexAuth: function() { return /* binding */ useConvexAuth; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/client.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$();\n\"use strict\";\n\n\nconst ConvexAuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nfunction useConvexAuth() {\n    _s();\n    const authContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ConvexAuthContext);\n    if (authContext === void 0) {\n        throw new Error(\"Could not find `ConvexProviderWithAuth` (or `ConvexProviderWithClerk` or `ConvexProviderWithAuth0`) as an ancestor component. This component may be missing, or you might have two instances of the `convex/react` module loaded in your project.\");\n    }\n    return authContext;\n}\n_s(useConvexAuth, \"g0q6N3HTsGa67OokMUhTOzE2a0M=\");\nfunction ConvexProviderWithAuth(param) {\n    let { children, client, useAuth } = param;\n    _s1();\n    const { isLoading: authProviderLoading, isAuthenticated: authProviderAuthenticated, fetchAccessToken } = useAuth();\n    const [isConvexAuthenticated, setIsConvexAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    if (authProviderLoading && isConvexAuthenticated !== null) {\n        setIsConvexAuthenticated(null);\n    }\n    if (!authProviderLoading && !authProviderAuthenticated && isConvexAuthenticated !== false) {\n        setIsConvexAuthenticated(false);\n    }\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConvexAuthContext.Provider, {\n        value: {\n            isLoading: isConvexAuthenticated === null,\n            isAuthenticated: authProviderAuthenticated && (isConvexAuthenticated !== null && isConvexAuthenticated !== void 0 ? isConvexAuthenticated : false)\n        }\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConvexAuthStateFirstEffect, {\n        authProviderAuthenticated,\n        fetchAccessToken,\n        authProviderLoading,\n        client,\n        setIsConvexAuthenticated\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_client_js__WEBPACK_IMPORTED_MODULE_1__.ConvexProvider, {\n        client\n    }, children), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConvexAuthStateLastEffect, {\n        authProviderAuthenticated,\n        fetchAccessToken,\n        authProviderLoading,\n        client,\n        setIsConvexAuthenticated\n    }));\n}\n_s1(ConvexProviderWithAuth, \"D20z1SCpibgpNx97TxM5hJ0TIGI=\", true);\n_c = ConvexProviderWithAuth;\nfunction ConvexAuthStateFirstEffect(param) {\n    let { authProviderAuthenticated, fetchAccessToken, authProviderLoading, client, setIsConvexAuthenticated } = param;\n    _s2();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let isThisEffectRelevant = true;\n        if (authProviderAuthenticated) {\n            client.setAuth(fetchAccessToken, (backendReportsIsAuthenticated)=>{\n                if (isThisEffectRelevant) {\n                    setIsConvexAuthenticated(()=>backendReportsIsAuthenticated);\n                }\n            });\n            return ()=>{\n                isThisEffectRelevant = false;\n                setIsConvexAuthenticated((isConvexAuthenticated)=>isConvexAuthenticated ? false : null);\n            };\n        }\n    }, [\n        authProviderAuthenticated,\n        fetchAccessToken,\n        authProviderLoading,\n        client,\n        setIsConvexAuthenticated\n    ]);\n    return null;\n}\n_s2(ConvexAuthStateFirstEffect, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c1 = ConvexAuthStateFirstEffect;\nfunction ConvexAuthStateLastEffect(param) {\n    let { authProviderAuthenticated, fetchAccessToken, authProviderLoading, client, setIsConvexAuthenticated } = param;\n    _s3();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (authProviderAuthenticated) {\n            return ()=>{\n                client.clearAuth();\n                setIsConvexAuthenticated(()=>null);\n            };\n        }\n    }, [\n        authProviderAuthenticated,\n        fetchAccessToken,\n        authProviderLoading,\n        client,\n        setIsConvexAuthenticated\n    ]);\n    return null;\n} //# sourceMappingURL=ConvexAuthState.js.map\n_s3(ConvexAuthStateLastEffect, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c2 = ConvexAuthStateLastEffect;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"ConvexProviderWithAuth\");\n$RefreshReg$(_c1, \"ConvexAuthStateFirstEffect\");\n$RefreshReg$(_c2, \"ConvexAuthStateLastEffect\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vcmVhY3QvQ29udmV4QXV0aFN0YXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFNZTtBQUM4QjtBQUM3QyxNQUFNTSxrQ0FBb0JMLG9EQUFhQSxDQUFDLEtBQUs7QUFDdEMsU0FBU007O0lBQ2QsTUFBTUMsY0FBY04saURBQVVBLENBQUNJO0lBQy9CLElBQUlFLGdCQUFnQixLQUFLLEdBQUc7UUFDMUIsTUFBTSxJQUFJQyxNQUNSO0lBRUo7SUFDQSxPQUFPRDtBQUNUO0dBUmdCRDtBQVNULFNBQVNHLHVCQUF1QixLQUl0QztRQUpzQyxFQUNyQ0MsUUFBUSxFQUNSQyxNQUFNLEVBQ05DLE9BQU8sRUFDUixHQUpzQzs7SUFLckMsTUFBTSxFQUNKQyxXQUFXQyxtQkFBbUIsRUFDOUJDLGlCQUFpQkMseUJBQXlCLEVBQzFDQyxnQkFBZ0IsRUFDakIsR0FBR0w7SUFDSixNQUFNLENBQUNNLHVCQUF1QkMseUJBQXlCLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUNuRSxJQUFJVyx1QkFBdUJJLDBCQUEwQixNQUFNO1FBQ3pEQyx5QkFBeUI7SUFDM0I7SUFDQSxJQUFJLENBQUNMLHVCQUF1QixDQUFDRSw2QkFBNkJFLDBCQUEwQixPQUFPO1FBQ3pGQyx5QkFBeUI7SUFDM0I7SUFDQSxPQUFPLGFBQWEsaUJBQUdwQixnREFBbUIsQ0FDeENNLGtCQUFrQmdCLFFBQVEsRUFDMUI7UUFDRUMsT0FBTztZQUNMVCxXQUFXSywwQkFBMEI7WUFDckNILGlCQUFpQkMsNkJBQThCRSxDQUFBQSxrQ0FBQUEsbUNBQUFBLHdCQUF5QixLQUFJO1FBQzlFO0lBQ0YsR0FDQSxhQUFhLGlCQUFHbkIsZ0RBQW1CLENBQ2pDd0IsNEJBQ0E7UUFDRVA7UUFDQUM7UUFDQUg7UUFDQUg7UUFDQVE7SUFDRixJQUVGLGFBQWEsaUJBQUdwQixnREFBbUIsQ0FBQ0ssc0RBQWNBLEVBQUU7UUFBRU87SUFBTyxHQUFHRCxXQUNoRSxhQUFhLGlCQUFHWCxnREFBbUIsQ0FDakN5QiwyQkFDQTtRQUNFUjtRQUNBQztRQUNBSDtRQUNBSDtRQUNBUTtJQUNGO0FBR047SUEvQ2dCVjtLQUFBQTtBQWdEaEIsU0FBU2MsMkJBQTJCLEtBTW5DO1FBTm1DLEVBQ2xDUCx5QkFBeUIsRUFDekJDLGdCQUFnQixFQUNoQkgsbUJBQW1CLEVBQ25CSCxNQUFNLEVBQ05RLHdCQUF3QixFQUN6QixHQU5tQzs7SUFPbENqQixnREFBU0EsQ0FBQztRQUNSLElBQUl1Qix1QkFBdUI7UUFDM0IsSUFBSVQsMkJBQTJCO1lBQzdCTCxPQUFPZSxPQUFPLENBQUNULGtCQUFrQixDQUFDVTtnQkFDaEMsSUFBSUYsc0JBQXNCO29CQUN4Qk4seUJBQXlCLElBQU1RO2dCQUNqQztZQUNGO1lBQ0EsT0FBTztnQkFDTEYsdUJBQXVCO2dCQUN2Qk4seUJBQ0UsQ0FBQ0Qsd0JBQTBCQSx3QkFBd0IsUUFBUTtZQUUvRDtRQUNGO0lBQ0YsR0FBRztRQUNERjtRQUNBQztRQUNBSDtRQUNBSDtRQUNBUTtLQUNEO0lBQ0QsT0FBTztBQUNUO0lBOUJTSTtNQUFBQTtBQStCVCxTQUFTQywwQkFBMEIsS0FNbEM7UUFOa0MsRUFDakNSLHlCQUF5QixFQUN6QkMsZ0JBQWdCLEVBQ2hCSCxtQkFBbUIsRUFDbkJILE1BQU0sRUFDTlEsd0JBQXdCLEVBQ3pCLEdBTmtDOztJQU9qQ2pCLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSWMsMkJBQTJCO1lBQzdCLE9BQU87Z0JBQ0xMLE9BQU9pQixTQUFTO2dCQUNoQlQseUJBQXlCLElBQU07WUFDakM7UUFDRjtJQUNGLEdBQUc7UUFDREg7UUFDQUM7UUFDQUg7UUFDQUg7UUFDQVE7S0FDRDtJQUNELE9BQU87QUFDVCxFQUNBLDJDQUEyQztJQXZCbENLO01BQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vcmVhY3QvQ29udmV4QXV0aFN0YXRlLmpzP2NhYTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgUmVhY3QsIHtcbiAgY3JlYXRlQ29udGV4dCxcbiAgdXNlQ29udGV4dCxcbiAgdXNlRWZmZWN0LFxuICB1c2VTdGF0ZVxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IENvbnZleFByb3ZpZGVyIH0gZnJvbSBcIi4vY2xpZW50LmpzXCI7XG5jb25zdCBDb252ZXhBdXRoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbmV4cG9ydCBmdW5jdGlvbiB1c2VDb252ZXhBdXRoKCkge1xuICBjb25zdCBhdXRoQ29udGV4dCA9IHVzZUNvbnRleHQoQ29udmV4QXV0aENvbnRleHQpO1xuICBpZiAoYXV0aENvbnRleHQgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiQ291bGQgbm90IGZpbmQgYENvbnZleFByb3ZpZGVyV2l0aEF1dGhgIChvciBgQ29udmV4UHJvdmlkZXJXaXRoQ2xlcmtgIG9yIGBDb252ZXhQcm92aWRlcldpdGhBdXRoMGApIGFzIGFuIGFuY2VzdG9yIGNvbXBvbmVudC4gVGhpcyBjb21wb25lbnQgbWF5IGJlIG1pc3NpbmcsIG9yIHlvdSBtaWdodCBoYXZlIHR3byBpbnN0YW5jZXMgb2YgdGhlIGBjb252ZXgvcmVhY3RgIG1vZHVsZSBsb2FkZWQgaW4geW91ciBwcm9qZWN0LlwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYXV0aENvbnRleHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gQ29udmV4UHJvdmlkZXJXaXRoQXV0aCh7XG4gIGNoaWxkcmVuLFxuICBjbGllbnQsXG4gIHVzZUF1dGhcbn0pIHtcbiAgY29uc3Qge1xuICAgIGlzTG9hZGluZzogYXV0aFByb3ZpZGVyTG9hZGluZyxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IGF1dGhQcm92aWRlckF1dGhlbnRpY2F0ZWQsXG4gICAgZmV0Y2hBY2Nlc3NUb2tlblxuICB9ID0gdXNlQXV0aCgpO1xuICBjb25zdCBbaXNDb252ZXhBdXRoZW50aWNhdGVkLCBzZXRJc0NvbnZleEF1dGhlbnRpY2F0ZWRdID0gdXNlU3RhdGUobnVsbCk7XG4gIGlmIChhdXRoUHJvdmlkZXJMb2FkaW5nICYmIGlzQ29udmV4QXV0aGVudGljYXRlZCAhPT0gbnVsbCkge1xuICAgIHNldElzQ29udmV4QXV0aGVudGljYXRlZChudWxsKTtcbiAgfVxuICBpZiAoIWF1dGhQcm92aWRlckxvYWRpbmcgJiYgIWF1dGhQcm92aWRlckF1dGhlbnRpY2F0ZWQgJiYgaXNDb252ZXhBdXRoZW50aWNhdGVkICE9PSBmYWxzZSkge1xuICAgIHNldElzQ29udmV4QXV0aGVudGljYXRlZChmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIENvbnZleEF1dGhDb250ZXh0LlByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGlzTG9hZGluZzogaXNDb252ZXhBdXRoZW50aWNhdGVkID09PSBudWxsLFxuICAgICAgICBpc0F1dGhlbnRpY2F0ZWQ6IGF1dGhQcm92aWRlckF1dGhlbnRpY2F0ZWQgJiYgKGlzQ29udmV4QXV0aGVudGljYXRlZCA/PyBmYWxzZSlcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgQ29udmV4QXV0aFN0YXRlRmlyc3RFZmZlY3QsXG4gICAgICB7XG4gICAgICAgIGF1dGhQcm92aWRlckF1dGhlbnRpY2F0ZWQsXG4gICAgICAgIGZldGNoQWNjZXNzVG9rZW4sXG4gICAgICAgIGF1dGhQcm92aWRlckxvYWRpbmcsXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAgc2V0SXNDb252ZXhBdXRoZW50aWNhdGVkXG4gICAgICB9XG4gICAgKSxcbiAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb252ZXhQcm92aWRlciwgeyBjbGllbnQgfSwgY2hpbGRyZW4pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgQ29udmV4QXV0aFN0YXRlTGFzdEVmZmVjdCxcbiAgICAgIHtcbiAgICAgICAgYXV0aFByb3ZpZGVyQXV0aGVudGljYXRlZCxcbiAgICAgICAgZmV0Y2hBY2Nlc3NUb2tlbixcbiAgICAgICAgYXV0aFByb3ZpZGVyTG9hZGluZyxcbiAgICAgICAgY2xpZW50LFxuICAgICAgICBzZXRJc0NvbnZleEF1dGhlbnRpY2F0ZWRcbiAgICAgIH1cbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBDb252ZXhBdXRoU3RhdGVGaXJzdEVmZmVjdCh7XG4gIGF1dGhQcm92aWRlckF1dGhlbnRpY2F0ZWQsXG4gIGZldGNoQWNjZXNzVG9rZW4sXG4gIGF1dGhQcm92aWRlckxvYWRpbmcsXG4gIGNsaWVudCxcbiAgc2V0SXNDb252ZXhBdXRoZW50aWNhdGVkXG59KSB7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGlzVGhpc0VmZmVjdFJlbGV2YW50ID0gdHJ1ZTtcbiAgICBpZiAoYXV0aFByb3ZpZGVyQXV0aGVudGljYXRlZCkge1xuICAgICAgY2xpZW50LnNldEF1dGgoZmV0Y2hBY2Nlc3NUb2tlbiwgKGJhY2tlbmRSZXBvcnRzSXNBdXRoZW50aWNhdGVkKSA9PiB7XG4gICAgICAgIGlmIChpc1RoaXNFZmZlY3RSZWxldmFudCkge1xuICAgICAgICAgIHNldElzQ29udmV4QXV0aGVudGljYXRlZCgoKSA9PiBiYWNrZW5kUmVwb3J0c0lzQXV0aGVudGljYXRlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaXNUaGlzRWZmZWN0UmVsZXZhbnQgPSBmYWxzZTtcbiAgICAgICAgc2V0SXNDb252ZXhBdXRoZW50aWNhdGVkKFxuICAgICAgICAgIChpc0NvbnZleEF1dGhlbnRpY2F0ZWQpID0+IGlzQ29udmV4QXV0aGVudGljYXRlZCA/IGZhbHNlIDogbnVsbFxuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtcbiAgICBhdXRoUHJvdmlkZXJBdXRoZW50aWNhdGVkLFxuICAgIGZldGNoQWNjZXNzVG9rZW4sXG4gICAgYXV0aFByb3ZpZGVyTG9hZGluZyxcbiAgICBjbGllbnQsXG4gICAgc2V0SXNDb252ZXhBdXRoZW50aWNhdGVkXG4gIF0pO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIENvbnZleEF1dGhTdGF0ZUxhc3RFZmZlY3Qoe1xuICBhdXRoUHJvdmlkZXJBdXRoZW50aWNhdGVkLFxuICBmZXRjaEFjY2Vzc1Rva2VuLFxuICBhdXRoUHJvdmlkZXJMb2FkaW5nLFxuICBjbGllbnQsXG4gIHNldElzQ29udmV4QXV0aGVudGljYXRlZFxufSkge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChhdXRoUHJvdmlkZXJBdXRoZW50aWNhdGVkKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGllbnQuY2xlYXJBdXRoKCk7XG4gICAgICAgIHNldElzQ29udmV4QXV0aGVudGljYXRlZCgoKSA9PiBudWxsKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbXG4gICAgYXV0aFByb3ZpZGVyQXV0aGVudGljYXRlZCxcbiAgICBmZXRjaEFjY2Vzc1Rva2VuLFxuICAgIGF1dGhQcm92aWRlckxvYWRpbmcsXG4gICAgY2xpZW50LFxuICAgIHNldElzQ29udmV4QXV0aGVudGljYXRlZFxuICBdKTtcbiAgcmV0dXJuIG51bGw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db252ZXhBdXRoU3RhdGUuanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiQ29udmV4UHJvdmlkZXIiLCJDb252ZXhBdXRoQ29udGV4dCIsInVzZUNvbnZleEF1dGgiLCJhdXRoQ29udGV4dCIsIkVycm9yIiwiQ29udmV4UHJvdmlkZXJXaXRoQXV0aCIsImNoaWxkcmVuIiwiY2xpZW50IiwidXNlQXV0aCIsImlzTG9hZGluZyIsImF1dGhQcm92aWRlckxvYWRpbmciLCJpc0F1dGhlbnRpY2F0ZWQiLCJhdXRoUHJvdmlkZXJBdXRoZW50aWNhdGVkIiwiZmV0Y2hBY2Nlc3NUb2tlbiIsImlzQ29udmV4QXV0aGVudGljYXRlZCIsInNldElzQ29udmV4QXV0aGVudGljYXRlZCIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInZhbHVlIiwiQ29udmV4QXV0aFN0YXRlRmlyc3RFZmZlY3QiLCJDb252ZXhBdXRoU3RhdGVMYXN0RWZmZWN0IiwiaXNUaGlzRWZmZWN0UmVsZXZhbnQiLCJzZXRBdXRoIiwiYmFja2VuZFJlcG9ydHNJc0F1dGhlbnRpY2F0ZWQiLCJjbGVhckF1dGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/react/ConvexAuthState.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/react/auth_helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/convex/dist/esm/react/auth_helpers.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthLoading: function() { return /* binding */ AuthLoading; },\n/* harmony export */   Authenticated: function() { return /* binding */ Authenticated; },\n/* harmony export */   Unauthenticated: function() { return /* binding */ Unauthenticated; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _ConvexAuthState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConvexAuthState.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/ConvexAuthState.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n\"use strict\";\n\n\nfunction Authenticated(param) {\n    let { children } = param;\n    _s();\n    const { isLoading, isAuthenticated } = (0,_ConvexAuthState_js__WEBPACK_IMPORTED_MODULE_1__.useConvexAuth)();\n    if (isLoading || !isAuthenticated) {\n        return null;\n    }\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children);\n}\n_s(Authenticated, \"5GGv9MEKRHHdPWj3ryepReKJmLE=\", false, function() {\n    return [\n        _ConvexAuthState_js__WEBPACK_IMPORTED_MODULE_1__.useConvexAuth\n    ];\n});\n_c = Authenticated;\nfunction Unauthenticated(param) {\n    let { children } = param;\n    _s1();\n    const { isLoading, isAuthenticated } = (0,_ConvexAuthState_js__WEBPACK_IMPORTED_MODULE_1__.useConvexAuth)();\n    if (isLoading || isAuthenticated) {\n        return null;\n    }\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children);\n}\n_s1(Unauthenticated, \"5GGv9MEKRHHdPWj3ryepReKJmLE=\", false, function() {\n    return [\n        _ConvexAuthState_js__WEBPACK_IMPORTED_MODULE_1__.useConvexAuth\n    ];\n});\n_c1 = Unauthenticated;\nfunction AuthLoading(param) {\n    let { children } = param;\n    _s2();\n    const { isLoading } = (0,_ConvexAuthState_js__WEBPACK_IMPORTED_MODULE_1__.useConvexAuth)();\n    if (!isLoading) {\n        return null;\n    }\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children);\n} //# sourceMappingURL=auth_helpers.js.map\n_s2(AuthLoading, \"T4P/uFnMPA7P+2KU5NWFLnzfLbw=\", false, function() {\n    return [\n        _ConvexAuthState_js__WEBPACK_IMPORTED_MODULE_1__.useConvexAuth\n    ];\n});\n_c2 = AuthLoading;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"Authenticated\");\n$RefreshReg$(_c1, \"Unauthenticated\");\n$RefreshReg$(_c2, \"AuthLoading\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vcmVhY3QvYXV0aF9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQzBCO0FBQzJCO0FBQzlDLFNBQVNFLGNBQWMsS0FBWTtRQUFaLEVBQUVDLFFBQVEsRUFBRSxHQUFaOztJQUM1QixNQUFNLEVBQUVDLFNBQVMsRUFBRUMsZUFBZSxFQUFFLEdBQUdKLGtFQUFhQTtJQUNwRCxJQUFJRyxhQUFhLENBQUNDLGlCQUFpQjtRQUNqQyxPQUFPO0lBQ1Q7SUFDQSxPQUFPLGFBQWEsaUJBQUdMLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFLE1BQU1HO0FBQ25FO0dBTmdCRDs7UUFDeUJELDhEQUFhQTs7O0tBRHRDQztBQU9ULFNBQVNNLGdCQUFnQixLQUFZO1FBQVosRUFBRUwsUUFBUSxFQUFFLEdBQVo7O0lBQzlCLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxlQUFlLEVBQUUsR0FBR0osa0VBQWFBO0lBQ3BELElBQUlHLGFBQWFDLGlCQUFpQjtRQUNoQyxPQUFPO0lBQ1Q7SUFDQSxPQUFPLGFBQWEsaUJBQUdMLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFLE1BQU1HO0FBQ25FO0lBTmdCSzs7UUFDeUJQLDhEQUFhQTs7O01BRHRDTztBQU9ULFNBQVNDLFlBQVksS0FBWTtRQUFaLEVBQUVOLFFBQVEsRUFBRSxHQUFaOztJQUMxQixNQUFNLEVBQUVDLFNBQVMsRUFBRSxHQUFHSCxrRUFBYUE7SUFDbkMsSUFBSSxDQUFDRyxXQUFXO1FBQ2QsT0FBTztJQUNUO0lBQ0EsT0FBTyxhQUFhLGlCQUFHSixnREFBbUIsQ0FBQ0EsMkNBQWMsRUFBRSxNQUFNRztBQUNuRSxFQUNBLHdDQUF3QztJQVB4Qk07O1FBQ1FSLDhEQUFhQTs7O01BRHJCUSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3JlYWN0L2F1dGhfaGVscGVycy5qcz9hMmRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ29udmV4QXV0aCB9IGZyb20gXCIuL0NvbnZleEF1dGhTdGF0ZS5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIEF1dGhlbnRpY2F0ZWQoeyBjaGlsZHJlbiB9KSB7XG4gIGNvbnN0IHsgaXNMb2FkaW5nLCBpc0F1dGhlbnRpY2F0ZWQgfSA9IHVzZUNvbnZleEF1dGgoKTtcbiAgaWYgKGlzTG9hZGluZyB8fCAhaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59XG5leHBvcnQgZnVuY3Rpb24gVW5hdXRoZW50aWNhdGVkKHsgY2hpbGRyZW4gfSkge1xuICBjb25zdCB7IGlzTG9hZGluZywgaXNBdXRoZW50aWNhdGVkIH0gPSB1c2VDb252ZXhBdXRoKCk7XG4gIGlmIChpc0xvYWRpbmcgfHwgaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59XG5leHBvcnQgZnVuY3Rpb24gQXV0aExvYWRpbmcoeyBjaGlsZHJlbiB9KSB7XG4gIGNvbnN0IHsgaXNMb2FkaW5nIH0gPSB1c2VDb252ZXhBdXRoKCk7XG4gIGlmICghaXNMb2FkaW5nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRoX2hlbHBlcnMuanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VDb252ZXhBdXRoIiwiQXV0aGVudGljYXRlZCIsImNoaWxkcmVuIiwiaXNMb2FkaW5nIiwiaXNBdXRoZW50aWNhdGVkIiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwiVW5hdXRoZW50aWNhdGVkIiwiQXV0aExvYWRpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/react/auth_helpers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/react/client.js":
/*!******************************************************!*\
  !*** ./node_modules/convex/dist/esm/react/client.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConvexProvider: function() { return /* binding */ ConvexProvider; },\n/* harmony export */   ConvexReactClient: function() { return /* binding */ ConvexReactClient; },\n/* harmony export */   createMutation: function() { return /* binding */ createMutation; },\n/* harmony export */   useAction: function() { return /* binding */ useAction; },\n/* harmony export */   useConvex: function() { return /* binding */ useConvex; },\n/* harmony export */   useConvexConnectionState: function() { return /* binding */ useConvexConnectionState; },\n/* harmony export */   useMutation: function() { return /* binding */ useMutation; },\n/* harmony export */   useQuery: function() { return /* binding */ useQuery; }\n/* harmony export */ });\n/* harmony import */ var _browser_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../browser/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _values_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../values/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/index.js\");\n/* harmony import */ var _use_queries_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./use_queries.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/use_queries.js\");\n/* harmony import */ var _use_subscription_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./use_subscription.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/use_subscription.js\");\n/* harmony import */ var _common_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/common/index.js\");\n/* harmony import */ var _server_api_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../server/api.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/server/api.js\");\n/* harmony import */ var _browser_logging_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../browser/logging.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/logging.js\");\n/* harmony import */ var _browser_sync_paginated_query_client_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../browser/sync/paginated_query_client.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/browser/sync/paginated_query_client.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$();\n\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n\n\n\n\n\n\n\n\nconst DEFAULT_EXTEND_SUBSCRIPTION_FOR = 5e3;\nif (typeof react__WEBPACK_IMPORTED_MODULE_1__ === \"undefined\") {\n    throw new Error(\"Required dependency 'react' not found\");\n}\nfunction createMutation(mutationReference, client, update) {\n    function mutation(args) {\n        assertNotAccidentalArgument(args);\n        return client.mutation(mutationReference, args, {\n            optimisticUpdate: update\n        });\n    }\n    mutation.withOptimisticUpdate = function withOptimisticUpdate(optimisticUpdate) {\n        if (update !== void 0) {\n            throw new Error(\"Already specified optimistic update for mutation \".concat((0,_server_api_js__WEBPACK_IMPORTED_MODULE_6__.getFunctionName)(mutationReference)));\n        }\n        return createMutation(mutationReference, client, optimisticUpdate);\n    };\n    return mutation;\n}\nfunction createAction(actionReference, client) {\n    return function(args) {\n        return client.action(actionReference, args);\n    };\n}\nclass ConvexReactClient {\n    /**\n   * Return the address for this client, useful for creating a new client.\n   *\n   * Not guaranteed to match the address with which this client was constructed:\n   * it may be canonicalized.\n   */ get url() {\n        return this.address;\n    }\n    /**\n   * Lazily instantiate the `BaseConvexClient` so we don't create the WebSocket\n   * when server-side rendering.\n   *\n   * @internal\n   */ get sync() {\n        if (this.closed) {\n            throw new Error(\"ConvexReactClient has already been closed.\");\n        }\n        if (this.cachedSync) {\n            return this.cachedSync;\n        }\n        this.cachedSync = new _browser_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseConvexClient(this.address, ()=>{}, // Use the PaginatedQueryClient's transition instead.\n        this.options);\n        if (this.adminAuth) {\n            this.cachedSync.setAdminAuth(this.adminAuth, this.fakeUserIdentity);\n        }\n        this.cachedPaginatedQueryClient = new _browser_sync_paginated_query_client_js__WEBPACK_IMPORTED_MODULE_8__.PaginatedQueryClient(this.cachedSync, (transition)=>this.handleTransition(transition));\n        return this.cachedSync;\n    }\n    /**\n   * Lazily instantiate the `PaginatedQueryClient` so we don't create it\n   * when server-side rendering.\n   *\n   * @internal\n   */ get paginatedQueryClient() {\n        this.sync;\n        if (this.cachedPaginatedQueryClient) {\n            return this.cachedPaginatedQueryClient;\n        }\n        throw new Error(\"Should already be instantiated\");\n    }\n    /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   * `fetchToken` will be called automatically again if a token expires.\n   * `fetchToken` should return `null` if the token cannot be retrieved, for example\n   * when the user's rights were permanently revoked.\n   * @param fetchToken - an async function returning the JWT-encoded OpenID Connect Identity Token\n   * @param onChange - a callback that will be called when the authentication status changes\n   */ setAuth(fetchToken, onChange) {\n        if (typeof fetchToken === \"string\") {\n            throw new Error(\"Passing a string to ConvexReactClient.setAuth is no longer supported, please upgrade to passing in an async function to handle reauthentication.\");\n        }\n        this.sync.setAuth(fetchToken, onChange !== null && onChange !== void 0 ? onChange : ()=>{});\n    }\n    /**\n   * Clear the current authentication token if set.\n   */ clearAuth() {\n        this.sync.clearAuth();\n    }\n    /**\n   * @internal\n   */ setAdminAuth(token, identity) {\n        this.adminAuth = token;\n        this.fakeUserIdentity = identity;\n        if (this.closed) {\n            throw new Error(\"ConvexReactClient has already been closed.\");\n        }\n        if (this.cachedSync) {\n            this.sync.setAdminAuth(token, identity);\n        }\n    }\n    /**\n   * Construct a new {@link Watch} on a Convex query function.\n   *\n   * **Most application code should not call this method directly. Instead use\n   * the {@link useQuery} hook.**\n   *\n   * The act of creating a watch does nothing, a Watch is stateless.\n   *\n   * @param query - A {@link server.FunctionReference} for the public query to run.\n   * @param args - An arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @param options - A {@link WatchQueryOptions} options object for this query.\n   *\n   * @returns The {@link Watch} object.\n   */ watchQuery(query) {\n        for(var _len = arguments.length, argsAndOptions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            argsAndOptions[_key - 1] = arguments[_key];\n        }\n        const [args, options] = argsAndOptions;\n        const name = (0,_server_api_js__WEBPACK_IMPORTED_MODULE_6__.getFunctionName)(query);\n        return {\n            onUpdate: (callback)=>{\n                const { queryToken, unsubscribe } = this.sync.subscribe(name, args, options);\n                const currentListeners = this.listeners.get(queryToken);\n                if (currentListeners !== void 0) {\n                    currentListeners.add(callback);\n                } else {\n                    this.listeners.set(queryToken, /* @__PURE__ */ new Set([\n                        callback\n                    ]));\n                }\n                return ()=>{\n                    if (this.closed) {\n                        return;\n                    }\n                    const currentListeners2 = this.listeners.get(queryToken);\n                    currentListeners2.delete(callback);\n                    if (currentListeners2.size === 0) {\n                        this.listeners.delete(queryToken);\n                    }\n                    unsubscribe();\n                };\n            },\n            localQueryResult: ()=>{\n                if (this.cachedSync) {\n                    return this.cachedSync.localQueryResult(name, args);\n                }\n                return void 0;\n            },\n            localQueryLogs: ()=>{\n                if (this.cachedSync) {\n                    return this.cachedSync.localQueryLogs(name, args);\n                }\n                return void 0;\n            },\n            journal: ()=>{\n                if (this.cachedSync) {\n                    return this.cachedSync.queryJournal(name, args);\n                }\n                return void 0;\n            }\n        };\n    }\n    // Let's try out a queryOptions-style API.\n    // This method is similar to the React Query API `queryClient.prefetchQuery()`.\n    // In the future an ensureQueryData(): Promise<Data> method could exist.\n    /**\n   * Indicates likely future interest in a query subscription.\n   *\n   * The implementation currently immediately subscribes to a query. In the future this method\n   * may prioritize some queries over others, fetch the query result without subscribing, or\n   * do nothing in slow network connections or high load scenarios.\n   *\n   * To use this in a React component, call useQuery() and ignore the return value.\n   *\n   * @param queryOptions - A query (function reference from an api object) and its args, plus\n   * an optional extendSubscriptionFor for how long to subscribe to the query.\n   */ prewarmQuery(queryOptions) {\n        var _queryOptions_extendSubscriptionFor;\n        const extendSubscriptionFor = (_queryOptions_extendSubscriptionFor = queryOptions.extendSubscriptionFor) !== null && _queryOptions_extendSubscriptionFor !== void 0 ? _queryOptions_extendSubscriptionFor : DEFAULT_EXTEND_SUBSCRIPTION_FOR;\n        const watch = this.watchQuery(queryOptions.query, queryOptions.args || {});\n        const unsubscribe = watch.onUpdate(()=>{});\n        setTimeout(unsubscribe, extendSubscriptionFor);\n    }\n    /**\n   * Construct a new {@link PaginatedWatch} on a Convex paginated query function.\n   *\n   * **Most application code should not call this method directly. Instead use\n   * the {@link usePaginatedQuery} hook.**\n   *\n   * The act of creating a watch does nothing, a Watch is stateless.\n   *\n   * @param query - A {@link server.FunctionReference} for the public query to run.\n   * @param args - An arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @param options - A {@link WatchPaginatedQueryOptions} options object for this query.\n   *\n   * @returns The {@link PaginatedWatch} object.\n   *\n   * @internal\n   */ watchPaginatedQuery(query, args, options) {\n        const name = (0,_server_api_js__WEBPACK_IMPORTED_MODULE_6__.getFunctionName)(query);\n        return {\n            onUpdate: (callback)=>{\n                const { paginatedQueryToken, unsubscribe } = this.paginatedQueryClient.subscribe(name, args || {}, options);\n                const currentListeners = this.listeners.get(paginatedQueryToken);\n                if (currentListeners !== void 0) {\n                    currentListeners.add(callback);\n                } else {\n                    this.listeners.set(paginatedQueryToken, /* @__PURE__ */ new Set([\n                        callback\n                    ]));\n                }\n                return ()=>{\n                    if (this.closed) {\n                        return;\n                    }\n                    const currentListeners2 = this.listeners.get(paginatedQueryToken);\n                    currentListeners2.delete(callback);\n                    if (currentListeners2.size === 0) {\n                        this.listeners.delete(paginatedQueryToken);\n                    }\n                    unsubscribe();\n                };\n            },\n            localQueryResult: ()=>{\n                return this.paginatedQueryClient.localQueryResult(name, args, options);\n            }\n        };\n    }\n    /**\n   * Execute a mutation function.\n   *\n   * @param mutation - A {@link server.FunctionReference} for the public mutation\n   * to run.\n   * @param args - An arguments object for the mutation. If this is omitted,\n   * the arguments will be `{}`.\n   * @param options - A {@link MutationOptions} options object for the mutation.\n   * @returns A promise of the mutation's result.\n   */ mutation(mutation) {\n        for(var _len = arguments.length, argsAndOptions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            argsAndOptions[_key - 1] = arguments[_key];\n        }\n        const [args, options] = argsAndOptions;\n        const name = (0,_server_api_js__WEBPACK_IMPORTED_MODULE_6__.getFunctionName)(mutation);\n        return this.sync.mutation(name, args, options);\n    }\n    /**\n   * Execute an action function.\n   *\n   * @param action - A {@link server.FunctionReference} for the public action\n   * to run.\n   * @param args - An arguments object for the action. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the action's result.\n   */ action(action) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        const name = (0,_server_api_js__WEBPACK_IMPORTED_MODULE_6__.getFunctionName)(action);\n        return this.sync.action(name, ...args);\n    }\n    /**\n   * Fetch a query result once.\n   *\n   * **Most application code should subscribe to queries instead, using\n   * the {@link useQuery} hook.**\n   *\n   * @param query - A {@link server.FunctionReference} for the public query\n   * to run.\n   * @param args - An arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the query's result.\n   */ query(query) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        const watch = this.watchQuery(query, ...args);\n        const existingResult = watch.localQueryResult();\n        if (existingResult !== void 0) {\n            return Promise.resolve(existingResult);\n        }\n        return new Promise((resolve, reject)=>{\n            const unsubscribe = watch.onUpdate(()=>{\n                unsubscribe();\n                try {\n                    resolve(watch.localQueryResult());\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    /**\n   * Get the current {@link ConnectionState} between the client and the Convex\n   * backend.\n   *\n   * @returns The {@link ConnectionState} with the Convex backend.\n   */ connectionState() {\n        return this.sync.connectionState();\n    }\n    /**\n   * Subscribe to the {@link ConnectionState} between the client and the Convex\n   * backend, calling a callback each time it changes.\n   *\n   * Subscribed callbacks will be called when any part of ConnectionState changes.\n   * ConnectionState may grow in future versions (e.g. to provide a array of\n   * inflight requests) in which case callbacks would be called more frequently.\n   * ConnectionState may also *lose* properties in future versions as we figure\n   * out what information is most useful. As such this API is considered unstable.\n   *\n   * @returns An unsubscribe function to stop listening.\n   */ subscribeToConnectionState(cb) {\n        return this.sync.subscribeToConnectionState(cb);\n    }\n    /**\n   * Get the logger for this client.\n   *\n   * @returns The {@link Logger} for this client.\n   */ get logger() {\n        return this._logger;\n    }\n    /**\n   * Close any network handles associated with this client and stop all subscriptions.\n   *\n   * Call this method when you're done with a {@link ConvexReactClient} to\n   * dispose of its sockets and resources.\n   *\n   * @returns A `Promise` fulfilled when the connection has been completely closed.\n   */ async close() {\n        this.closed = true;\n        this.listeners = /* @__PURE__ */ new Map();\n        if (this.cachedPaginatedQueryClient) {\n            this.cachedPaginatedQueryClient = void 0;\n        }\n        if (this.cachedSync) {\n            const sync = this.cachedSync;\n            this.cachedSync = void 0;\n            await sync.close();\n        }\n    }\n    /**\n   * Handle transitions from both base client and paginated client.\n   * This ensures all transitions are processed synchronously and in order.\n   */ handleTransition(transition) {\n        const simple = transition.queries.map((q)=>q.token);\n        const paginated = transition.paginatedQueries.map((q)=>q.token);\n        this.transition([\n            ...simple,\n            ...paginated\n        ]);\n    }\n    transition(updatedQueries) {\n        for (const queryToken of updatedQueries){\n            const callbacks = this.listeners.get(queryToken);\n            if (callbacks) {\n                for (const callback of callbacks){\n                    callback();\n                }\n            }\n        }\n    }\n    /**\n   * @param address - The url of your Convex deployment, often provided\n   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.\n   * @param options - See {@link ConvexReactClientOptions} for a full description.\n   */ constructor(address, options){\n        __publicField(this, \"address\");\n        __publicField(this, \"cachedSync\");\n        __publicField(this, \"cachedPaginatedQueryClient\");\n        __publicField(this, \"listeners\");\n        __publicField(this, \"options\");\n        // \"closed\" means this client is done, not just that the underlying WS connection is closed.\n        __publicField(this, \"closed\", false);\n        __publicField(this, \"_logger\");\n        __publicField(this, \"adminAuth\");\n        __publicField(this, \"fakeUserIdentity\");\n        if (address === void 0) {\n            throw new Error(\"No address provided to ConvexReactClient.\\nIf trying to deploy to production, make sure to follow all the instructions found at https://docs.convex.dev/production/hosting/\\nIf running locally, make sure to run `convex dev` and ensure the .env.local file is populated.\");\n        }\n        if (typeof address !== \"string\") {\n            throw new Error(\"ConvexReactClient requires a URL like 'https://happy-otter-123.convex.cloud', received something of type \".concat(typeof address, \" instead.\"));\n        }\n        if (!address.includes(\"://\")) {\n            throw new Error(\"Provided address was not an absolute URL.\");\n        }\n        this.address = address;\n        this.listeners = /* @__PURE__ */ new Map();\n        var _options_verbose, _options_verbose1;\n        this._logger = (options === null || options === void 0 ? void 0 : options.logger) === false ? (0,_browser_logging_js__WEBPACK_IMPORTED_MODULE_7__.instantiateNoopLogger)({\n            verbose: (_options_verbose = options === null || options === void 0 ? void 0 : options.verbose) !== null && _options_verbose !== void 0 ? _options_verbose : false\n        }) : (options === null || options === void 0 ? void 0 : options.logger) !== true && (options === null || options === void 0 ? void 0 : options.logger) ? options.logger : (0,_browser_logging_js__WEBPACK_IMPORTED_MODULE_7__.instantiateDefaultLogger)({\n            verbose: (_options_verbose1 = options === null || options === void 0 ? void 0 : options.verbose) !== null && _options_verbose1 !== void 0 ? _options_verbose1 : false\n        });\n        this.options = {\n            ...options,\n            logger: this._logger\n        };\n    }\n}\nconst ConvexContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0);\nfunction useConvex() {\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ConvexContext);\n}\n_s(useConvex, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst ConvexProvider = (param)=>{\n    let { client, children } = param;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(ConvexContext.Provider, {\n        value: client\n    }, children);\n};\n_c = ConvexProvider;\nfunction useQuery(query) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    _s1();\n    const skip = args[0] === \"skip\";\n    const argsObject = args[0] === \"skip\" ? {} : (0,_common_index_js__WEBPACK_IMPORTED_MODULE_5__.parseArgs)(args[0]);\n    const queryReference = typeof query === \"string\" ? (0,_server_api_js__WEBPACK_IMPORTED_MODULE_6__.makeFunctionReference)(query) : query;\n    const queryName = (0,_server_api_js__WEBPACK_IMPORTED_MODULE_6__.getFunctionName)(queryReference);\n    const queries = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>skip ? {} : {\n            query: {\n                query: queryReference,\n                args: argsObject\n            }\n        }, // Stringify args so args that are semantically the same don't trigger a\n    // rerender. Saves developers from adding `useMemo` on every args usage.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        JSON.stringify((0,_values_index_js__WEBPACK_IMPORTED_MODULE_2__.convexToJson)(argsObject)),\n        queryName,\n        skip\n    ]);\n    const results = (0,_use_queries_js__WEBPACK_IMPORTED_MODULE_3__.useQueries)(queries);\n    const result = results[\"query\"];\n    if (result instanceof Error) {\n        throw result;\n    }\n    return result;\n}\n_s1(useQuery, \"z7Sb6nP071RXggrUdLnaFm4g4u4=\", false, function() {\n    return [\n        _use_queries_js__WEBPACK_IMPORTED_MODULE_3__.useQueries\n    ];\n});\nfunction useMutation(mutation) {\n    _s2();\n    const mutationReference = typeof mutation === \"string\" ? (0,_server_api_js__WEBPACK_IMPORTED_MODULE_6__.makeFunctionReference)(mutation) : mutation;\n    const convex = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ConvexContext);\n    if (convex === void 0) {\n        throw new Error(\"Could not find Convex client! `useMutation` must be used in the React component tree under `ConvexProvider`. Did you forget it? See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app\");\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>createMutation(mutationReference, convex), // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        convex,\n        (0,_server_api_js__WEBPACK_IMPORTED_MODULE_6__.getFunctionName)(mutationReference)\n    ]);\n}\n_s2(useMutation, \"5RcZ9S4PUI16Le2vh+CFvwKfMsk=\");\nfunction useAction(action) {\n    _s3();\n    const convex = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ConvexContext);\n    const actionReference = typeof action === \"string\" ? (0,_server_api_js__WEBPACK_IMPORTED_MODULE_6__.makeFunctionReference)(action) : action;\n    if (convex === void 0) {\n        throw new Error(\"Could not find Convex client! `useAction` must be used in the React component tree under `ConvexProvider`. Did you forget it? See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app\");\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>createAction(actionReference, convex), // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        convex,\n        (0,_server_api_js__WEBPACK_IMPORTED_MODULE_6__.getFunctionName)(actionReference)\n    ]);\n}\n_s3(useAction, \"5RcZ9S4PUI16Le2vh+CFvwKfMsk=\");\nfunction useConvexConnectionState() {\n    _s4();\n    const convex = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ConvexContext);\n    if (convex === void 0) {\n        throw new Error(\"Could not find Convex client! `useConvexConnectionState` must be used in the React component tree under `ConvexProvider`. Did you forget it? See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app\");\n    }\n    const getCurrentValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        return convex.connectionState();\n    }, [\n        convex\n    ]);\n    const subscribe = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((callback)=>{\n        return convex.subscribeToConnectionState(()=>{\n            callback();\n        });\n    }, [\n        convex\n    ]);\n    return (0,_use_subscription_js__WEBPACK_IMPORTED_MODULE_4__.useSubscription)({\n        getCurrentValue,\n        subscribe\n    });\n}\n_s4(useConvexConnectionState, \"G7ychVjTKwQNOpeDRR9ERhCMf8E=\", false, function() {\n    return [\n        _use_subscription_js__WEBPACK_IMPORTED_MODULE_4__.useSubscription\n    ];\n});\nfunction assertNotAccidentalArgument(value) {\n    if (typeof value === \"object\" && value !== null && \"bubbles\" in value && \"persist\" in value && \"isDefaultPrevented\" in value) {\n        throw new Error(\"Convex function called with SyntheticEvent object. Did you use a Convex function as an event handler directly? Event handlers like onClick receive an event object as their first argument. These SyntheticEvent objects are not valid Convex values. Try wrapping the function like `const handler = () => myMutation();` and using `handler` in the event handler.\");\n    }\n} //# sourceMappingURL=client.js.map\nvar _c;\n$RefreshReg$(_c, \"ConvexProvider\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vcmVhY3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxrQkFBa0IsQ0FBQ0MsS0FBS0MsS0FBS0MsUUFBVUQsT0FBT0QsTUFBTUosVUFBVUksS0FBS0MsS0FBSztRQUFFRSxZQUFZO1FBQU1DLGNBQWM7UUFBTUMsVUFBVTtRQUFNSDtJQUFNLEtBQUtGLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztBQUMxSixJQUFJSSxnQkFBZ0IsQ0FBQ04sS0FBS0MsS0FBS0MsUUFBVUgsZ0JBQWdCQyxLQUFLLE9BQU9DLFFBQVEsV0FBV0EsTUFBTSxLQUFLQSxLQUFLQztBQUNqRDtBQUNTO0FBQ2Q7QUFDSjtBQUNVO0FBQ1Q7QUFJckI7QUFJSztBQUdvQjtBQUNuRCxNQUFNbUIsa0NBQWtDO0FBQ3hDLElBQUksT0FBT2Isa0NBQUtBLEtBQUssYUFBYTtJQUNoQyxNQUFNLElBQUljLE1BQU07QUFDbEI7QUFDTyxTQUFTQyxlQUFlQyxpQkFBaUIsRUFBRUMsTUFBTSxFQUFFQyxNQUFNO0lBQzlELFNBQVNDLFNBQVNDLElBQUk7UUFDcEJDLDRCQUE0QkQ7UUFDNUIsT0FBT0gsT0FBT0UsUUFBUSxDQUFDSCxtQkFBbUJJLE1BQU07WUFDOUNFLGtCQUFrQko7UUFDcEI7SUFDRjtJQUNBQyxTQUFTSSxvQkFBb0IsR0FBRyxTQUFTQSxxQkFBcUJELGdCQUFnQjtRQUM1RSxJQUFJSixXQUFXLEtBQUssR0FBRztZQUNyQixNQUFNLElBQUlKLE1BQ1Isb0RBRUUsT0FGa0ROLCtEQUFlQSxDQUNqRVE7UUFHTjtRQUNBLE9BQU9ELGVBQWVDLG1CQUFtQkMsUUFBUUs7SUFDbkQ7SUFDQSxPQUFPSDtBQUNUO0FBQ0EsU0FBU0ssYUFBYUMsZUFBZSxFQUFFUixNQUFNO0lBQzNDLE9BQU8sU0FBU0cs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QWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vcmVhY3QvY2xpZW50LmpzP2IzZjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuaW1wb3J0IHsgQmFzZUNvbnZleENsaWVudCB9IGZyb20gXCIuLi9icm93c2VyL2luZGV4LmpzXCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGNvbnZleFRvSnNvbiB9IGZyb20gXCIuLi92YWx1ZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IHVzZVF1ZXJpZXMgfSBmcm9tIFwiLi91c2VfcXVlcmllcy5qc1wiO1xuaW1wb3J0IHsgdXNlU3Vic2NyaXB0aW9uIH0gZnJvbSBcIi4vdXNlX3N1YnNjcmlwdGlvbi5qc1wiO1xuaW1wb3J0IHsgcGFyc2VBcmdzIH0gZnJvbSBcIi4uL2NvbW1vbi9pbmRleC5qc1wiO1xuaW1wb3J0IHtcbiAgZ2V0RnVuY3Rpb25OYW1lLFxuICBtYWtlRnVuY3Rpb25SZWZlcmVuY2Vcbn0gZnJvbSBcIi4uL3NlcnZlci9hcGkuanNcIjtcbmltcG9ydCB7XG4gIGluc3RhbnRpYXRlRGVmYXVsdExvZ2dlcixcbiAgaW5zdGFudGlhdGVOb29wTG9nZ2VyXG59IGZyb20gXCIuLi9icm93c2VyL2xvZ2dpbmcuanNcIjtcbmltcG9ydCB7XG4gIFBhZ2luYXRlZFF1ZXJ5Q2xpZW50XG59IGZyb20gXCIuLi9icm93c2VyL3N5bmMvcGFnaW5hdGVkX3F1ZXJ5X2NsaWVudC5qc1wiO1xuY29uc3QgREVGQVVMVF9FWFRFTkRfU1VCU0NSSVBUSU9OX0ZPUiA9IDVlMztcbmlmICh0eXBlb2YgUmVhY3QgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWlyZWQgZGVwZW5kZW5jeSAncmVhY3QnIG5vdCBmb3VuZFwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNdXRhdGlvbihtdXRhdGlvblJlZmVyZW5jZSwgY2xpZW50LCB1cGRhdGUpIHtcbiAgZnVuY3Rpb24gbXV0YXRpb24oYXJncykge1xuICAgIGFzc2VydE5vdEFjY2lkZW50YWxBcmd1bWVudChhcmdzKTtcbiAgICByZXR1cm4gY2xpZW50Lm11dGF0aW9uKG11dGF0aW9uUmVmZXJlbmNlLCBhcmdzLCB7XG4gICAgICBvcHRpbWlzdGljVXBkYXRlOiB1cGRhdGVcbiAgICB9KTtcbiAgfVxuICBtdXRhdGlvbi53aXRoT3B0aW1pc3RpY1VwZGF0ZSA9IGZ1bmN0aW9uIHdpdGhPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGUpIHtcbiAgICBpZiAodXBkYXRlICE9PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEFscmVhZHkgc3BlY2lmaWVkIG9wdGltaXN0aWMgdXBkYXRlIGZvciBtdXRhdGlvbiAke2dldEZ1bmN0aW9uTmFtZShcbiAgICAgICAgICBtdXRhdGlvblJlZmVyZW5jZVxuICAgICAgICApfWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVNdXRhdGlvbihtdXRhdGlvblJlZmVyZW5jZSwgY2xpZW50LCBvcHRpbWlzdGljVXBkYXRlKTtcbiAgfTtcbiAgcmV0dXJuIG11dGF0aW9uO1xufVxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKGFjdGlvblJlZmVyZW5jZSwgY2xpZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmdzKSB7XG4gICAgcmV0dXJuIGNsaWVudC5hY3Rpb24oYWN0aW9uUmVmZXJlbmNlLCBhcmdzKTtcbiAgfTtcbn1cbmV4cG9ydCBjbGFzcyBDb252ZXhSZWFjdENsaWVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gYWRkcmVzcyAtIFRoZSB1cmwgb2YgeW91ciBDb252ZXggZGVwbG95bWVudCwgb2Z0ZW4gcHJvdmlkZWRcbiAgICogYnkgYW4gZW52aXJvbm1lbnQgdmFyaWFibGUuIEUuZy4gYGh0dHBzOi8vc21hbGwtbW91c2UtMTIzLmNvbnZleC5jbG91ZGAuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gU2VlIHtAbGluayBDb252ZXhSZWFjdENsaWVudE9wdGlvbnN9IGZvciBhIGZ1bGwgZGVzY3JpcHRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBvcHRpb25zKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFkZHJlc3NcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNhY2hlZFN5bmNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNhY2hlZFBhZ2luYXRlZFF1ZXJ5Q2xpZW50XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsaXN0ZW5lcnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9wdGlvbnNcIik7XG4gICAgLy8gXCJjbG9zZWRcIiBtZWFucyB0aGlzIGNsaWVudCBpcyBkb25lLCBub3QganVzdCB0aGF0IHRoZSB1bmRlcmx5aW5nIFdTIGNvbm5lY3Rpb24gaXMgY2xvc2VkLlxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjbG9zZWRcIiwgZmFsc2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbG9nZ2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhZG1pbkF1dGhcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZha2VVc2VySWRlbnRpdHlcIik7XG4gICAgaWYgKGFkZHJlc3MgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIk5vIGFkZHJlc3MgcHJvdmlkZWQgdG8gQ29udmV4UmVhY3RDbGllbnQuXFxuSWYgdHJ5aW5nIHRvIGRlcGxveSB0byBwcm9kdWN0aW9uLCBtYWtlIHN1cmUgdG8gZm9sbG93IGFsbCB0aGUgaW5zdHJ1Y3Rpb25zIGZvdW5kIGF0IGh0dHBzOi8vZG9jcy5jb252ZXguZGV2L3Byb2R1Y3Rpb24vaG9zdGluZy9cXG5JZiBydW5uaW5nIGxvY2FsbHksIG1ha2Ugc3VyZSB0byBydW4gYGNvbnZleCBkZXZgIGFuZCBlbnN1cmUgdGhlIC5lbnYubG9jYWwgZmlsZSBpcyBwb3B1bGF0ZWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYWRkcmVzcyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ29udmV4UmVhY3RDbGllbnQgcmVxdWlyZXMgYSBVUkwgbGlrZSAnaHR0cHM6Ly9oYXBweS1vdHRlci0xMjMuY29udmV4LmNsb3VkJywgcmVjZWl2ZWQgc29tZXRoaW5nIG9mIHR5cGUgJHt0eXBlb2YgYWRkcmVzc30gaW5zdGVhZC5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWFkZHJlc3MuaW5jbHVkZXMoXCI6Ly9cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVkIGFkZHJlc3Mgd2FzIG5vdCBhbiBhYnNvbHV0ZSBVUkwuXCIpO1xuICAgIH1cbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgIHRoaXMubGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9sb2dnZXIgPSBvcHRpb25zPy5sb2dnZXIgPT09IGZhbHNlID8gaW5zdGFudGlhdGVOb29wTG9nZ2VyKHsgdmVyYm9zZTogb3B0aW9ucz8udmVyYm9zZSA/PyBmYWxzZSB9KSA6IG9wdGlvbnM/LmxvZ2dlciAhPT0gdHJ1ZSAmJiBvcHRpb25zPy5sb2dnZXIgPyBvcHRpb25zLmxvZ2dlciA6IGluc3RhbnRpYXRlRGVmYXVsdExvZ2dlcih7IHZlcmJvc2U6IG9wdGlvbnM/LnZlcmJvc2UgPz8gZmFsc2UgfSk7XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi5vcHRpb25zLCBsb2dnZXI6IHRoaXMuX2xvZ2dlciB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGFkZHJlc3MgZm9yIHRoaXMgY2xpZW50LCB1c2VmdWwgZm9yIGNyZWF0aW5nIGEgbmV3IGNsaWVudC5cbiAgICpcbiAgICogTm90IGd1YXJhbnRlZWQgdG8gbWF0Y2ggdGhlIGFkZHJlc3Mgd2l0aCB3aGljaCB0aGlzIGNsaWVudCB3YXMgY29uc3RydWN0ZWQ6XG4gICAqIGl0IG1heSBiZSBjYW5vbmljYWxpemVkLlxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRyZXNzO1xuICB9XG4gIC8qKlxuICAgKiBMYXppbHkgaW5zdGFudGlhdGUgdGhlIGBCYXNlQ29udmV4Q2xpZW50YCBzbyB3ZSBkb24ndCBjcmVhdGUgdGhlIFdlYlNvY2tldFxuICAgKiB3aGVuIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgc3luYygpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnZleFJlYWN0Q2xpZW50IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2FjaGVkU3luYykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkU3luYztcbiAgICB9XG4gICAgdGhpcy5jYWNoZWRTeW5jID0gbmV3IEJhc2VDb252ZXhDbGllbnQoXG4gICAgICB0aGlzLmFkZHJlc3MsXG4gICAgICAoKSA9PiB7XG4gICAgICB9LFxuICAgICAgLy8gVXNlIHRoZSBQYWdpbmF0ZWRRdWVyeUNsaWVudCdzIHRyYW5zaXRpb24gaW5zdGVhZC5cbiAgICAgIHRoaXMub3B0aW9uc1xuICAgICk7XG4gICAgaWYgKHRoaXMuYWRtaW5BdXRoKSB7XG4gICAgICB0aGlzLmNhY2hlZFN5bmMuc2V0QWRtaW5BdXRoKHRoaXMuYWRtaW5BdXRoLCB0aGlzLmZha2VVc2VySWRlbnRpdHkpO1xuICAgIH1cbiAgICB0aGlzLmNhY2hlZFBhZ2luYXRlZFF1ZXJ5Q2xpZW50ID0gbmV3IFBhZ2luYXRlZFF1ZXJ5Q2xpZW50KFxuICAgICAgdGhpcy5jYWNoZWRTeW5jLFxuICAgICAgKHRyYW5zaXRpb24pID0+IHRoaXMuaGFuZGxlVHJhbnNpdGlvbih0cmFuc2l0aW9uKVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVkU3luYztcbiAgfVxuICAvKipcbiAgICogTGF6aWx5IGluc3RhbnRpYXRlIHRoZSBgUGFnaW5hdGVkUXVlcnlDbGllbnRgIHNvIHdlIGRvbid0IGNyZWF0ZSBpdFxuICAgKiB3aGVuIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgcGFnaW5hdGVkUXVlcnlDbGllbnQoKSB7XG4gICAgdGhpcy5zeW5jO1xuICAgIGlmICh0aGlzLmNhY2hlZFBhZ2luYXRlZFF1ZXJ5Q2xpZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZWRQYWdpbmF0ZWRRdWVyeUNsaWVudDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIGFscmVhZHkgYmUgaW5zdGFudGlhdGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuIHRvIGJlIHVzZWQgZm9yIHN1YnNlcXVlbnQgcXVlcmllcyBhbmQgbXV0YXRpb25zLlxuICAgKiBgZmV0Y2hUb2tlbmAgd2lsbCBiZSBjYWxsZWQgYXV0b21hdGljYWxseSBhZ2FpbiBpZiBhIHRva2VuIGV4cGlyZXMuXG4gICAqIGBmZXRjaFRva2VuYCBzaG91bGQgcmV0dXJuIGBudWxsYCBpZiB0aGUgdG9rZW4gY2Fubm90IGJlIHJldHJpZXZlZCwgZm9yIGV4YW1wbGVcbiAgICogd2hlbiB0aGUgdXNlcidzIHJpZ2h0cyB3ZXJlIHBlcm1hbmVudGx5IHJldm9rZWQuXG4gICAqIEBwYXJhbSBmZXRjaFRva2VuIC0gYW4gYXN5bmMgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBKV1QtZW5jb2RlZCBPcGVuSUQgQ29ubmVjdCBJZGVudGl0eSBUb2tlblxuICAgKiBAcGFyYW0gb25DaGFuZ2UgLSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYXV0aGVudGljYXRpb24gc3RhdHVzIGNoYW5nZXNcbiAgICovXG4gIHNldEF1dGgoZmV0Y2hUb2tlbiwgb25DaGFuZ2UpIHtcbiAgICBpZiAodHlwZW9mIGZldGNoVG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJQYXNzaW5nIGEgc3RyaW5nIHRvIENvbnZleFJlYWN0Q2xpZW50LnNldEF1dGggaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCwgcGxlYXNlIHVwZ3JhZGUgdG8gcGFzc2luZyBpbiBhbiBhc3luYyBmdW5jdGlvbiB0byBoYW5kbGUgcmVhdXRoZW50aWNhdGlvbi5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5zeW5jLnNldEF1dGgoXG4gICAgICBmZXRjaFRva2VuLFxuICAgICAgb25DaGFuZ2UgPz8gKCgpID0+IHtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXIgdGhlIGN1cnJlbnQgYXV0aGVudGljYXRpb24gdG9rZW4gaWYgc2V0LlxuICAgKi9cbiAgY2xlYXJBdXRoKCkge1xuICAgIHRoaXMuc3luYy5jbGVhckF1dGgoKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRBZG1pbkF1dGgodG9rZW4sIGlkZW50aXR5KSB7XG4gICAgdGhpcy5hZG1pbkF1dGggPSB0b2tlbjtcbiAgICB0aGlzLmZha2VVc2VySWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnZleFJlYWN0Q2xpZW50IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2FjaGVkU3luYykge1xuICAgICAgdGhpcy5zeW5jLnNldEFkbWluQXV0aCh0b2tlbiwgaWRlbnRpdHkpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHtAbGluayBXYXRjaH0gb24gYSBDb252ZXggcXVlcnkgZnVuY3Rpb24uXG4gICAqXG4gICAqICoqTW9zdCBhcHBsaWNhdGlvbiBjb2RlIHNob3VsZCBub3QgY2FsbCB0aGlzIG1ldGhvZCBkaXJlY3RseS4gSW5zdGVhZCB1c2VcbiAgICogdGhlIHtAbGluayB1c2VRdWVyeX0gaG9vay4qKlxuICAgKlxuICAgKiBUaGUgYWN0IG9mIGNyZWF0aW5nIGEgd2F0Y2ggZG9lcyBub3RoaW5nLCBhIFdhdGNoIGlzIHN0YXRlbGVzcy5cbiAgICpcbiAgICogQHBhcmFtIHF1ZXJ5IC0gQSB7QGxpbmsgc2VydmVyLkZ1bmN0aW9uUmVmZXJlbmNlfSBmb3IgdGhlIHB1YmxpYyBxdWVyeSB0byBydW4uXG4gICAqIEBwYXJhbSBhcmdzIC0gQW4gYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIHF1ZXJ5LiBJZiB0aGlzIGlzIG9taXR0ZWQsXG4gICAqIHRoZSBhcmd1bWVudHMgd2lsbCBiZSBge31gLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEEge0BsaW5rIFdhdGNoUXVlcnlPcHRpb25zfSBvcHRpb25zIG9iamVjdCBmb3IgdGhpcyBxdWVyeS5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHtAbGluayBXYXRjaH0gb2JqZWN0LlxuICAgKi9cbiAgd2F0Y2hRdWVyeShxdWVyeSwgLi4uYXJnc0FuZE9wdGlvbnMpIHtcbiAgICBjb25zdCBbYXJncywgb3B0aW9uc10gPSBhcmdzQW5kT3B0aW9ucztcbiAgICBjb25zdCBuYW1lID0gZ2V0RnVuY3Rpb25OYW1lKHF1ZXJ5KTtcbiAgICByZXR1cm4ge1xuICAgICAgb25VcGRhdGU6IChjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25zdCB7IHF1ZXJ5VG9rZW4sIHVuc3Vic2NyaWJlIH0gPSB0aGlzLnN5bmMuc3Vic2NyaWJlKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRMaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycy5nZXQocXVlcnlUb2tlbik7XG4gICAgICAgIGlmIChjdXJyZW50TGlzdGVuZXJzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjdXJyZW50TGlzdGVuZXJzLmFkZChjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5saXN0ZW5lcnMuc2V0KHF1ZXJ5VG9rZW4sIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtjYWxsYmFja10pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjdXJyZW50TGlzdGVuZXJzMiA9IHRoaXMubGlzdGVuZXJzLmdldChxdWVyeVRva2VuKTtcbiAgICAgICAgICBjdXJyZW50TGlzdGVuZXJzMi5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChjdXJyZW50TGlzdGVuZXJzMi5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUocXVlcnlUb2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgbG9jYWxRdWVyeVJlc3VsdDogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jYWNoZWRTeW5jKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkU3luYy5sb2NhbFF1ZXJ5UmVzdWx0KG5hbWUsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9LFxuICAgICAgbG9jYWxRdWVyeUxvZ3M6ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkU3luYykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlZFN5bmMubG9jYWxRdWVyeUxvZ3MobmFtZSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH0sXG4gICAgICBqb3VybmFsOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZFN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRTeW5jLnF1ZXJ5Sm91cm5hbChuYW1lLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLy8gTGV0J3MgdHJ5IG91dCBhIHF1ZXJ5T3B0aW9ucy1zdHlsZSBBUEkuXG4gIC8vIFRoaXMgbWV0aG9kIGlzIHNpbWlsYXIgdG8gdGhlIFJlYWN0IFF1ZXJ5IEFQSSBgcXVlcnlDbGllbnQucHJlZmV0Y2hRdWVyeSgpYC5cbiAgLy8gSW4gdGhlIGZ1dHVyZSBhbiBlbnN1cmVRdWVyeURhdGEoKTogUHJvbWlzZTxEYXRhPiBtZXRob2QgY291bGQgZXhpc3QuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgbGlrZWx5IGZ1dHVyZSBpbnRlcmVzdCBpbiBhIHF1ZXJ5IHN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogVGhlIGltcGxlbWVudGF0aW9uIGN1cnJlbnRseSBpbW1lZGlhdGVseSBzdWJzY3JpYmVzIHRvIGEgcXVlcnkuIEluIHRoZSBmdXR1cmUgdGhpcyBtZXRob2RcbiAgICogbWF5IHByaW9yaXRpemUgc29tZSBxdWVyaWVzIG92ZXIgb3RoZXJzLCBmZXRjaCB0aGUgcXVlcnkgcmVzdWx0IHdpdGhvdXQgc3Vic2NyaWJpbmcsIG9yXG4gICAqIGRvIG5vdGhpbmcgaW4gc2xvdyBuZXR3b3JrIGNvbm5lY3Rpb25zIG9yIGhpZ2ggbG9hZCBzY2VuYXJpb3MuXG4gICAqXG4gICAqIFRvIHVzZSB0aGlzIGluIGEgUmVhY3QgY29tcG9uZW50LCBjYWxsIHVzZVF1ZXJ5KCkgYW5kIGlnbm9yZSB0aGUgcmV0dXJuIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gcXVlcnlPcHRpb25zIC0gQSBxdWVyeSAoZnVuY3Rpb24gcmVmZXJlbmNlIGZyb20gYW4gYXBpIG9iamVjdCkgYW5kIGl0cyBhcmdzLCBwbHVzXG4gICAqIGFuIG9wdGlvbmFsIGV4dGVuZFN1YnNjcmlwdGlvbkZvciBmb3IgaG93IGxvbmcgdG8gc3Vic2NyaWJlIHRvIHRoZSBxdWVyeS5cbiAgICovXG4gIHByZXdhcm1RdWVyeShxdWVyeU9wdGlvbnMpIHtcbiAgICBjb25zdCBleHRlbmRTdWJzY3JpcHRpb25Gb3IgPSBxdWVyeU9wdGlvbnMuZXh0ZW5kU3Vic2NyaXB0aW9uRm9yID8/IERFRkFVTFRfRVhURU5EX1NVQlNDUklQVElPTl9GT1I7XG4gICAgY29uc3Qgd2F0Y2ggPSB0aGlzLndhdGNoUXVlcnkocXVlcnlPcHRpb25zLnF1ZXJ5LCBxdWVyeU9wdGlvbnMuYXJncyB8fCB7fSk7XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSB3YXRjaC5vblVwZGF0ZSgoKSA9PiB7XG4gICAgfSk7XG4gICAgc2V0VGltZW91dCh1bnN1YnNjcmliZSwgZXh0ZW5kU3Vic2NyaXB0aW9uRm9yKTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHtAbGluayBQYWdpbmF0ZWRXYXRjaH0gb24gYSBDb252ZXggcGFnaW5hdGVkIHF1ZXJ5IGZ1bmN0aW9uLlxuICAgKlxuICAgKiAqKk1vc3QgYXBwbGljYXRpb24gY29kZSBzaG91bGQgbm90IGNhbGwgdGhpcyBtZXRob2QgZGlyZWN0bHkuIEluc3RlYWQgdXNlXG4gICAqIHRoZSB7QGxpbmsgdXNlUGFnaW5hdGVkUXVlcnl9IGhvb2suKipcbiAgICpcbiAgICogVGhlIGFjdCBvZiBjcmVhdGluZyBhIHdhdGNoIGRvZXMgbm90aGluZywgYSBXYXRjaCBpcyBzdGF0ZWxlc3MuXG4gICAqXG4gICAqIEBwYXJhbSBxdWVyeSAtIEEge0BsaW5rIHNlcnZlci5GdW5jdGlvblJlZmVyZW5jZX0gZm9yIHRoZSBwdWJsaWMgcXVlcnkgdG8gcnVuLlxuICAgKiBAcGFyYW0gYXJncyAtIEFuIGFyZ3VtZW50cyBvYmplY3QgZm9yIHRoZSBxdWVyeS4gSWYgdGhpcyBpcyBvbWl0dGVkLFxuICAgKiB0aGUgYXJndW1lbnRzIHdpbGwgYmUgYHt9YC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBIHtAbGluayBXYXRjaFBhZ2luYXRlZFF1ZXJ5T3B0aW9uc30gb3B0aW9ucyBvYmplY3QgZm9yIHRoaXMgcXVlcnkuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSB7QGxpbmsgUGFnaW5hdGVkV2F0Y2h9IG9iamVjdC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB3YXRjaFBhZ2luYXRlZFF1ZXJ5KHF1ZXJ5LCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbmFtZSA9IGdldEZ1bmN0aW9uTmFtZShxdWVyeSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uVXBkYXRlOiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgY29uc3QgeyBwYWdpbmF0ZWRRdWVyeVRva2VuLCB1bnN1YnNjcmliZSB9ID0gdGhpcy5wYWdpbmF0ZWRRdWVyeUNsaWVudC5zdWJzY3JpYmUobmFtZSwgYXJncyB8fCB7fSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRMaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycy5nZXQocGFnaW5hdGVkUXVlcnlUb2tlbik7XG4gICAgICAgIGlmIChjdXJyZW50TGlzdGVuZXJzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjdXJyZW50TGlzdGVuZXJzLmFkZChjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5saXN0ZW5lcnMuc2V0KHBhZ2luYXRlZFF1ZXJ5VG9rZW4sIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtjYWxsYmFja10pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjdXJyZW50TGlzdGVuZXJzMiA9IHRoaXMubGlzdGVuZXJzLmdldChwYWdpbmF0ZWRRdWVyeVRva2VuKTtcbiAgICAgICAgICBjdXJyZW50TGlzdGVuZXJzMi5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChjdXJyZW50TGlzdGVuZXJzMi5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUocGFnaW5hdGVkUXVlcnlUb2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgbG9jYWxRdWVyeVJlc3VsdDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdpbmF0ZWRRdWVyeUNsaWVudC5sb2NhbFF1ZXJ5UmVzdWx0KG5hbWUsIGFyZ3MsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBtdXRhdGlvbiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG11dGF0aW9uIC0gQSB7QGxpbmsgc2VydmVyLkZ1bmN0aW9uUmVmZXJlbmNlfSBmb3IgdGhlIHB1YmxpYyBtdXRhdGlvblxuICAgKiB0byBydW4uXG4gICAqIEBwYXJhbSBhcmdzIC0gQW4gYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIG11dGF0aW9uLiBJZiB0aGlzIGlzIG9taXR0ZWQsXG4gICAqIHRoZSBhcmd1bWVudHMgd2lsbCBiZSBge31gLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEEge0BsaW5rIE11dGF0aW9uT3B0aW9uc30gb3B0aW9ucyBvYmplY3QgZm9yIHRoZSBtdXRhdGlvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIG9mIHRoZSBtdXRhdGlvbidzIHJlc3VsdC5cbiAgICovXG4gIG11dGF0aW9uKG11dGF0aW9uLCAuLi5hcmdzQW5kT3B0aW9ucykge1xuICAgIGNvbnN0IFthcmdzLCBvcHRpb25zXSA9IGFyZ3NBbmRPcHRpb25zO1xuICAgIGNvbnN0IG5hbWUgPSBnZXRGdW5jdGlvbk5hbWUobXV0YXRpb24pO1xuICAgIHJldHVybiB0aGlzLnN5bmMubXV0YXRpb24obmFtZSwgYXJncywgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYW4gYWN0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYWN0aW9uIC0gQSB7QGxpbmsgc2VydmVyLkZ1bmN0aW9uUmVmZXJlbmNlfSBmb3IgdGhlIHB1YmxpYyBhY3Rpb25cbiAgICogdG8gcnVuLlxuICAgKiBAcGFyYW0gYXJncyAtIEFuIGFyZ3VtZW50cyBvYmplY3QgZm9yIHRoZSBhY3Rpb24uIElmIHRoaXMgaXMgb21pdHRlZCxcbiAgICogdGhlIGFyZ3VtZW50cyB3aWxsIGJlIGB7fWAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgYWN0aW9uJ3MgcmVzdWx0LlxuICAgKi9cbiAgYWN0aW9uKGFjdGlvbiwgLi4uYXJncykge1xuICAgIGNvbnN0IG5hbWUgPSBnZXRGdW5jdGlvbk5hbWUoYWN0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5zeW5jLmFjdGlvbihuYW1lLCAuLi5hcmdzKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBxdWVyeSByZXN1bHQgb25jZS5cbiAgICpcbiAgICogKipNb3N0IGFwcGxpY2F0aW9uIGNvZGUgc2hvdWxkIHN1YnNjcmliZSB0byBxdWVyaWVzIGluc3RlYWQsIHVzaW5nXG4gICAqIHRoZSB7QGxpbmsgdXNlUXVlcnl9IGhvb2suKipcbiAgICpcbiAgICogQHBhcmFtIHF1ZXJ5IC0gQSB7QGxpbmsgc2VydmVyLkZ1bmN0aW9uUmVmZXJlbmNlfSBmb3IgdGhlIHB1YmxpYyBxdWVyeVxuICAgKiB0byBydW4uXG4gICAqIEBwYXJhbSBhcmdzIC0gQW4gYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIHF1ZXJ5LiBJZiB0aGlzIGlzIG9taXR0ZWQsXG4gICAqIHRoZSBhcmd1bWVudHMgd2lsbCBiZSBge31gLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2Ugb2YgdGhlIHF1ZXJ5J3MgcmVzdWx0LlxuICAgKi9cbiAgcXVlcnkocXVlcnksIC4uLmFyZ3MpIHtcbiAgICBjb25zdCB3YXRjaCA9IHRoaXMud2F0Y2hRdWVyeShxdWVyeSwgLi4uYXJncyk7XG4gICAgY29uc3QgZXhpc3RpbmdSZXN1bHQgPSB3YXRjaC5sb2NhbFF1ZXJ5UmVzdWx0KCk7XG4gICAgaWYgKGV4aXN0aW5nUmVzdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZXhpc3RpbmdSZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB3YXRjaC5vblVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzb2x2ZSh3YXRjaC5sb2NhbFF1ZXJ5UmVzdWx0KCkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHtAbGluayBDb25uZWN0aW9uU3RhdGV9IGJldHdlZW4gdGhlIGNsaWVudCBhbmQgdGhlIENvbnZleFxuICAgKiBiYWNrZW5kLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUge0BsaW5rIENvbm5lY3Rpb25TdGF0ZX0gd2l0aCB0aGUgQ29udmV4IGJhY2tlbmQuXG4gICAqL1xuICBjb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3luYy5jb25uZWN0aW9uU3RhdGUoKTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSB7QGxpbmsgQ29ubmVjdGlvblN0YXRlfSBiZXR3ZWVuIHRoZSBjbGllbnQgYW5kIHRoZSBDb252ZXhcbiAgICogYmFja2VuZCwgY2FsbGluZyBhIGNhbGxiYWNrIGVhY2ggdGltZSBpdCBjaGFuZ2VzLlxuICAgKlxuICAgKiBTdWJzY3JpYmVkIGNhbGxiYWNrcyB3aWxsIGJlIGNhbGxlZCB3aGVuIGFueSBwYXJ0IG9mIENvbm5lY3Rpb25TdGF0ZSBjaGFuZ2VzLlxuICAgKiBDb25uZWN0aW9uU3RhdGUgbWF5IGdyb3cgaW4gZnV0dXJlIHZlcnNpb25zIChlLmcuIHRvIHByb3ZpZGUgYSBhcnJheSBvZlxuICAgKiBpbmZsaWdodCByZXF1ZXN0cykgaW4gd2hpY2ggY2FzZSBjYWxsYmFja3Mgd291bGQgYmUgY2FsbGVkIG1vcmUgZnJlcXVlbnRseS5cbiAgICogQ29ubmVjdGlvblN0YXRlIG1heSBhbHNvICpsb3NlKiBwcm9wZXJ0aWVzIGluIGZ1dHVyZSB2ZXJzaW9ucyBhcyB3ZSBmaWd1cmVcbiAgICogb3V0IHdoYXQgaW5mb3JtYXRpb24gaXMgbW9zdCB1c2VmdWwuIEFzIHN1Y2ggdGhpcyBBUEkgaXMgY29uc2lkZXJlZCB1bnN0YWJsZS5cbiAgICpcbiAgICogQHJldHVybnMgQW4gdW5zdWJzY3JpYmUgZnVuY3Rpb24gdG8gc3RvcCBsaXN0ZW5pbmcuXG4gICAqL1xuICBzdWJzY3JpYmVUb0Nvbm5lY3Rpb25TdGF0ZShjYikge1xuICAgIHJldHVybiB0aGlzLnN5bmMuc3Vic2NyaWJlVG9Db25uZWN0aW9uU3RhdGUoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvZ2dlciBmb3IgdGhpcyBjbGllbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSB7QGxpbmsgTG9nZ2VyfSBmb3IgdGhpcyBjbGllbnQuXG4gICAqL1xuICBnZXQgbG9nZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2dnZXI7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIGFueSBuZXR3b3JrIGhhbmRsZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY2xpZW50IGFuZCBzdG9wIGFsbCBzdWJzY3JpcHRpb25zLlxuICAgKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHdoZW4geW91J3JlIGRvbmUgd2l0aCBhIHtAbGluayBDb252ZXhSZWFjdENsaWVudH0gdG9cbiAgICogZGlzcG9zZSBvZiBpdHMgc29ja2V0cyBhbmQgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIGBQcm9taXNlYCBmdWxmaWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBoYXMgYmVlbiBjb21wbGV0ZWx5IGNsb3NlZC5cbiAgICovXG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKHRoaXMuY2FjaGVkUGFnaW5hdGVkUXVlcnlDbGllbnQpIHtcbiAgICAgIHRoaXMuY2FjaGVkUGFnaW5hdGVkUXVlcnlDbGllbnQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh0aGlzLmNhY2hlZFN5bmMpIHtcbiAgICAgIGNvbnN0IHN5bmMgPSB0aGlzLmNhY2hlZFN5bmM7XG4gICAgICB0aGlzLmNhY2hlZFN5bmMgPSB2b2lkIDA7XG4gICAgICBhd2FpdCBzeW5jLmNsb3NlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgdHJhbnNpdGlvbnMgZnJvbSBib3RoIGJhc2UgY2xpZW50IGFuZCBwYWdpbmF0ZWQgY2xpZW50LlxuICAgKiBUaGlzIGVuc3VyZXMgYWxsIHRyYW5zaXRpb25zIGFyZSBwcm9jZXNzZWQgc3luY2hyb25vdXNseSBhbmQgaW4gb3JkZXIuXG4gICAqL1xuICBoYW5kbGVUcmFuc2l0aW9uKHRyYW5zaXRpb24pIHtcbiAgICBjb25zdCBzaW1wbGUgPSB0cmFuc2l0aW9uLnF1ZXJpZXMubWFwKChxKSA9PiBxLnRva2VuKTtcbiAgICBjb25zdCBwYWdpbmF0ZWQgPSB0cmFuc2l0aW9uLnBhZ2luYXRlZFF1ZXJpZXMubWFwKChxKSA9PiBxLnRva2VuKTtcbiAgICB0aGlzLnRyYW5zaXRpb24oWy4uLnNpbXBsZSwgLi4ucGFnaW5hdGVkXSk7XG4gIH1cbiAgdHJhbnNpdGlvbih1cGRhdGVkUXVlcmllcykge1xuICAgIGZvciAoY29uc3QgcXVlcnlUb2tlbiBvZiB1cGRhdGVkUXVlcmllcykge1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5saXN0ZW5lcnMuZ2V0KHF1ZXJ5VG9rZW4pO1xuICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IENvbnZleENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICB2b2lkIDBcbiAgLy8gaW4gdGhlIGZ1dHVyZSB0aGlzIHdpbGwgYmUgYSBtb2NrZWQgY2xpZW50IGZvciB0ZXN0aW5nXG4pO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbnZleCgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoQ29udmV4Q29udGV4dCk7XG59XG5leHBvcnQgY29uc3QgQ29udmV4UHJvdmlkZXIgPSAoeyBjbGllbnQsIGNoaWxkcmVuIH0pID0+IHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgQ29udmV4Q29udGV4dC5Qcm92aWRlcixcbiAgICB7IHZhbHVlOiBjbGllbnQgfSxcbiAgICBjaGlsZHJlblxuICApO1xufTtcbmV4cG9ydCBmdW5jdGlvbiB1c2VRdWVyeShxdWVyeSwgLi4uYXJncykge1xuICBjb25zdCBza2lwID0gYXJnc1swXSA9PT0gXCJza2lwXCI7XG4gIGNvbnN0IGFyZ3NPYmplY3QgPSBhcmdzWzBdID09PSBcInNraXBcIiA/IHt9IDogcGFyc2VBcmdzKGFyZ3NbMF0pO1xuICBjb25zdCBxdWVyeVJlZmVyZW5jZSA9IHR5cGVvZiBxdWVyeSA9PT0gXCJzdHJpbmdcIiA/IG1ha2VGdW5jdGlvblJlZmVyZW5jZShxdWVyeSkgOiBxdWVyeTtcbiAgY29uc3QgcXVlcnlOYW1lID0gZ2V0RnVuY3Rpb25OYW1lKHF1ZXJ5UmVmZXJlbmNlKTtcbiAgY29uc3QgcXVlcmllcyA9IHVzZU1lbW8oXG4gICAgKCkgPT4gc2tpcCA/IHt9IDogeyBxdWVyeTogeyBxdWVyeTogcXVlcnlSZWZlcmVuY2UsIGFyZ3M6IGFyZ3NPYmplY3QgfSB9LFxuICAgIC8vIFN0cmluZ2lmeSBhcmdzIHNvIGFyZ3MgdGhhdCBhcmUgc2VtYW50aWNhbGx5IHRoZSBzYW1lIGRvbid0IHRyaWdnZXIgYVxuICAgIC8vIHJlcmVuZGVyLiBTYXZlcyBkZXZlbG9wZXJzIGZyb20gYWRkaW5nIGB1c2VNZW1vYCBvbiBldmVyeSBhcmdzIHVzYWdlLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbSlNPTi5zdHJpbmdpZnkoY29udmV4VG9Kc29uKGFyZ3NPYmplY3QpKSwgcXVlcnlOYW1lLCBza2lwXVxuICApO1xuICBjb25zdCByZXN1bHRzID0gdXNlUXVlcmllcyhxdWVyaWVzKTtcbiAgY29uc3QgcmVzdWx0ID0gcmVzdWx0c1tcInF1ZXJ5XCJdO1xuICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICB0aHJvdyByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VNdXRhdGlvbihtdXRhdGlvbikge1xuICBjb25zdCBtdXRhdGlvblJlZmVyZW5jZSA9IHR5cGVvZiBtdXRhdGlvbiA9PT0gXCJzdHJpbmdcIiA/IG1ha2VGdW5jdGlvblJlZmVyZW5jZShtdXRhdGlvbikgOiBtdXRhdGlvbjtcbiAgY29uc3QgY29udmV4ID0gdXNlQ29udGV4dChDb252ZXhDb250ZXh0KTtcbiAgaWYgKGNvbnZleCA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJDb3VsZCBub3QgZmluZCBDb252ZXggY2xpZW50ISBgdXNlTXV0YXRpb25gIG11c3QgYmUgdXNlZCBpbiB0aGUgUmVhY3QgY29tcG9uZW50IHRyZWUgdW5kZXIgYENvbnZleFByb3ZpZGVyYC4gRGlkIHlvdSBmb3JnZXQgaXQ/IFNlZSBodHRwczovL2RvY3MuY29udmV4LmRldi9xdWljay1zdGFydCNzZXQtdXAtY29udmV4LWluLXlvdXItcmVhY3QtYXBwXCJcbiAgICApO1xuICB9XG4gIHJldHVybiB1c2VNZW1vKFxuICAgICgpID0+IGNyZWF0ZU11dGF0aW9uKG11dGF0aW9uUmVmZXJlbmNlLCBjb252ZXgpLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbY29udmV4LCBnZXRGdW5jdGlvbk5hbWUobXV0YXRpb25SZWZlcmVuY2UpXVxuICApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdGlvbihhY3Rpb24pIHtcbiAgY29uc3QgY29udmV4ID0gdXNlQ29udGV4dChDb252ZXhDb250ZXh0KTtcbiAgY29uc3QgYWN0aW9uUmVmZXJlbmNlID0gdHlwZW9mIGFjdGlvbiA9PT0gXCJzdHJpbmdcIiA/IG1ha2VGdW5jdGlvblJlZmVyZW5jZShhY3Rpb24pIDogYWN0aW9uO1xuICBpZiAoY29udmV4ID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkNvdWxkIG5vdCBmaW5kIENvbnZleCBjbGllbnQhIGB1c2VBY3Rpb25gIG11c3QgYmUgdXNlZCBpbiB0aGUgUmVhY3QgY29tcG9uZW50IHRyZWUgdW5kZXIgYENvbnZleFByb3ZpZGVyYC4gRGlkIHlvdSBmb3JnZXQgaXQ/IFNlZSBodHRwczovL2RvY3MuY29udmV4LmRldi9xdWljay1zdGFydCNzZXQtdXAtY29udmV4LWluLXlvdXItcmVhY3QtYXBwXCJcbiAgICApO1xuICB9XG4gIHJldHVybiB1c2VNZW1vKFxuICAgICgpID0+IGNyZWF0ZUFjdGlvbihhY3Rpb25SZWZlcmVuY2UsIGNvbnZleCksXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtjb252ZXgsIGdldEZ1bmN0aW9uTmFtZShhY3Rpb25SZWZlcmVuY2UpXVxuICApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbnZleENvbm5lY3Rpb25TdGF0ZSgpIHtcbiAgY29uc3QgY29udmV4ID0gdXNlQ29udGV4dChDb252ZXhDb250ZXh0KTtcbiAgaWYgKGNvbnZleCA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJDb3VsZCBub3QgZmluZCBDb252ZXggY2xpZW50ISBgdXNlQ29udmV4Q29ubmVjdGlvblN0YXRlYCBtdXN0IGJlIHVzZWQgaW4gdGhlIFJlYWN0IGNvbXBvbmVudCB0cmVlIHVuZGVyIGBDb252ZXhQcm92aWRlcmAuIERpZCB5b3UgZm9yZ2V0IGl0PyBTZWUgaHR0cHM6Ly9kb2NzLmNvbnZleC5kZXYvcXVpY2stc3RhcnQjc2V0LXVwLWNvbnZleC1pbi15b3VyLXJlYWN0LWFwcFwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBnZXRDdXJyZW50VmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmV0dXJuIGNvbnZleC5jb25uZWN0aW9uU3RhdGUoKTtcbiAgfSwgW2NvbnZleF0pO1xuICBjb25zdCBzdWJzY3JpYmUgPSB1c2VDYWxsYmFjayhcbiAgICAoY2FsbGJhY2spID0+IHtcbiAgICAgIHJldHVybiBjb252ZXguc3Vic2NyaWJlVG9Db25uZWN0aW9uU3RhdGUoKCkgPT4ge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBbY29udmV4XVxuICApO1xuICByZXR1cm4gdXNlU3Vic2NyaXB0aW9uKHsgZ2V0Q3VycmVudFZhbHVlLCBzdWJzY3JpYmUgfSk7XG59XG5mdW5jdGlvbiBhc3NlcnROb3RBY2NpZGVudGFsQXJndW1lbnQodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBcImJ1YmJsZXNcIiBpbiB2YWx1ZSAmJiBcInBlcnNpc3RcIiBpbiB2YWx1ZSAmJiBcImlzRGVmYXVsdFByZXZlbnRlZFwiIGluIHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENvbnZleCBmdW5jdGlvbiBjYWxsZWQgd2l0aCBTeW50aGV0aWNFdmVudCBvYmplY3QuIERpZCB5b3UgdXNlIGEgQ29udmV4IGZ1bmN0aW9uIGFzIGFuIGV2ZW50IGhhbmRsZXIgZGlyZWN0bHk/IEV2ZW50IGhhbmRsZXJzIGxpa2Ugb25DbGljayByZWNlaXZlIGFuIGV2ZW50IG9iamVjdCBhcyB0aGVpciBmaXJzdCBhcmd1bWVudC4gVGhlc2UgU3ludGhldGljRXZlbnQgb2JqZWN0cyBhcmUgbm90IHZhbGlkIENvbnZleCB2YWx1ZXMuIFRyeSB3cmFwcGluZyB0aGUgZnVuY3Rpb24gbGlrZSBcXGBjb25zdCBoYW5kbGVyID0gKCkgPT4gbXlNdXRhdGlvbigpO1xcYCBhbmQgdXNpbmcgXFxgaGFuZGxlclxcYCBpbiB0aGUgZXZlbnQgaGFuZGxlci5gXG4gICAgKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19kZWZOb3JtYWxQcm9wIiwib2JqIiwia2V5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX3B1YmxpY0ZpZWxkIiwiQmFzZUNvbnZleENsaWVudCIsIlJlYWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwidXNlTWVtbyIsImNvbnZleFRvSnNvbiIsInVzZVF1ZXJpZXMiLCJ1c2VTdWJzY3JpcHRpb24iLCJwYXJzZUFyZ3MiLCJnZXRGdW5jdGlvbk5hbWUiLCJtYWtlRnVuY3Rpb25SZWZlcmVuY2UiLCJpbnN0YW50aWF0ZURlZmF1bHRMb2dnZXIiLCJpbnN0YW50aWF0ZU5vb3BMb2dnZXIiLCJQYWdpbmF0ZWRRdWVyeUNsaWVudCIsIkRFRkFVTFRfRVhURU5EX1NVQlNDUklQVElPTl9GT1IiLCJFcnJvciIsImNyZWF0ZU11dGF0aW9uIiwibXV0YXRpb25SZWZlcmVuY2UiLCJjbGllbnQiLCJ1cGRhdGUiLCJtdXRhdGlvbiIsImFyZ3MiLCJhc3NlcnROb3RBY2NpZGVudGFsQXJndW1lbnQiLCJvcHRpbWlzdGljVXBkYXRlIiwid2l0aE9wdGltaXN0aWNVcGRhdGUiLCJjcmVhdGVBY3Rpb24iLCJhY3Rpb25SZWZlcmVuY2UiLCJhY3Rpb24iLCJDb252ZXhSZWFjdENsaWVudCIsInVybCIsImFkZHJlc3MiLCJzeW5jIiwiY2xvc2VkIiwiY2FjaGVkU3luYyIsIm9wdGlvbnMiLCJhZG1pbkF1dGgiLCJzZXRBZG1pbkF1dGgiLCJmYWtlVXNlcklkZW50aXR5IiwiY2FjaGVkUGFnaW5hdGVkUXVlcnlDbGllbnQiLCJ0cmFuc2l0aW9uIiwiaGFuZGxlVHJhbnNpdGlvbiIsInBhZ2luYXRlZFF1ZXJ5Q2xpZW50Iiwic2V0QXV0aCIsImZldGNoVG9rZW4iLCJvbkNoYW5nZSIsImNsZWFyQXV0aCIsInRva2VuIiwiaWRlbnRpdHkiLCJ3YXRjaFF1ZXJ5IiwicXVlcnkiLCJhcmdzQW5kT3B0aW9ucyIsIm5hbWUiLCJvblVwZGF0ZSIsImNhbGxiYWNrIiwicXVlcnlUb2tlbiIsInVuc3Vic2NyaWJlIiwic3Vic2NyaWJlIiwiY3VycmVudExpc3RlbmVycyIsImxpc3RlbmVycyIsImdldCIsImFkZCIsInNldCIsIlNldCIsImN1cnJlbnRMaXN0ZW5lcnMyIiwiZGVsZXRlIiwic2l6ZSIsImxvY2FsUXVlcnlSZXN1bHQiLCJsb2NhbFF1ZXJ5TG9ncyIsImpvdXJuYWwiLCJxdWVyeUpvdXJuYWwiLCJwcmV3YXJtUXVlcnkiLCJxdWVyeU9wdGlvbnMiLCJleHRlbmRTdWJzY3JpcHRpb25Gb3IiLCJ3YXRjaCIsInNldFRpbWVvdXQiLCJ3YXRjaFBhZ2luYXRlZFF1ZXJ5IiwicGFnaW5hdGVkUXVlcnlUb2tlbiIsImV4aXN0aW5nUmVzdWx0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJlIiwiY29ubmVjdGlvblN0YXRlIiwic3Vic2NyaWJlVG9Db25uZWN0aW9uU3RhdGUiLCJjYiIsImxvZ2dlciIsIl9sb2dnZXIiLCJjbG9zZSIsIk1hcCIsInNpbXBsZSIsInF1ZXJpZXMiLCJtYXAiLCJxIiwicGFnaW5hdGVkIiwicGFnaW5hdGVkUXVlcmllcyIsInVwZGF0ZWRRdWVyaWVzIiwiY2FsbGJhY2tzIiwiY29uc3RydWN0b3IiLCJpbmNsdWRlcyIsInZlcmJvc2UiLCJDb252ZXhDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnZleCIsIkNvbnZleFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ1c2VRdWVyeSIsInNraXAiLCJhcmdzT2JqZWN0IiwicXVlcnlSZWZlcmVuY2UiLCJxdWVyeU5hbWUiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzdWx0cyIsInJlc3VsdCIsInVzZU11dGF0aW9uIiwiY29udmV4IiwidXNlQWN0aW9uIiwidXNlQ29udmV4Q29ubmVjdGlvblN0YXRlIiwiZ2V0Q3VycmVudFZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/react/client.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/react/hydration.js":
/*!*********************************************************!*\
  !*** ./node_modules/convex/dist/esm/react/hydration.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   usePreloadedQuery: function() { return /* binding */ usePreloadedQuery; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _react_client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../react/client.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/client.js\");\n/* harmony import */ var _server_api_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../server/api.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/server/api.js\");\n/* harmony import */ var _values_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../values/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/index.js\");\nvar _s = $RefreshSig$();\n\"use strict\";\n\n\n\n\nfunction usePreloadedQuery(preloadedQuery) {\n    _s();\n    const args = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_values_index_js__WEBPACK_IMPORTED_MODULE_3__.jsonToConvex)(preloadedQuery._argsJSON), [\n        preloadedQuery._argsJSON\n    ]);\n    const preloadedResult = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_values_index_js__WEBPACK_IMPORTED_MODULE_3__.jsonToConvex)(preloadedQuery._valueJSON), [\n        preloadedQuery._valueJSON\n    ]);\n    const result = (0,_react_client_js__WEBPACK_IMPORTED_MODULE_1__.useQuery)((0,_server_api_js__WEBPACK_IMPORTED_MODULE_2__.makeFunctionReference)(preloadedQuery._name), args);\n    return result === void 0 ? preloadedResult : result;\n} //# sourceMappingURL=hydration.js.map\n_s(usePreloadedQuery, \"/cOfU2vNsyjh/rmRqgnYmz1yGAg=\", false, function() {\n    return [\n        _react_client_js__WEBPACK_IMPORTED_MODULE_1__.useQuery\n    ];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vcmVhY3QvaHlkcmF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ2dDO0FBQ2M7QUFDVztBQUNQO0FBQzNDLFNBQVNJLGtCQUFrQkMsY0FBYzs7SUFDOUMsTUFBTUMsT0FBT04sOENBQU9BLENBQ2xCLElBQU1HLDhEQUFZQSxDQUFDRSxlQUFlRSxTQUFTLEdBQzNDO1FBQUNGLGVBQWVFLFNBQVM7S0FBQztJQUU1QixNQUFNQyxrQkFBa0JSLDhDQUFPQSxDQUM3QixJQUFNRyw4REFBWUEsQ0FBQ0UsZUFBZUksVUFBVSxHQUM1QztRQUFDSixlQUFlSSxVQUFVO0tBQUM7SUFFN0IsTUFBTUMsU0FBU1QsMERBQVFBLENBQ3JCQyxxRUFBcUJBLENBQUNHLGVBQWVNLEtBQUssR0FDMUNMO0lBRUYsT0FBT0ksV0FBVyxLQUFLLElBQUlGLGtCQUFrQkU7QUFDL0MsRUFDQSxxQ0FBcUM7R0FmckJOOztRQVNDSCxzREFBUUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9yZWFjdC9oeWRyYXRpb24uanM/ODIxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVF1ZXJ5IH0gZnJvbSBcIi4uL3JlYWN0L2NsaWVudC5qc1wiO1xuaW1wb3J0IHsgbWFrZUZ1bmN0aW9uUmVmZXJlbmNlIH0gZnJvbSBcIi4uL3NlcnZlci9hcGkuanNcIjtcbmltcG9ydCB7IGpzb25Ub0NvbnZleCB9IGZyb20gXCIuLi92YWx1ZXMvaW5kZXguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VQcmVsb2FkZWRRdWVyeShwcmVsb2FkZWRRdWVyeSkge1xuICBjb25zdCBhcmdzID0gdXNlTWVtbyhcbiAgICAoKSA9PiBqc29uVG9Db252ZXgocHJlbG9hZGVkUXVlcnkuX2FyZ3NKU09OKSxcbiAgICBbcHJlbG9hZGVkUXVlcnkuX2FyZ3NKU09OXVxuICApO1xuICBjb25zdCBwcmVsb2FkZWRSZXN1bHQgPSB1c2VNZW1vKFxuICAgICgpID0+IGpzb25Ub0NvbnZleChwcmVsb2FkZWRRdWVyeS5fdmFsdWVKU09OKSxcbiAgICBbcHJlbG9hZGVkUXVlcnkuX3ZhbHVlSlNPTl1cbiAgKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlUXVlcnkoXG4gICAgbWFrZUZ1bmN0aW9uUmVmZXJlbmNlKHByZWxvYWRlZFF1ZXJ5Ll9uYW1lKSxcbiAgICBhcmdzXG4gICk7XG4gIHJldHVybiByZXN1bHQgPT09IHZvaWQgMCA/IHByZWxvYWRlZFJlc3VsdCA6IHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh5ZHJhdGlvbi5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VNZW1vIiwidXNlUXVlcnkiLCJtYWtlRnVuY3Rpb25SZWZlcmVuY2UiLCJqc29uVG9Db252ZXgiLCJ1c2VQcmVsb2FkZWRRdWVyeSIsInByZWxvYWRlZFF1ZXJ5IiwiYXJncyIsIl9hcmdzSlNPTiIsInByZWxvYWRlZFJlc3VsdCIsIl92YWx1ZUpTT04iLCJyZXN1bHQiLCJfbmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/react/hydration.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/react/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/convex/dist/esm/react/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthLoading: function() { return /* reexport safe */ _auth_helpers_js__WEBPACK_IMPORTED_MODULE_3__.AuthLoading; },\n/* harmony export */   Authenticated: function() { return /* reexport safe */ _auth_helpers_js__WEBPACK_IMPORTED_MODULE_3__.Authenticated; },\n/* harmony export */   ConvexProvider: function() { return /* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_7__.ConvexProvider; },\n/* harmony export */   ConvexProviderWithAuth: function() { return /* reexport safe */ _ConvexAuthState_js__WEBPACK_IMPORTED_MODULE_4__.ConvexProviderWithAuth; },\n/* harmony export */   ConvexReactClient: function() { return /* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_7__.ConvexReactClient; },\n/* harmony export */   Unauthenticated: function() { return /* reexport safe */ _auth_helpers_js__WEBPACK_IMPORTED_MODULE_3__.Unauthenticated; },\n/* harmony export */   includePage: function() { return /* reexport safe */ _use_paginated_query_js__WEBPACK_IMPORTED_MODULE_0__.includePage; },\n/* harmony export */   insertAtBottomIfLoaded: function() { return /* reexport safe */ _use_paginated_query_js__WEBPACK_IMPORTED_MODULE_0__.insertAtBottomIfLoaded; },\n/* harmony export */   insertAtPosition: function() { return /* reexport safe */ _use_paginated_query_js__WEBPACK_IMPORTED_MODULE_0__.insertAtPosition; },\n/* harmony export */   insertAtTop: function() { return /* reexport safe */ _use_paginated_query_js__WEBPACK_IMPORTED_MODULE_0__.insertAtTop; },\n/* harmony export */   optimisticallyUpdateValueInPaginatedQuery: function() { return /* reexport safe */ _use_paginated_query_js__WEBPACK_IMPORTED_MODULE_0__.optimisticallyUpdateValueInPaginatedQuery; },\n/* harmony export */   page: function() { return /* reexport safe */ _use_paginated_query_js__WEBPACK_IMPORTED_MODULE_0__.page; },\n/* harmony export */   resetPaginationId: function() { return /* reexport safe */ _use_paginated_query_js__WEBPACK_IMPORTED_MODULE_0__.resetPaginationId; },\n/* harmony export */   useAction: function() { return /* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_7__.useAction; },\n/* harmony export */   useConvex: function() { return /* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_7__.useConvex; },\n/* harmony export */   useConvexAuth: function() { return /* reexport safe */ _ConvexAuthState_js__WEBPACK_IMPORTED_MODULE_4__.useConvexAuth; },\n/* harmony export */   useConvexConnectionState: function() { return /* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_7__.useConvexConnectionState; },\n/* harmony export */   useMutation: function() { return /* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_7__.useMutation; },\n/* harmony export */   usePaginatedQuery: function() { return /* reexport safe */ _use_paginated_query_js__WEBPACK_IMPORTED_MODULE_0__.usePaginatedQuery; },\n/* harmony export */   usePaginatedQueryInternal: function() { return /* reexport safe */ _use_paginated_query_js__WEBPACK_IMPORTED_MODULE_0__.usePaginatedQueryInternal; },\n/* harmony export */   usePaginatedQuery_experimental: function() { return /* reexport safe */ _use_paginated_query2_js__WEBPACK_IMPORTED_MODULE_1__.usePaginatedQuery_experimental; },\n/* harmony export */   usePreloadedQuery: function() { return /* reexport safe */ _hydration_js__WEBPACK_IMPORTED_MODULE_5__.usePreloadedQuery; },\n/* harmony export */   useQueries: function() { return /* reexport safe */ _use_queries_js__WEBPACK_IMPORTED_MODULE_2__.useQueries; },\n/* harmony export */   useQuery: function() { return /* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_7__.useQuery; },\n/* harmony export */   useSubscription: function() { return /* reexport safe */ _use_subscription_js__WEBPACK_IMPORTED_MODULE_6__.useSubscription; }\n/* harmony export */ });\n/* harmony import */ var _use_paginated_query_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./use_paginated_query.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/use_paginated_query.js\");\n/* harmony import */ var _use_paginated_query2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./use_paginated_query2.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/use_paginated_query2.js\");\n/* harmony import */ var _use_queries_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use_queries.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/use_queries.js\");\n/* harmony import */ var _auth_helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./auth_helpers.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/auth_helpers.js\");\n/* harmony import */ var _ConvexAuthState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ConvexAuthState.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/ConvexAuthState.js\");\n/* harmony import */ var _hydration_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hydration.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/hydration.js\");\n/* harmony import */ var _use_subscription_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./use_subscription.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/use_subscription.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./client.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/client.js\");\n\n\n\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vcmVhY3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDNEI7QUFDa0M7QUFDZDtBQUNmO0FBQ1o7QUFDRztBQUNOO0FBQ3lCO0FBU25DLENBQ3JCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3JlYWN0L2luZGV4LmpzPzM1NWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnQgKiBmcm9tIFwiLi91c2VfcGFnaW5hdGVkX3F1ZXJ5LmpzXCI7XG5leHBvcnQgeyB1c2VQYWdpbmF0ZWRRdWVyeV9leHBlcmltZW50YWwgfSBmcm9tIFwiLi91c2VfcGFnaW5hdGVkX3F1ZXJ5Mi5qc1wiO1xuZXhwb3J0IHsgdXNlUGFnaW5hdGVkUXVlcnkgfSBmcm9tIFwiLi91c2VfcGFnaW5hdGVkX3F1ZXJ5LmpzXCI7XG5leHBvcnQgeyB1c2VRdWVyaWVzIH0gZnJvbSBcIi4vdXNlX3F1ZXJpZXMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2F1dGhfaGVscGVycy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vQ29udmV4QXV0aFN0YXRlLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9oeWRyYXRpb24uanNcIjtcbmV4cG9ydCB7IHVzZVN1YnNjcmlwdGlvbiB9IGZyb20gXCIuL3VzZV9zdWJzY3JpcHRpb24uanNcIjtcbmV4cG9ydCB7XG4gIENvbnZleFJlYWN0Q2xpZW50LFxuICB1c2VDb252ZXgsXG4gIENvbnZleFByb3ZpZGVyLFxuICB1c2VRdWVyeSxcbiAgdXNlTXV0YXRpb24sXG4gIHVzZUFjdGlvbixcbiAgdXNlQ29udmV4Q29ubmVjdGlvblN0YXRlXG59IGZyb20gXCIuL2NsaWVudC5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsidXNlUGFnaW5hdGVkUXVlcnlfZXhwZXJpbWVudGFsIiwidXNlUGFnaW5hdGVkUXVlcnkiLCJ1c2VRdWVyaWVzIiwidXNlU3Vic2NyaXB0aW9uIiwiQ29udmV4UmVhY3RDbGllbnQiLCJ1c2VDb252ZXgiLCJDb252ZXhQcm92aWRlciIsInVzZVF1ZXJ5IiwidXNlTXV0YXRpb24iLCJ1c2VBY3Rpb24iLCJ1c2VDb252ZXhDb25uZWN0aW9uU3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/react/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/react/queries_observer.js":
/*!****************************************************************!*\
  !*** ./node_modules/convex/dist/esm/react/queries_observer.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueriesObserver: function() { return /* binding */ QueriesObserver; }\n/* harmony export */ });\n/* harmony import */ var _values_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../values/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/index.js\");\n/* harmony import */ var _server_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server/api.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/server/api.js\");\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n\nclass QueriesObserver {\n    setQueries(newQueries) {\n        for (const identifier of Object.keys(newQueries)){\n            const { query, args, paginationOptions } = newQueries[identifier];\n            (0,_server_api_js__WEBPACK_IMPORTED_MODULE_1__.getFunctionName)(query);\n            if (this.queries[identifier] === void 0) {\n                this.addQuery(identifier, query, args, paginationOptions ? {\n                    paginationOptions\n                } : {});\n            } else {\n                const existingInfo = this.queries[identifier];\n                if ((0,_server_api_js__WEBPACK_IMPORTED_MODULE_1__.getFunctionName)(query) !== (0,_server_api_js__WEBPACK_IMPORTED_MODULE_1__.getFunctionName)(existingInfo.query) || JSON.stringify((0,_values_index_js__WEBPACK_IMPORTED_MODULE_0__.convexToJson)(args)) !== JSON.stringify((0,_values_index_js__WEBPACK_IMPORTED_MODULE_0__.convexToJson)(existingInfo.args)) || JSON.stringify(paginationOptions) !== JSON.stringify(existingInfo.paginationOptions)) {\n                    this.removeQuery(identifier);\n                    this.addQuery(identifier, query, args, paginationOptions ? {\n                        paginationOptions\n                    } : {});\n                }\n            }\n        }\n        for (const identifier of Object.keys(this.queries)){\n            if (newQueries[identifier] === void 0) {\n                this.removeQuery(identifier);\n            }\n        }\n    }\n    subscribe(listener) {\n        this.listeners.add(listener);\n        return ()=>{\n            this.listeners.delete(listener);\n        };\n    }\n    getLocalResults(queries) {\n        const result = {};\n        for (const identifier of Object.keys(queries)){\n            const { query, args } = queries[identifier];\n            const paginationOptions = queries[identifier].paginationOptions;\n            (0,_server_api_js__WEBPACK_IMPORTED_MODULE_1__.getFunctionName)(query);\n            const watch = this.createWatch(query, args, paginationOptions ? {\n                paginationOptions\n            } : {});\n            let value;\n            try {\n                value = watch.localQueryResult();\n            } catch (e) {\n                if (e instanceof Error) {\n                    value = e;\n                } else {\n                    throw e;\n                }\n            }\n            result[identifier] = value;\n        }\n        return result;\n    }\n    setCreateWatch(createWatch) {\n        this.createWatch = createWatch;\n        for (const identifier of Object.keys(this.queries)){\n            const { query, args, watch, paginationOptions } = this.queries[identifier];\n            const journal = \"journal\" in watch ? watch.journal() : void 0;\n            this.removeQuery(identifier);\n            this.addQuery(identifier, query, args, {\n                ...journal ? {\n                    journal\n                } : [],\n                ...paginationOptions ? {\n                    paginationOptions\n                } : {}\n            });\n        }\n    }\n    destroy() {\n        for (const identifier of Object.keys(this.queries)){\n            this.removeQuery(identifier);\n        }\n        this.listeners = /* @__PURE__ */ new Set();\n    }\n    addQuery(identifier, query, args, param) {\n        let { paginationOptions, journal } = param;\n        if (this.queries[identifier] !== void 0) {\n            throw new Error(\"Tried to add a new query with identifier \".concat(identifier, \" when it already exists.\"));\n        }\n        const watch = this.createWatch(query, args, {\n            ...journal ? {\n                journal\n            } : [],\n            ...paginationOptions ? {\n                paginationOptions\n            } : {}\n        });\n        const unsubscribe = watch.onUpdate(()=>this.notifyListeners());\n        this.queries[identifier] = {\n            query,\n            args,\n            watch,\n            unsubscribe,\n            ...paginationOptions ? {\n                paginationOptions\n            } : {}\n        };\n    }\n    removeQuery(identifier) {\n        const info = this.queries[identifier];\n        if (info === void 0) {\n            throw new Error(\"No query found with identifier \".concat(identifier, \".\"));\n        }\n        info.unsubscribe();\n        delete this.queries[identifier];\n    }\n    notifyListeners() {\n        for (const listener of this.listeners){\n            listener();\n        }\n    }\n    constructor(createWatch){\n        __publicField(this, \"createWatch\");\n        __publicField(this, \"queries\");\n        __publicField(this, \"listeners\");\n        this.createWatch = createWatch;\n        this.queries = {};\n        this.listeners = /* @__PURE__ */ new Set();\n    }\n} //# sourceMappingURL=queries_observer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vcmVhY3QvcXVlcmllc19vYnNlcnZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBYTtBQUNiLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsa0JBQWtCLENBQUNDLEtBQUtDLEtBQUtDLFFBQVVELE9BQU9ELE1BQU1KLFVBQVVJLEtBQUtDLEtBQUs7UUFBRUUsWUFBWTtRQUFNQyxjQUFjO1FBQU1DLFVBQVU7UUFBTUg7SUFBTSxLQUFLRixHQUFHLENBQUNDLElBQUksR0FBR0M7QUFDMUosSUFBSUksZ0JBQWdCLENBQUNOLEtBQUtDLEtBQUtDLFFBQVVILGdCQUFnQkMsS0FBSyxPQUFPQyxRQUFRLFdBQVdBLE1BQU0sS0FBS0EsS0FBS0M7QUFDdEQ7QUFDQztBQUM1QyxNQUFNTztJQVNYQyxXQUFXQyxVQUFVLEVBQUU7UUFDckIsS0FBSyxNQUFNQyxjQUFjZixPQUFPZ0IsSUFBSSxDQUFDRixZQUFhO1lBQ2hELE1BQU0sRUFBRUcsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLGlCQUFpQixFQUFFLEdBQUdMLFVBQVUsQ0FBQ0MsV0FBVztZQUNqRUosK0RBQWVBLENBQUNNO1lBQ2hCLElBQUksSUFBSSxDQUFDRyxPQUFPLENBQUNMLFdBQVcsS0FBSyxLQUFLLEdBQUc7Z0JBQ3ZDLElBQUksQ0FBQ00sUUFBUSxDQUNYTixZQUNBRSxPQUNBQyxNQUNBQyxvQkFBb0I7b0JBQUVBO2dCQUFrQixJQUFJLENBQUM7WUFFakQsT0FBTztnQkFDTCxNQUFNRyxlQUFlLElBQUksQ0FBQ0YsT0FBTyxDQUFDTCxXQUFXO2dCQUM3QyxJQUFJSiwrREFBZUEsQ0FBQ00sV0FBV04sK0RBQWVBLENBQUNXLGFBQWFMLEtBQUssS0FBS00sS0FBS0MsU0FBUyxDQUFDZCw4REFBWUEsQ0FBQ1EsV0FBV0ssS0FBS0MsU0FBUyxDQUFDZCw4REFBWUEsQ0FBQ1ksYUFBYUosSUFBSSxNQUFNSyxL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WUFDMUMsR0FBR3FCLFVBQVU7Z0JBQUVBO1lBQVEsSUFBSSxFQUFFO1lBQzdCLEdBQUdwQixvQkFBb0I7Z0JBQUVBO1lBQWtCLElBQUksQ0FBQyxDQUFDO1FBQ25EO1FBQ0EsTUFBTXVCLGNBQWNULE1BQU1VLFFBQVEsQ0FBQyxJQUFNLElBQUksQ0FBQ0MsZUFBZTtRQUM3RCxJQUFJLENBQUN4QixPQUFPLENBQUNMLFdBQVcsR0FBRztZQUN6QkU7WUFDQUM7WUFDQWU7WUFDQVM7WUFDQSxHQUFHdkIsb0JBQW9CO2dCQUFFQTtZQUFrQixJQUFJLENBQUMsQ0FBQztRQUNuRDtJQUNGO0lBQ0FNLFlBQVlWLFVBQVUsRUFBRTtRQUN0QixNQUFNOEIsT0FBTyxJQUFJLENBQUN6QixPQUFPLENBQUNMLFdBQVc7UUFDckMsSUFBSThCLFNBQVMsS0FBSyxHQUFHO1lBQ25CLE1BQU0sSUFBSVIsTUFBTSxrQ0FBNkMsT0FBWHRCLFlBQVc7UUFDL0Q7UUFDQThCLEtBQUtILFdBQVc7UUFDaEIsT0FBTyxJQUFJLENBQUN0QixPQUFPLENBQUNMLFdBQVc7SUFDakM7SUFDQTZCLGtCQUFrQjtRQUNoQixLQUFLLE1BQU1qQixZQUFZLElBQUksQ0FBQ0MsU0FBUyxDQUFFO1lBQ3JDRDtRQUNGO0lBQ0Y7SUF6SEFtQixZQUFZWixXQUFXLENBQUU7UUFDdkJ6QixjQUFjLElBQUksRUFBRTtRQUNwQkEsY0FBYyxJQUFJLEVBQUU7UUFDcEJBLGNBQWMsSUFBSSxFQUFFO1FBQ3BCLElBQUksQ0FBQ3lCLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDZCxPQUFPLEdBQUcsQ0FBQztRQUNoQixJQUFJLENBQUNRLFNBQVMsR0FBRyxhQUFhLEdBQUcsSUFBSWE7SUFDdkM7QUFtSEYsRUFDQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9yZWFjdC9xdWVyaWVzX29ic2VydmVyLmpzPzk0MmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuaW1wb3J0IHsgY29udmV4VG9Kc29uIH0gZnJvbSBcIi4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0RnVuY3Rpb25OYW1lIH0gZnJvbSBcIi4uL3NlcnZlci9hcGkuanNcIjtcbmV4cG9ydCBjbGFzcyBRdWVyaWVzT2JzZXJ2ZXIge1xuICBjb25zdHJ1Y3RvcihjcmVhdGVXYXRjaCkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjcmVhdGVXYXRjaFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicXVlcmllc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibGlzdGVuZXJzXCIpO1xuICAgIHRoaXMuY3JlYXRlV2F0Y2ggPSBjcmVhdGVXYXRjaDtcbiAgICB0aGlzLnF1ZXJpZXMgPSB7fTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIH1cbiAgc2V0UXVlcmllcyhuZXdRdWVyaWVzKSB7XG4gICAgZm9yIChjb25zdCBpZGVudGlmaWVyIG9mIE9iamVjdC5rZXlzKG5ld1F1ZXJpZXMpKSB7XG4gICAgICBjb25zdCB7IHF1ZXJ5LCBhcmdzLCBwYWdpbmF0aW9uT3B0aW9ucyB9ID0gbmV3UXVlcmllc1tpZGVudGlmaWVyXTtcbiAgICAgIGdldEZ1bmN0aW9uTmFtZShxdWVyeSk7XG4gICAgICBpZiAodGhpcy5xdWVyaWVzW2lkZW50aWZpZXJdID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5hZGRRdWVyeShcbiAgICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgcGFnaW5hdGlvbk9wdGlvbnMgPyB7IHBhZ2luYXRpb25PcHRpb25zIH0gOiB7fVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbmZvID0gdGhpcy5xdWVyaWVzW2lkZW50aWZpZXJdO1xuICAgICAgICBpZiAoZ2V0RnVuY3Rpb25OYW1lKHF1ZXJ5KSAhPT0gZ2V0RnVuY3Rpb25OYW1lKGV4aXN0aW5nSW5mby5xdWVyeSkgfHwgSlNPTi5zdHJpbmdpZnkoY29udmV4VG9Kc29uKGFyZ3MpKSAhPT0gSlNPTi5zdHJpbmdpZnkoY29udmV4VG9Kc29uKGV4aXN0aW5nSW5mby5hcmdzKSkgfHwgSlNPTi5zdHJpbmdpZnkocGFnaW5hdGlvbk9wdGlvbnMpICE9PSBKU09OLnN0cmluZ2lmeShleGlzdGluZ0luZm8ucGFnaW5hdGlvbk9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVRdWVyeShpZGVudGlmaWVyKTtcbiAgICAgICAgICB0aGlzLmFkZFF1ZXJ5KFxuICAgICAgICAgICAgaWRlbnRpZmllcixcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgIHBhZ2luYXRpb25PcHRpb25zID8geyBwYWdpbmF0aW9uT3B0aW9ucyB9IDoge31cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgaWRlbnRpZmllciBvZiBPYmplY3Qua2V5cyh0aGlzLnF1ZXJpZXMpKSB7XG4gICAgICBpZiAobmV3UXVlcmllc1tpZGVudGlmaWVyXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUXVlcnkoaWRlbnRpZmllcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIHRoaXMubGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgfTtcbiAgfVxuICBnZXRMb2NhbFJlc3VsdHMocXVlcmllcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgaWRlbnRpZmllciBvZiBPYmplY3Qua2V5cyhxdWVyaWVzKSkge1xuICAgICAgY29uc3QgeyBxdWVyeSwgYXJncyB9ID0gcXVlcmllc1tpZGVudGlmaWVyXTtcbiAgICAgIGNvbnN0IHBhZ2luYXRpb25PcHRpb25zID0gcXVlcmllc1tpZGVudGlmaWVyXS5wYWdpbmF0aW9uT3B0aW9ucztcbiAgICAgIGdldEZ1bmN0aW9uTmFtZShxdWVyeSk7XG4gICAgICBjb25zdCB3YXRjaCA9IHRoaXMuY3JlYXRlV2F0Y2goXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBhcmdzLFxuICAgICAgICBwYWdpbmF0aW9uT3B0aW9ucyA/IHsgcGFnaW5hdGlvbk9wdGlvbnMgfSA6IHt9XG4gICAgICApO1xuICAgICAgbGV0IHZhbHVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSB3YXRjaC5sb2NhbFF1ZXJ5UmVzdWx0KCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICB2YWx1ZSA9IGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0W2lkZW50aWZpZXJdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc2V0Q3JlYXRlV2F0Y2goY3JlYXRlV2F0Y2gpIHtcbiAgICB0aGlzLmNyZWF0ZVdhdGNoID0gY3JlYXRlV2F0Y2g7XG4gICAgZm9yIChjb25zdCBpZGVudGlmaWVyIG9mIE9iamVjdC5rZXlzKHRoaXMucXVlcmllcykpIHtcbiAgICAgIGNvbnN0IHsgcXVlcnksIGFyZ3MsIHdhdGNoLCBwYWdpbmF0aW9uT3B0aW9ucyB9ID0gdGhpcy5xdWVyaWVzW2lkZW50aWZpZXJdO1xuICAgICAgY29uc3Qgam91cm5hbCA9IFwiam91cm5hbFwiIGluIHdhdGNoID8gd2F0Y2guam91cm5hbCgpIDogdm9pZCAwO1xuICAgICAgdGhpcy5yZW1vdmVRdWVyeShpZGVudGlmaWVyKTtcbiAgICAgIHRoaXMuYWRkUXVlcnkoaWRlbnRpZmllciwgcXVlcnksIGFyZ3MsIHtcbiAgICAgICAgLi4uam91cm5hbCA/IHsgam91cm5hbCB9IDogW10sXG4gICAgICAgIC4uLnBhZ2luYXRpb25PcHRpb25zID8geyBwYWdpbmF0aW9uT3B0aW9ucyB9IDoge31cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgaWRlbnRpZmllciBvZiBPYmplY3Qua2V5cyh0aGlzLnF1ZXJpZXMpKSB7XG4gICAgICB0aGlzLnJlbW92ZVF1ZXJ5KGlkZW50aWZpZXIpO1xuICAgIH1cbiAgICB0aGlzLmxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIH1cbiAgYWRkUXVlcnkoaWRlbnRpZmllciwgcXVlcnksIGFyZ3MsIHtcbiAgICBwYWdpbmF0aW9uT3B0aW9ucyxcbiAgICBqb3VybmFsXG4gIH0pIHtcbiAgICBpZiAodGhpcy5xdWVyaWVzW2lkZW50aWZpZXJdICE9PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRyaWVkIHRvIGFkZCBhIG5ldyBxdWVyeSB3aXRoIGlkZW50aWZpZXIgJHtpZGVudGlmaWVyfSB3aGVuIGl0IGFscmVhZHkgZXhpc3RzLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHdhdGNoID0gdGhpcy5jcmVhdGVXYXRjaChxdWVyeSwgYXJncywge1xuICAgICAgLi4uam91cm5hbCA/IHsgam91cm5hbCB9IDogW10sXG4gICAgICAuLi5wYWdpbmF0aW9uT3B0aW9ucyA/IHsgcGFnaW5hdGlvbk9wdGlvbnMgfSA6IHt9XG4gICAgfSk7XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSB3YXRjaC5vblVwZGF0ZSgoKSA9PiB0aGlzLm5vdGlmeUxpc3RlbmVycygpKTtcbiAgICB0aGlzLnF1ZXJpZXNbaWRlbnRpZmllcl0gPSB7XG4gICAgICBxdWVyeSxcbiAgICAgIGFyZ3MsXG4gICAgICB3YXRjaCxcbiAgICAgIHVuc3Vic2NyaWJlLFxuICAgICAgLi4ucGFnaW5hdGlvbk9wdGlvbnMgPyB7IHBhZ2luYXRpb25PcHRpb25zIH0gOiB7fVxuICAgIH07XG4gIH1cbiAgcmVtb3ZlUXVlcnkoaWRlbnRpZmllcikge1xuICAgIGNvbnN0IGluZm8gPSB0aGlzLnF1ZXJpZXNbaWRlbnRpZmllcl07XG4gICAgaWYgKGluZm8gPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBxdWVyeSBmb3VuZCB3aXRoIGlkZW50aWZpZXIgJHtpZGVudGlmaWVyfS5gKTtcbiAgICB9XG4gICAgaW5mby51bnN1YnNjcmliZSgpO1xuICAgIGRlbGV0ZSB0aGlzLnF1ZXJpZXNbaWRlbnRpZmllcl07XG4gIH1cbiAgbm90aWZ5TGlzdGVuZXJzKCkge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyaWVzX29ic2VydmVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19kZWZOb3JtYWxQcm9wIiwib2JqIiwia2V5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX3B1YmxpY0ZpZWxkIiwiY29udmV4VG9Kc29uIiwiZ2V0RnVuY3Rpb25OYW1lIiwiUXVlcmllc09ic2VydmVyIiwic2V0UXVlcmllcyIsIm5ld1F1ZXJpZXMiLCJpZGVudGlmaWVyIiwia2V5cyIsInF1ZXJ5IiwiYXJncyIsInBhZ2luYXRpb25PcHRpb25zIiwicXVlcmllcyIsImFkZFF1ZXJ5IiwiZXhpc3RpbmdJbmZvIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlbW92ZVF1ZXJ5Iiwic3Vic2NyaWJlIiwibGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJhZGQiLCJkZWxldGUiLCJnZXRMb2NhbFJlc3VsdHMiLCJyZXN1bHQiLCJ3YXRjaCIsImNyZWF0ZVdhdGNoIiwibG9jYWxRdWVyeVJlc3VsdCIsImUiLCJFcnJvciIsInNldENyZWF0ZVdhdGNoIiwiam91cm5hbCIsImRlc3Ryb3kiLCJTZXQiLCJ1bnN1YnNjcmliZSIsIm9uVXBkYXRlIiwibm90aWZ5TGlzdGVuZXJzIiwiaW5mbyIsImNvbnN0cnVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/react/queries_observer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/react/use_paginated_query.js":
/*!*******************************************************************!*\
  !*** ./node_modules/convex/dist/esm/react/use_paginated_query.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   includePage: function() { return /* binding */ includePage; },\n/* harmony export */   insertAtBottomIfLoaded: function() { return /* binding */ insertAtBottomIfLoaded; },\n/* harmony export */   insertAtPosition: function() { return /* binding */ insertAtPosition; },\n/* harmony export */   insertAtTop: function() { return /* binding */ insertAtTop; },\n/* harmony export */   optimisticallyUpdateValueInPaginatedQuery: function() { return /* binding */ optimisticallyUpdateValueInPaginatedQuery; },\n/* harmony export */   page: function() { return /* binding */ page; },\n/* harmony export */   resetPaginationId: function() { return /* binding */ resetPaginationId; },\n/* harmony export */   usePaginatedQuery: function() { return /* binding */ usePaginatedQuery; },\n/* harmony export */   usePaginatedQueryInternal: function() { return /* binding */ usePaginatedQueryInternal; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _values_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../values/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/index.js\");\n/* harmony import */ var _use_queries_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use_queries.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/use_queries.js\");\n/* harmony import */ var _server_api_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../server/api.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/server/api.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./client.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/client.js\");\n/* harmony import */ var _values_compare_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../values/compare.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/compare.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\"use strict\";\n\n\n\n\n\n\nconst splitQuery = (key, splitCursor, continueCursor)=>(prevState)=>{\n        const queries = {\n            ...prevState.queries\n        };\n        const splitKey1 = prevState.nextPageKey;\n        const splitKey2 = prevState.nextPageKey + 1;\n        const nextPageKey = prevState.nextPageKey + 2;\n        queries[splitKey1] = {\n            query: prevState.query,\n            args: {\n                ...prevState.args,\n                paginationOpts: {\n                    ...prevState.queries[key].args.paginationOpts,\n                    endCursor: splitCursor\n                }\n            }\n        };\n        queries[splitKey2] = {\n            query: prevState.query,\n            args: {\n                ...prevState.args,\n                paginationOpts: {\n                    ...prevState.queries[key].args.paginationOpts,\n                    cursor: splitCursor,\n                    endCursor: continueCursor\n                }\n            }\n        };\n        const ongoingSplits = {\n            ...prevState.ongoingSplits\n        };\n        ongoingSplits[key] = [\n            splitKey1,\n            splitKey2\n        ];\n        return {\n            ...prevState,\n            nextPageKey,\n            queries,\n            ongoingSplits\n        };\n    };\nconst completeSplitQuery = (key)=>(prevState)=>{\n        const completedSplit = prevState.ongoingSplits[key];\n        if (completedSplit === void 0) {\n            return prevState;\n        }\n        const queries = {\n            ...prevState.queries\n        };\n        delete queries[key];\n        const ongoingSplits = {\n            ...prevState.ongoingSplits\n        };\n        delete ongoingSplits[key];\n        let pageKeys = prevState.pageKeys.slice();\n        const pageIndex = prevState.pageKeys.findIndex((v)=>v === key);\n        if (pageIndex >= 0) {\n            pageKeys = [\n                ...prevState.pageKeys.slice(0, pageIndex),\n                ...completedSplit,\n                ...prevState.pageKeys.slice(pageIndex + 1)\n            ];\n        }\n        return {\n            ...prevState,\n            queries,\n            pageKeys,\n            ongoingSplits\n        };\n    };\nfunction usePaginatedQuery(query, args, options) {\n    _s();\n    const { user } = usePaginatedQueryInternal(query, args, options);\n    return user;\n}\n_s(usePaginatedQuery, \"B2M7fdOdDoM9hqoGjJbqLpq+AmM=\", false, function() {\n    return [\n        usePaginatedQueryInternal\n    ];\n});\nconst includePage = Symbol(\"includePageKeys\");\nconst page = Symbol(\"page\");\nfunction usePaginatedQueryInternal(query, args, options) {\n    _s1();\n    if (typeof (options === null || options === void 0 ? void 0 : options.initialNumItems) !== \"number\" || options.initialNumItems < 0) {\n        throw new Error(\"`options.initialNumItems` must be a positive number. Received `\".concat(options === null || options === void 0 ? void 0 : options.initialNumItems, \"`.\"));\n    }\n    const skip = args === \"skip\";\n    const argsObject = skip ? {} : args;\n    const queryName = (0,_server_api_js__WEBPACK_IMPORTED_MODULE_3__.getFunctionName)(query);\n    const createInitialState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return ()=>{\n            const id = nextPaginationId();\n            return {\n                query,\n                args: argsObject,\n                id,\n                nextPageKey: 1,\n                pageKeys: skip ? [] : [\n                    0\n                ],\n                queries: skip ? {} : {\n                    0: {\n                        query,\n                        args: {\n                            ...argsObject,\n                            paginationOpts: {\n                                numItems: options.initialNumItems,\n                                cursor: null,\n                                id\n                            }\n                        }\n                    }\n                },\n                ongoingSplits: {},\n                skip\n            };\n        };\n    }, [\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        JSON.stringify((0,_values_index_js__WEBPACK_IMPORTED_MODULE_1__.convexToJson)(argsObject)),\n        queryName,\n        options.initialNumItems,\n        skip\n    ]);\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(createInitialState);\n    let currState = state;\n    if ((0,_server_api_js__WEBPACK_IMPORTED_MODULE_3__.getFunctionName)(query) !== (0,_server_api_js__WEBPACK_IMPORTED_MODULE_3__.getFunctionName)(state.query) || JSON.stringify((0,_values_index_js__WEBPACK_IMPORTED_MODULE_1__.convexToJson)(argsObject)) !== JSON.stringify((0,_values_index_js__WEBPACK_IMPORTED_MODULE_1__.convexToJson)(state.args)) || skip !== state.skip) {\n        currState = createInitialState();\n        setState(currState);\n    }\n    const convexClient = (0,_client_js__WEBPACK_IMPORTED_MODULE_4__.useConvex)();\n    const logger = convexClient.logger;\n    const resultsObject = (0,_use_queries_js__WEBPACK_IMPORTED_MODULE_2__.useQueries)(currState.queries);\n    var _options_includePage;\n    const isIncludingPageKeys = (_options_includePage = options[includePage]) !== null && _options_includePage !== void 0 ? _options_includePage : false;\n    const [results, maybeLastResult] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let currResult = void 0;\n        const allItems = [];\n        for (const pageKey of currState.pageKeys){\n            currResult = resultsObject[pageKey];\n            if (currResult === void 0) {\n                break;\n            }\n            if (currResult instanceof Error) {\n                var _currResult_data, _currResult_data1;\n                if (currResult.message.includes(\"InvalidCursor\") || currResult instanceof _values_index_js__WEBPACK_IMPORTED_MODULE_1__.ConvexError && typeof currResult.data === \"object\" && ((_currResult_data = currResult.data) === null || _currResult_data === void 0 ? void 0 : _currResult_data.isConvexSystemError) === true && ((_currResult_data1 = currResult.data) === null || _currResult_data1 === void 0 ? void 0 : _currResult_data1.paginationError) === \"InvalidCursor\") {\n                    logger.warn(\"usePaginatedQuery hit error, resetting pagination state: \" + currResult.message);\n                    setState(createInitialState);\n                    return [\n                        [],\n                        void 0\n                    ];\n                } else {\n                    throw currResult;\n                }\n            }\n            const ongoingSplit = currState.ongoingSplits[pageKey];\n            if (ongoingSplit !== void 0) {\n                if (resultsObject[ongoingSplit[0]] !== void 0 && resultsObject[ongoingSplit[1]] !== void 0) {\n                    setState(completeSplitQuery(pageKey));\n                }\n            } else if (currResult.splitCursor && (currResult.pageStatus === \"SplitRecommended\" || currResult.pageStatus === \"SplitRequired\" || currResult.page.length > options.initialNumItems * 2)) {\n                setState(splitQuery(pageKey, currResult.splitCursor, currResult.continueCursor));\n            }\n            if (currResult.pageStatus === \"SplitRequired\") {\n                return [\n                    allItems,\n                    void 0\n                ];\n            }\n            allItems.push(...isIncludingPageKeys ? currResult.page.map((i)=>({\n                    ...i,\n                    [page]: pageKey.toString()\n                })) : currResult.page);\n        }\n        return [\n            allItems,\n            currResult\n        ];\n    }, [\n        resultsObject,\n        currState.pageKeys,\n        currState.ongoingSplits,\n        options.initialNumItems,\n        createInitialState,\n        logger,\n        isIncludingPageKeys\n    ]);\n    const statusObject = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (maybeLastResult === void 0) {\n            if (currState.nextPageKey === 1) {\n                return {\n                    status: \"LoadingFirstPage\",\n                    isLoading: true,\n                    loadMore: (_numItems)=>{}\n                };\n            } else {\n                return {\n                    status: \"LoadingMore\",\n                    isLoading: true,\n                    loadMore: (_numItems)=>{}\n                };\n            }\n        }\n        if (maybeLastResult.isDone) {\n            return {\n                status: \"Exhausted\",\n                isLoading: false,\n                loadMore: (_numItems)=>{}\n            };\n        }\n        const continueCursor = maybeLastResult.continueCursor;\n        let alreadyLoadingMore = false;\n        return {\n            status: \"CanLoadMore\",\n            isLoading: false,\n            loadMore: (numItems)=>{\n                if (!alreadyLoadingMore) {\n                    alreadyLoadingMore = true;\n                    setState((prevState)=>{\n                        const pageKeys = [\n                            ...prevState.pageKeys,\n                            prevState.nextPageKey\n                        ];\n                        const queries = {\n                            ...prevState.queries\n                        };\n                        queries[prevState.nextPageKey] = {\n                            query: prevState.query,\n                            args: {\n                                ...prevState.args,\n                                paginationOpts: {\n                                    numItems,\n                                    cursor: continueCursor,\n                                    id: prevState.id\n                                }\n                            }\n                        };\n                        return {\n                            ...prevState,\n                            nextPageKey: prevState.nextPageKey + 1,\n                            pageKeys,\n                            queries\n                        };\n                    });\n                }\n            }\n        };\n    }, [\n        maybeLastResult,\n        currState.nextPageKey\n    ]);\n    return {\n        user: {\n            results,\n            ...statusObject\n        },\n        internal: {\n            state: currState\n        }\n    };\n}\n_s1(usePaginatedQueryInternal, \"x1EhudgnhdYQsmoNTE/UgWV3rcM=\", false, function() {\n    return [\n        _client_js__WEBPACK_IMPORTED_MODULE_4__.useConvex,\n        _use_queries_js__WEBPACK_IMPORTED_MODULE_2__.useQueries\n    ];\n});\nlet paginationId = 0;\nfunction nextPaginationId() {\n    paginationId++;\n    return paginationId;\n}\nfunction resetPaginationId() {\n    paginationId = 0;\n}\nfunction optimisticallyUpdateValueInPaginatedQuery(localStore, query, args, updateValue) {\n    const expectedArgs = JSON.stringify((0,_values_index_js__WEBPACK_IMPORTED_MODULE_1__.convexToJson)(args));\n    for (const queryResult of localStore.getAllQueries(query)){\n        if (queryResult.value !== void 0) {\n            const { paginationOpts: _, ...innerArgs } = queryResult.args;\n            if (JSON.stringify((0,_values_index_js__WEBPACK_IMPORTED_MODULE_1__.convexToJson)(innerArgs)) === expectedArgs) {\n                const value = queryResult.value;\n                if (typeof value === \"object\" && value !== null && Array.isArray(value.page)) {\n                    localStore.setQuery(query, queryResult.args, {\n                        ...value,\n                        page: value.page.map(updateValue)\n                    });\n                }\n            }\n        }\n    }\n}\nfunction insertAtTop(options) {\n    const { paginatedQuery, argsToMatch, localQueryStore, item } = options;\n    const queries = localQueryStore.getAllQueries(paginatedQuery);\n    const queriesThatMatch = queries.filter((q)=>{\n        if (argsToMatch === void 0) {\n            return true;\n        }\n        return Object.keys(argsToMatch).every(// @ts-expect-error -- This should be safe since both should be plain objects\n        (k)=>(0,_values_compare_js__WEBPACK_IMPORTED_MODULE_5__.compareValues)(argsToMatch[k], q.args[k]) === 0);\n    });\n    const firstPage = queriesThatMatch.find((q)=>q.args.paginationOpts.cursor === null);\n    if (firstPage === void 0 || firstPage.value === void 0) {\n        return;\n    }\n    localQueryStore.setQuery(paginatedQuery, firstPage.args, {\n        ...firstPage.value,\n        page: [\n            item,\n            ...firstPage.value.page\n        ]\n    });\n}\nfunction insertAtBottomIfLoaded(options) {\n    const { paginatedQuery, localQueryStore, item, argsToMatch } = options;\n    const queries = localQueryStore.getAllQueries(paginatedQuery);\n    const queriesThatMatch = queries.filter((q)=>{\n        if (argsToMatch === void 0) {\n            return true;\n        }\n        return Object.keys(argsToMatch).every(// @ts-expect-error -- This should be safe since both should be plain objects\n        (k)=>(0,_values_compare_js__WEBPACK_IMPORTED_MODULE_5__.compareValues)(argsToMatch[k], q.args[k]) === 0);\n    });\n    const lastPage = queriesThatMatch.find((q)=>q.value !== void 0 && q.value.isDone);\n    if (lastPage === void 0) {\n        return;\n    }\n    localQueryStore.setQuery(paginatedQuery, lastPage.args, {\n        ...lastPage.value,\n        page: [\n            ...lastPage.value.page,\n            item\n        ]\n    });\n}\nfunction insertAtPosition(options) {\n    const { paginatedQuery, sortOrder, sortKeyFromItem, localQueryStore, item, argsToMatch } = options;\n    const queries = localQueryStore.getAllQueries(paginatedQuery);\n    const queryGroups = {};\n    for (const query of queries){\n        if (argsToMatch !== void 0 && !Object.keys(argsToMatch).every((k)=>// @ts-ignore why is this not working?\n            argsToMatch[k] === query.args[k])) {\n            continue;\n        }\n        const key = JSON.stringify(Object.fromEntries(Object.entries(query.args).map((param)=>{\n            let [k, v] = param;\n            return [\n                k,\n                k === \"paginationOpts\" ? v.id : v\n            ];\n        })));\n        var _queryGroups_key;\n        (_queryGroups_key = queryGroups[key]) !== null && _queryGroups_key !== void 0 ? _queryGroups_key : queryGroups[key] = [];\n        queryGroups[key].push(query);\n    }\n    for (const pageQueries of Object.values(queryGroups)){\n        insertAtPositionInPages({\n            pageQueries,\n            paginatedQuery,\n            sortOrder,\n            sortKeyFromItem,\n            localQueryStore,\n            item\n        });\n    }\n}\nfunction insertAtPositionInPages(options) {\n    const { pageQueries, sortOrder, sortKeyFromItem, localQueryStore, item, paginatedQuery } = options;\n    const insertedKey = sortKeyFromItem(item);\n    const loadedPages = pageQueries.filter((q)=>q.value !== void 0 && q.value.page.length > 0);\n    const sortedPages = loadedPages.sort((a, b)=>{\n        const aKey = sortKeyFromItem(a.value.page[0]);\n        const bKey = sortKeyFromItem(b.value.page[0]);\n        if (sortOrder === \"asc\") {\n            return (0,_values_compare_js__WEBPACK_IMPORTED_MODULE_5__.compareValues)(aKey, bKey);\n        } else {\n            return (0,_values_compare_js__WEBPACK_IMPORTED_MODULE_5__.compareValues)(bKey, aKey);\n        }\n    });\n    const firstLoadedPage = sortedPages[0];\n    if (firstLoadedPage === void 0) {\n        return;\n    }\n    const firstPageKey = sortKeyFromItem(firstLoadedPage.value.page[0]);\n    const isBeforeFirstPage = sortOrder === \"asc\" ? (0,_values_compare_js__WEBPACK_IMPORTED_MODULE_5__.compareValues)(insertedKey, firstPageKey) <= 0 : (0,_values_compare_js__WEBPACK_IMPORTED_MODULE_5__.compareValues)(insertedKey, firstPageKey) >= 0;\n    if (isBeforeFirstPage) {\n        if (firstLoadedPage.args.paginationOpts.cursor === null) {\n            localQueryStore.setQuery(paginatedQuery, firstLoadedPage.args, {\n                ...firstLoadedPage.value,\n                page: [\n                    item,\n                    ...firstLoadedPage.value.page\n                ]\n            });\n        } else {\n            return;\n        }\n        return;\n    }\n    const lastLoadedPage = sortedPages[sortedPages.length - 1];\n    if (lastLoadedPage === void 0) {\n        return;\n    }\n    const lastPageKey = sortKeyFromItem(lastLoadedPage.value.page[lastLoadedPage.value.page.length - 1]);\n    const isAfterLastPage = sortOrder === \"asc\" ? (0,_values_compare_js__WEBPACK_IMPORTED_MODULE_5__.compareValues)(insertedKey, lastPageKey) >= 0 : (0,_values_compare_js__WEBPACK_IMPORTED_MODULE_5__.compareValues)(insertedKey, lastPageKey) <= 0;\n    if (isAfterLastPage) {\n        if (lastLoadedPage.value.isDone) {\n            localQueryStore.setQuery(paginatedQuery, lastLoadedPage.args, {\n                ...lastLoadedPage.value,\n                page: [\n                    ...lastLoadedPage.value.page,\n                    item\n                ]\n            });\n        }\n        return;\n    }\n    const successorPageIndex = sortedPages.findIndex((p)=>sortOrder === \"asc\" ? (0,_values_compare_js__WEBPACK_IMPORTED_MODULE_5__.compareValues)(sortKeyFromItem(p.value.page[0]), insertedKey) > 0 : (0,_values_compare_js__WEBPACK_IMPORTED_MODULE_5__.compareValues)(sortKeyFromItem(p.value.page[0]), insertedKey) < 0);\n    const pageToUpdate = successorPageIndex === -1 ? sortedPages[sortedPages.length - 1] : sortedPages[successorPageIndex - 1];\n    if (pageToUpdate === void 0) {\n        return;\n    }\n    const indexWithinPage = pageToUpdate.value.page.findIndex((e)=>sortOrder === \"asc\" ? (0,_values_compare_js__WEBPACK_IMPORTED_MODULE_5__.compareValues)(sortKeyFromItem(e), insertedKey) >= 0 : (0,_values_compare_js__WEBPACK_IMPORTED_MODULE_5__.compareValues)(sortKeyFromItem(e), insertedKey) <= 0);\n    const newPage = indexWithinPage === -1 ? [\n        ...pageToUpdate.value.page,\n        item\n    ] : [\n        ...pageToUpdate.value.page.slice(0, indexWithinPage),\n        item,\n        ...pageToUpdate.value.page.slice(indexWithinPage)\n    ];\n    localQueryStore.setQuery(paginatedQuery, pageToUpdate.args, {\n        ...pageToUpdate.value,\n        page: newPage\n    });\n} //# sourceMappingURL=use_paginated_query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vcmVhY3QvdXNlX3BhZ2luYXRlZF9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDMEM7QUFDcUI7QUFDakI7QUFHcEI7QUFDYztBQUNhO0FBQ3JELE1BQU1RLGFBQWEsQ0FBQ0MsS0FBS0MsYUFBYUMsaUJBQW1CLENBQUNDO1FBQ3hELE1BQU1DLFVBQVU7WUFBRSxHQUFHRCxVQUFVQyxPQUFPO1FBQUM7UUFDdkMsTUFBTUMsWUFBWUYsVUFBVUcsV0FBVztRQUN2QyxNQUFNQyxZQUFZSixVQUFVRyxXQUFXLEdBQUc7UUFDMUMsTUFBTUEsY0FBY0gsVUFBVUcsV0FBVyxHQUFHO1FBQzVDRixPQUFPLENBQUNDLFVBQVUsR0FBRztZQUNuQkcsT0FBT0wsVUFBVUssS0FBSztZQUN0QkMsTUFBTTtnQkFDSixHQUFHTixVQUFVTSxJQUFJO2dCQUNqQkMsZ0JBQWdCO29CQUNkLEdBQUdQLFVBQVVDLE9BQU8sQ0FBQ0osSUFBSSxDQUFDUyxJQUFJLENBQUNDLGNBQWM7b0JBQzdDQyxXQUFXVjtnQkFDYjtZQUNGO1FBQ0Y7UUFDQUcsT0FBTyxDQUFDRyxVQUFVLEdBQUc7WUFDbkJDLE9BQU9MLFVBQVVLLEtBQUs7WUFDdEJDLE1BQU07Z0JBQ0osR0FBR04sVUFBVU0sSUFBSTtnQkFDakJDLGdCQUFnQjtvQkFDZCxHQUFHUCxVQUFVQyxPQUFPLENBQUNKLElBQUksQ0FBQ1MsSUFBSSxDQUFDQyxjQUFjO29CQUM3Q0UsUUFBUVg7b0JBQ1JVLFdBQVdUO2dCQUNiO1lBQ0Y7UUFDRjtRQUNBLE1BQU1XLGdCQUFnQjtZQUFFLEdBQUdWLFVBQVVVLGFBQWE7UUFBQztRQUNuREEsYUFBYSxDQUFDYixJQUFJLEdBQUc7WUFBQ0s7WUFBV0U7U0FBVTtRQUMzQyxPQUFPO1lBQ0wsR0FBR0osU0FBUztZQUNaRztZQUNBRjtZQUNBUztRQUNGO0lBQ0Y7QUFDQSxN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QUMxSCxJQUFJRSxpQkFBaUIsS0FBSyxHQUFHO1FBQzNCO0lBQ0Y7SUFDQSxNQUFNQyxrQkFBa0JELGFBQWEvQyxLQUFLLENBQUNyRCxJQUFJLENBQUNSLFNBQVMsQ0FDdkQsQ0FBQzhHLElBQU0xQixjQUFjLFFBQVF6RyxpRUFBYUEsQ0FBQzBHLGdCQUFnQnlCLElBQUlsQixnQkFBZ0IsSUFBSWpILGlFQUFhQSxDQUFDMEcsZ0JBQWdCeUIsSUFBSWxCLGdCQUFnQjtJQUV2SSxNQUFNbUIsVUFBVUYsb0JBQW9CLENBQUMsSUFBSTtXQUFJRCxhQUFhL0MsS0FBSyxDQUFDckQsSUFBSTtRQUFFK0Q7S0FBSyxHQUFHO1dBQ3pFcUMsYUFBYS9DLEtBQUssQ0FBQ3JELElBQUksQ0FBQ1YsS0FBSyxDQUFDLEdBQUcrRztRQUNwQ3RDO1dBQ0dxQyxhQUFhL0MsS0FBSyxDQUFDckQsSUFBSSxDQUFDVixLQUFLLENBQUMrRztLQUNsQztJQUNEdkMsZ0JBQWdCSixRQUFRLENBQUNFLGdCQUFnQndDLGFBQWF0SCxJQUFJLEVBQUU7UUFDMUQsR0FBR3NILGFBQWEvQyxLQUFLO1FBQ3JCckQsTUFBTXVHO0lBQ1I7QUFDRixFQUNBLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3JlYWN0L3VzZV9wYWdpbmF0ZWRfcXVlcnkuanM/MzZlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IHVzZU1lbW8sIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBDb252ZXhFcnJvciwgY29udmV4VG9Kc29uIH0gZnJvbSBcIi4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgdXNlUXVlcmllcyB9IGZyb20gXCIuL3VzZV9xdWVyaWVzLmpzXCI7XG5pbXBvcnQge1xuICBnZXRGdW5jdGlvbk5hbWVcbn0gZnJvbSBcIi4uL3NlcnZlci9hcGkuanNcIjtcbmltcG9ydCB7IHVzZUNvbnZleCB9IGZyb20gXCIuL2NsaWVudC5qc1wiO1xuaW1wb3J0IHsgY29tcGFyZVZhbHVlcyB9IGZyb20gXCIuLi92YWx1ZXMvY29tcGFyZS5qc1wiO1xuY29uc3Qgc3BsaXRRdWVyeSA9IChrZXksIHNwbGl0Q3Vyc29yLCBjb250aW51ZUN1cnNvcikgPT4gKHByZXZTdGF0ZSkgPT4ge1xuICBjb25zdCBxdWVyaWVzID0geyAuLi5wcmV2U3RhdGUucXVlcmllcyB9O1xuICBjb25zdCBzcGxpdEtleTEgPSBwcmV2U3RhdGUubmV4dFBhZ2VLZXk7XG4gIGNvbnN0IHNwbGl0S2V5MiA9IHByZXZTdGF0ZS5uZXh0UGFnZUtleSArIDE7XG4gIGNvbnN0IG5leHRQYWdlS2V5ID0gcHJldlN0YXRlLm5leHRQYWdlS2V5ICsgMjtcbiAgcXVlcmllc1tzcGxpdEtleTFdID0ge1xuICAgIHF1ZXJ5OiBwcmV2U3RhdGUucXVlcnksXG4gICAgYXJnczoge1xuICAgICAgLi4ucHJldlN0YXRlLmFyZ3MsXG4gICAgICBwYWdpbmF0aW9uT3B0czoge1xuICAgICAgICAuLi5wcmV2U3RhdGUucXVlcmllc1trZXldLmFyZ3MucGFnaW5hdGlvbk9wdHMsXG4gICAgICAgIGVuZEN1cnNvcjogc3BsaXRDdXJzb3JcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHF1ZXJpZXNbc3BsaXRLZXkyXSA9IHtcbiAgICBxdWVyeTogcHJldlN0YXRlLnF1ZXJ5LFxuICAgIGFyZ3M6IHtcbiAgICAgIC4uLnByZXZTdGF0ZS5hcmdzLFxuICAgICAgcGFnaW5hdGlvbk9wdHM6IHtcbiAgICAgICAgLi4ucHJldlN0YXRlLnF1ZXJpZXNba2V5XS5hcmdzLnBhZ2luYXRpb25PcHRzLFxuICAgICAgICBjdXJzb3I6IHNwbGl0Q3Vyc29yLFxuICAgICAgICBlbmRDdXJzb3I6IGNvbnRpbnVlQ3Vyc29yXG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBvbmdvaW5nU3BsaXRzID0geyAuLi5wcmV2U3RhdGUub25nb2luZ1NwbGl0cyB9O1xuICBvbmdvaW5nU3BsaXRzW2tleV0gPSBbc3BsaXRLZXkxLCBzcGxpdEtleTJdO1xuICByZXR1cm4ge1xuICAgIC4uLnByZXZTdGF0ZSxcbiAgICBuZXh0UGFnZUtleSxcbiAgICBxdWVyaWVzLFxuICAgIG9uZ29pbmdTcGxpdHNcbiAgfTtcbn07XG5jb25zdCBjb21wbGV0ZVNwbGl0UXVlcnkgPSAoa2V5KSA9PiAocHJldlN0YXRlKSA9PiB7XG4gIGNvbnN0IGNvbXBsZXRlZFNwbGl0ID0gcHJldlN0YXRlLm9uZ29pbmdTcGxpdHNba2V5XTtcbiAgaWYgKGNvbXBsZXRlZFNwbGl0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gcHJldlN0YXRlO1xuICB9XG4gIGNvbnN0IHF1ZXJpZXMgPSB7IC4uLnByZXZTdGF0ZS5xdWVyaWVzIH07XG4gIGRlbGV0ZSBxdWVyaWVzW2tleV07XG4gIGNvbnN0IG9uZ29pbmdTcGxpdHMgPSB7IC4uLnByZXZTdGF0ZS5vbmdvaW5nU3BsaXRzIH07XG4gIGRlbGV0ZSBvbmdvaW5nU3BsaXRzW2tleV07XG4gIGxldCBwYWdlS2V5cyA9IHByZXZTdGF0ZS5wYWdlS2V5cy5zbGljZSgpO1xuICBjb25zdCBwYWdlSW5kZXggPSBwcmV2U3RhdGUucGFnZUtleXMuZmluZEluZGV4KCh2KSA9PiB2ID09PSBrZXkpO1xuICBpZiAocGFnZUluZGV4ID49IDApIHtcbiAgICBwYWdlS2V5cyA9IFtcbiAgICAgIC4uLnByZXZTdGF0ZS5wYWdlS2V5cy5zbGljZSgwLCBwYWdlSW5kZXgpLFxuICAgICAgLi4uY29tcGxldGVkU3BsaXQsXG4gICAgICAuLi5wcmV2U3RhdGUucGFnZUtleXMuc2xpY2UocGFnZUluZGV4ICsgMSlcbiAgICBdO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4ucHJldlN0YXRlLFxuICAgIHF1ZXJpZXMsXG4gICAgcGFnZUtleXMsXG4gICAgb25nb2luZ1NwbGl0c1xuICB9O1xufTtcbmV4cG9ydCBmdW5jdGlvbiB1c2VQYWdpbmF0ZWRRdWVyeShxdWVyeSwgYXJncywgb3B0aW9ucykge1xuICBjb25zdCB7IHVzZXIgfSA9IHVzZVBhZ2luYXRlZFF1ZXJ5SW50ZXJuYWwocXVlcnksIGFyZ3MsIG9wdGlvbnMpO1xuICByZXR1cm4gdXNlcjtcbn1cbmV4cG9ydCBjb25zdCBpbmNsdWRlUGFnZSA9IFN5bWJvbChcImluY2x1ZGVQYWdlS2V5c1wiKTtcbmV4cG9ydCBjb25zdCBwYWdlID0gU3ltYm9sKFwicGFnZVwiKTtcbmV4cG9ydCBmdW5jdGlvbiB1c2VQYWdpbmF0ZWRRdWVyeUludGVybmFsKHF1ZXJ5LCBhcmdzLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucz8uaW5pdGlhbE51bUl0ZW1zICE9PSBcIm51bWJlclwiIHx8IG9wdGlvbnMuaW5pdGlhbE51bUl0ZW1zIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBcXGBvcHRpb25zLmluaXRpYWxOdW1JdGVtc1xcYCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyLiBSZWNlaXZlZCBcXGAke29wdGlvbnM/LmluaXRpYWxOdW1JdGVtc31cXGAuYFxuICAgICk7XG4gIH1cbiAgY29uc3Qgc2tpcCA9IGFyZ3MgPT09IFwic2tpcFwiO1xuICBjb25zdCBhcmdzT2JqZWN0ID0gc2tpcCA/IHt9IDogYXJncztcbiAgY29uc3QgcXVlcnlOYW1lID0gZ2V0RnVuY3Rpb25OYW1lKHF1ZXJ5KTtcbiAgY29uc3QgY3JlYXRlSW5pdGlhbFN0YXRlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGlkID0gbmV4dFBhZ2luYXRpb25JZCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGFyZ3M6IGFyZ3NPYmplY3QsXG4gICAgICAgIGlkLFxuICAgICAgICBuZXh0UGFnZUtleTogMSxcbiAgICAgICAgcGFnZUtleXM6IHNraXAgPyBbXSA6IFswXSxcbiAgICAgICAgcXVlcmllczogc2tpcCA/IHt9IDoge1xuICAgICAgICAgIDA6IHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgYXJnczoge1xuICAgICAgICAgICAgICAuLi5hcmdzT2JqZWN0LFxuICAgICAgICAgICAgICBwYWdpbmF0aW9uT3B0czoge1xuICAgICAgICAgICAgICAgIG51bUl0ZW1zOiBvcHRpb25zLmluaXRpYWxOdW1JdGVtcyxcbiAgICAgICAgICAgICAgICBjdXJzb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25nb2luZ1NwbGl0czoge30sXG4gICAgICAgIHNraXBcbiAgICAgIH07XG4gICAgfTtcbiAgfSwgW1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBKU09OLnN0cmluZ2lmeShjb252ZXhUb0pzb24oYXJnc09iamVjdCkpLFxuICAgIHF1ZXJ5TmFtZSxcbiAgICBvcHRpb25zLmluaXRpYWxOdW1JdGVtcyxcbiAgICBza2lwXG4gIF0pO1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlKGNyZWF0ZUluaXRpYWxTdGF0ZSk7XG4gIGxldCBjdXJyU3RhdGUgPSBzdGF0ZTtcbiAgaWYgKGdldEZ1bmN0aW9uTmFtZShxdWVyeSkgIT09IGdldEZ1bmN0aW9uTmFtZShzdGF0ZS5xdWVyeSkgfHwgSlNPTi5zdHJpbmdpZnkoY29udmV4VG9Kc29uKGFyZ3NPYmplY3QpKSAhPT0gSlNPTi5zdHJpbmdpZnkoY29udmV4VG9Kc29uKHN0YXRlLmFyZ3MpKSB8fCBza2lwICE9PSBzdGF0ZS5za2lwKSB7XG4gICAgY3VyclN0YXRlID0gY3JlYXRlSW5pdGlhbFN0YXRlKCk7XG4gICAgc2V0U3RhdGUoY3VyclN0YXRlKTtcbiAgfVxuICBjb25zdCBjb252ZXhDbGllbnQgPSB1c2VDb252ZXgoKTtcbiAgY29uc3QgbG9nZ2VyID0gY29udmV4Q2xpZW50LmxvZ2dlcjtcbiAgY29uc3QgcmVzdWx0c09iamVjdCA9IHVzZVF1ZXJpZXMoY3VyclN0YXRlLnF1ZXJpZXMpO1xuICBjb25zdCBpc0luY2x1ZGluZ1BhZ2VLZXlzID0gb3B0aW9uc1tpbmNsdWRlUGFnZV0gPz8gZmFsc2U7XG4gIGNvbnN0IFtyZXN1bHRzLCBtYXliZUxhc3RSZXN1bHRdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IGN1cnJSZXN1bHQgPSB2b2lkIDA7XG4gICAgY29uc3QgYWxsSXRlbXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBhZ2VLZXkgb2YgY3VyclN0YXRlLnBhZ2VLZXlzKSB7XG4gICAgICBjdXJyUmVzdWx0ID0gcmVzdWx0c09iamVjdFtwYWdlS2V5XTtcbiAgICAgIGlmIChjdXJyUmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoY3VyclJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGlmIChjdXJyUmVzdWx0Lm1lc3NhZ2UuaW5jbHVkZXMoXCJJbnZhbGlkQ3Vyc29yXCIpIHx8IGN1cnJSZXN1bHQgaW5zdGFuY2VvZiBDb252ZXhFcnJvciAmJiB0eXBlb2YgY3VyclJlc3VsdC5kYXRhID09PSBcIm9iamVjdFwiICYmIGN1cnJSZXN1bHQuZGF0YT8uaXNDb252ZXhTeXN0ZW1FcnJvciA9PT0gdHJ1ZSAmJiBjdXJyUmVzdWx0LmRhdGE/LnBhZ2luYXRpb25FcnJvciA9PT0gXCJJbnZhbGlkQ3Vyc29yXCIpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgIFwidXNlUGFnaW5hdGVkUXVlcnkgaGl0IGVycm9yLCByZXNldHRpbmcgcGFnaW5hdGlvbiBzdGF0ZTogXCIgKyBjdXJyUmVzdWx0Lm1lc3NhZ2VcbiAgICAgICAgICApO1xuICAgICAgICAgIHNldFN0YXRlKGNyZWF0ZUluaXRpYWxTdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIFtbXSwgdm9pZCAwXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBjdXJyUmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBvbmdvaW5nU3BsaXQgPSBjdXJyU3RhdGUub25nb2luZ1NwbGl0c1twYWdlS2V5XTtcbiAgICAgIGlmIChvbmdvaW5nU3BsaXQgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAocmVzdWx0c09iamVjdFtvbmdvaW5nU3BsaXRbMF1dICE9PSB2b2lkIDAgJiYgcmVzdWx0c09iamVjdFtvbmdvaW5nU3BsaXRbMV1dICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBzZXRTdGF0ZShjb21wbGV0ZVNwbGl0UXVlcnkocGFnZUtleSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGN1cnJSZXN1bHQuc3BsaXRDdXJzb3IgJiYgKGN1cnJSZXN1bHQucGFnZVN0YXR1cyA9PT0gXCJTcGxpdFJlY29tbWVuZGVkXCIgfHwgY3VyclJlc3VsdC5wYWdlU3RhdHVzID09PSBcIlNwbGl0UmVxdWlyZWRcIiB8fCBjdXJyUmVzdWx0LnBhZ2UubGVuZ3RoID4gb3B0aW9ucy5pbml0aWFsTnVtSXRlbXMgKiAyKSkge1xuICAgICAgICBzZXRTdGF0ZShcbiAgICAgICAgICBzcGxpdFF1ZXJ5KFxuICAgICAgICAgICAgcGFnZUtleSxcbiAgICAgICAgICAgIGN1cnJSZXN1bHQuc3BsaXRDdXJzb3IsXG4gICAgICAgICAgICBjdXJyUmVzdWx0LmNvbnRpbnVlQ3Vyc29yXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJSZXN1bHQucGFnZVN0YXR1cyA9PT0gXCJTcGxpdFJlcXVpcmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIFthbGxJdGVtcywgdm9pZCAwXTtcbiAgICAgIH1cbiAgICAgIGFsbEl0ZW1zLnB1c2goXG4gICAgICAgIC4uLmlzSW5jbHVkaW5nUGFnZUtleXMgPyBjdXJyUmVzdWx0LnBhZ2UubWFwKChpKSA9PiAoe1xuICAgICAgICAgIC4uLmksXG4gICAgICAgICAgW3BhZ2VdOiBwYWdlS2V5LnRvU3RyaW5nKClcbiAgICAgICAgfSkpIDogY3VyclJlc3VsdC5wYWdlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW2FsbEl0ZW1zLCBjdXJyUmVzdWx0XTtcbiAgfSwgW1xuICAgIHJlc3VsdHNPYmplY3QsXG4gICAgY3VyclN0YXRlLnBhZ2VLZXlzLFxuICAgIGN1cnJTdGF0ZS5vbmdvaW5nU3BsaXRzLFxuICAgIG9wdGlvbnMuaW5pdGlhbE51bUl0ZW1zLFxuICAgIGNyZWF0ZUluaXRpYWxTdGF0ZSxcbiAgICBsb2dnZXIsXG4gICAgaXNJbmNsdWRpbmdQYWdlS2V5c1xuICBdKTtcbiAgY29uc3Qgc3RhdHVzT2JqZWN0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKG1heWJlTGFzdFJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoY3VyclN0YXRlLm5leHRQYWdlS2V5ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiBcIkxvYWRpbmdGaXJzdFBhZ2VcIixcbiAgICAgICAgICBpc0xvYWRpbmc6IHRydWUsXG4gICAgICAgICAgbG9hZE1vcmU6IChfbnVtSXRlbXMpID0+IHtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogXCJMb2FkaW5nTW9yZVwiLFxuICAgICAgICAgIGlzTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICBsb2FkTW9yZTogKF9udW1JdGVtcykgPT4ge1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1heWJlTGFzdFJlc3VsdC5pc0RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogXCJFeGhhdXN0ZWRcIixcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgbG9hZE1vcmU6IChfbnVtSXRlbXMpID0+IHtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY29udGludWVDdXJzb3IgPSBtYXliZUxhc3RSZXN1bHQuY29udGludWVDdXJzb3I7XG4gICAgbGV0IGFscmVhZHlMb2FkaW5nTW9yZSA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IFwiQ2FuTG9hZE1vcmVcIixcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBsb2FkTW9yZTogKG51bUl0ZW1zKSA9PiB7XG4gICAgICAgIGlmICghYWxyZWFkeUxvYWRpbmdNb3JlKSB7XG4gICAgICAgICAgYWxyZWFkeUxvYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICAgICAgICBzZXRTdGF0ZSgocHJldlN0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYWdlS2V5cyA9IFsuLi5wcmV2U3RhdGUucGFnZUtleXMsIHByZXZTdGF0ZS5uZXh0UGFnZUtleV07XG4gICAgICAgICAgICBjb25zdCBxdWVyaWVzID0geyAuLi5wcmV2U3RhdGUucXVlcmllcyB9O1xuICAgICAgICAgICAgcXVlcmllc1twcmV2U3RhdGUubmV4dFBhZ2VLZXldID0ge1xuICAgICAgICAgICAgICBxdWVyeTogcHJldlN0YXRlLnF1ZXJ5LFxuICAgICAgICAgICAgICBhcmdzOiB7XG4gICAgICAgICAgICAgICAgLi4ucHJldlN0YXRlLmFyZ3MsXG4gICAgICAgICAgICAgICAgcGFnaW5hdGlvbk9wdHM6IHtcbiAgICAgICAgICAgICAgICAgIG51bUl0ZW1zLFxuICAgICAgICAgICAgICAgICAgY3Vyc29yOiBjb250aW51ZUN1cnNvcixcbiAgICAgICAgICAgICAgICAgIGlkOiBwcmV2U3RhdGUuaWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5wcmV2U3RhdGUsXG4gICAgICAgICAgICAgIG5leHRQYWdlS2V5OiBwcmV2U3RhdGUubmV4dFBhZ2VLZXkgKyAxLFxuICAgICAgICAgICAgICBwYWdlS2V5cyxcbiAgICAgICAgICAgICAgcXVlcmllc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFttYXliZUxhc3RSZXN1bHQsIGN1cnJTdGF0ZS5uZXh0UGFnZUtleV0pO1xuICByZXR1cm4ge1xuICAgIHVzZXI6IHtcbiAgICAgIHJlc3VsdHMsXG4gICAgICAuLi5zdGF0dXNPYmplY3RcbiAgICB9LFxuICAgIGludGVybmFsOiB7IHN0YXRlOiBjdXJyU3RhdGUgfVxuICB9O1xufVxubGV0IHBhZ2luYXRpb25JZCA9IDA7XG5mdW5jdGlvbiBuZXh0UGFnaW5hdGlvbklkKCkge1xuICBwYWdpbmF0aW9uSWQrKztcbiAgcmV0dXJuIHBhZ2luYXRpb25JZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXNldFBhZ2luYXRpb25JZCgpIHtcbiAgcGFnaW5hdGlvbklkID0gMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvcHRpbWlzdGljYWxseVVwZGF0ZVZhbHVlSW5QYWdpbmF0ZWRRdWVyeShsb2NhbFN0b3JlLCBxdWVyeSwgYXJncywgdXBkYXRlVmFsdWUpIHtcbiAgY29uc3QgZXhwZWN0ZWRBcmdzID0gSlNPTi5zdHJpbmdpZnkoY29udmV4VG9Kc29uKGFyZ3MpKTtcbiAgZm9yIChjb25zdCBxdWVyeVJlc3VsdCBvZiBsb2NhbFN0b3JlLmdldEFsbFF1ZXJpZXMocXVlcnkpKSB7XG4gICAgaWYgKHF1ZXJ5UmVzdWx0LnZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHsgcGFnaW5hdGlvbk9wdHM6IF8sIC4uLmlubmVyQXJncyB9ID0gcXVlcnlSZXN1bHQuYXJncztcbiAgICAgIGlmIChKU09OLnN0cmluZ2lmeShjb252ZXhUb0pzb24oaW5uZXJBcmdzKSkgPT09IGV4cGVjdGVkQXJncykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHF1ZXJ5UmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIEFycmF5LmlzQXJyYXkodmFsdWUucGFnZSkpIHtcbiAgICAgICAgICBsb2NhbFN0b3JlLnNldFF1ZXJ5KHF1ZXJ5LCBxdWVyeVJlc3VsdC5hcmdzLCB7XG4gICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgIHBhZ2U6IHZhbHVlLnBhZ2UubWFwKHVwZGF0ZVZhbHVlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0QXRUb3Aob3B0aW9ucykge1xuICBjb25zdCB7IHBhZ2luYXRlZFF1ZXJ5LCBhcmdzVG9NYXRjaCwgbG9jYWxRdWVyeVN0b3JlLCBpdGVtIH0gPSBvcHRpb25zO1xuICBjb25zdCBxdWVyaWVzID0gbG9jYWxRdWVyeVN0b3JlLmdldEFsbFF1ZXJpZXMocGFnaW5hdGVkUXVlcnkpO1xuICBjb25zdCBxdWVyaWVzVGhhdE1hdGNoID0gcXVlcmllcy5maWx0ZXIoKHEpID0+IHtcbiAgICBpZiAoYXJnc1RvTWF0Y2ggPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhhcmdzVG9NYXRjaCkuZXZlcnkoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIFRoaXMgc2hvdWxkIGJlIHNhZmUgc2luY2UgYm90aCBzaG91bGQgYmUgcGxhaW4gb2JqZWN0c1xuICAgICAgKGspID0+IGNvbXBhcmVWYWx1ZXMoYXJnc1RvTWF0Y2hba10sIHEuYXJnc1trXSkgPT09IDBcbiAgICApO1xuICB9KTtcbiAgY29uc3QgZmlyc3RQYWdlID0gcXVlcmllc1RoYXRNYXRjaC5maW5kKFxuICAgIChxKSA9PiBxLmFyZ3MucGFnaW5hdGlvbk9wdHMuY3Vyc29yID09PSBudWxsXG4gICk7XG4gIGlmIChmaXJzdFBhZ2UgPT09IHZvaWQgMCB8fCBmaXJzdFBhZ2UudmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsb2NhbFF1ZXJ5U3RvcmUuc2V0UXVlcnkocGFnaW5hdGVkUXVlcnksIGZpcnN0UGFnZS5hcmdzLCB7XG4gICAgLi4uZmlyc3RQYWdlLnZhbHVlLFxuICAgIHBhZ2U6IFtpdGVtLCAuLi5maXJzdFBhZ2UudmFsdWUucGFnZV1cbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0QXRCb3R0b21JZkxvYWRlZChvcHRpb25zKSB7XG4gIGNvbnN0IHsgcGFnaW5hdGVkUXVlcnksIGxvY2FsUXVlcnlTdG9yZSwgaXRlbSwgYXJnc1RvTWF0Y2ggfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHF1ZXJpZXMgPSBsb2NhbFF1ZXJ5U3RvcmUuZ2V0QWxsUXVlcmllcyhwYWdpbmF0ZWRRdWVyeSk7XG4gIGNvbnN0IHF1ZXJpZXNUaGF0TWF0Y2ggPSBxdWVyaWVzLmZpbHRlcigocSkgPT4ge1xuICAgIGlmIChhcmdzVG9NYXRjaCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGFyZ3NUb01hdGNoKS5ldmVyeShcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gVGhpcyBzaG91bGQgYmUgc2FmZSBzaW5jZSBib3RoIHNob3VsZCBiZSBwbGFpbiBvYmplY3RzXG4gICAgICAoaykgPT4gY29tcGFyZVZhbHVlcyhhcmdzVG9NYXRjaFtrXSwgcS5hcmdzW2tdKSA9PT0gMFxuICAgICk7XG4gIH0pO1xuICBjb25zdCBsYXN0UGFnZSA9IHF1ZXJpZXNUaGF0TWF0Y2guZmluZChcbiAgICAocSkgPT4gcS52YWx1ZSAhPT0gdm9pZCAwICYmIHEudmFsdWUuaXNEb25lXG4gICk7XG4gIGlmIChsYXN0UGFnZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxvY2FsUXVlcnlTdG9yZS5zZXRRdWVyeShwYWdpbmF0ZWRRdWVyeSwgbGFzdFBhZ2UuYXJncywge1xuICAgIC4uLmxhc3RQYWdlLnZhbHVlLFxuICAgIHBhZ2U6IFsuLi5sYXN0UGFnZS52YWx1ZS5wYWdlLCBpdGVtXVxuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRBdFBvc2l0aW9uKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHBhZ2luYXRlZFF1ZXJ5LFxuICAgIHNvcnRPcmRlcixcbiAgICBzb3J0S2V5RnJvbUl0ZW0sXG4gICAgbG9jYWxRdWVyeVN0b3JlLFxuICAgIGl0ZW0sXG4gICAgYXJnc1RvTWF0Y2hcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHF1ZXJpZXMgPSBsb2NhbFF1ZXJ5U3RvcmUuZ2V0QWxsUXVlcmllcyhwYWdpbmF0ZWRRdWVyeSk7XG4gIGNvbnN0IHF1ZXJ5R3JvdXBzID0ge307XG4gIGZvciAoY29uc3QgcXVlcnkgb2YgcXVlcmllcykge1xuICAgIGlmIChhcmdzVG9NYXRjaCAhPT0gdm9pZCAwICYmICFPYmplY3Qua2V5cyhhcmdzVG9NYXRjaCkuZXZlcnkoXG4gICAgICAoaykgPT4gKFxuICAgICAgICAvLyBAdHMtaWdub3JlIHdoeSBpcyB0aGlzIG5vdCB3b3JraW5nP1xuICAgICAgICBhcmdzVG9NYXRjaFtrXSA9PT0gcXVlcnkuYXJnc1trXVxuICAgICAgKVxuICAgICkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocXVlcnkuYXJncykubWFwKChbaywgdl0pID0+IFtcbiAgICAgICAgICBrLFxuICAgICAgICAgIGsgPT09IFwicGFnaW5hdGlvbk9wdHNcIiA/IHYuaWQgOiB2XG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgICBxdWVyeUdyb3Vwc1trZXldID8/IChxdWVyeUdyb3Vwc1trZXldID0gW10pO1xuICAgIHF1ZXJ5R3JvdXBzW2tleV0ucHVzaChxdWVyeSk7XG4gIH1cbiAgZm9yIChjb25zdCBwYWdlUXVlcmllcyBvZiBPYmplY3QudmFsdWVzKHF1ZXJ5R3JvdXBzKSkge1xuICAgIGluc2VydEF0UG9zaXRpb25JblBhZ2VzKHtcbiAgICAgIHBhZ2VRdWVyaWVzLFxuICAgICAgcGFnaW5hdGVkUXVlcnksXG4gICAgICBzb3J0T3JkZXIsXG4gICAgICBzb3J0S2V5RnJvbUl0ZW0sXG4gICAgICBsb2NhbFF1ZXJ5U3RvcmUsXG4gICAgICBpdGVtXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc2VydEF0UG9zaXRpb25JblBhZ2VzKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHBhZ2VRdWVyaWVzLFxuICAgIHNvcnRPcmRlcixcbiAgICBzb3J0S2V5RnJvbUl0ZW0sXG4gICAgbG9jYWxRdWVyeVN0b3JlLFxuICAgIGl0ZW0sXG4gICAgcGFnaW5hdGVkUXVlcnlcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGluc2VydGVkS2V5ID0gc29ydEtleUZyb21JdGVtKGl0ZW0pO1xuICBjb25zdCBsb2FkZWRQYWdlcyA9IHBhZ2VRdWVyaWVzLmZpbHRlcihcbiAgICAocSkgPT4gcS52YWx1ZSAhPT0gdm9pZCAwICYmIHEudmFsdWUucGFnZS5sZW5ndGggPiAwXG4gICk7XG4gIGNvbnN0IHNvcnRlZFBhZ2VzID0gbG9hZGVkUGFnZXMuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGFLZXkgPSBzb3J0S2V5RnJvbUl0ZW0oYS52YWx1ZS5wYWdlWzBdKTtcbiAgICBjb25zdCBiS2V5ID0gc29ydEtleUZyb21JdGVtKGIudmFsdWUucGFnZVswXSk7XG4gICAgaWYgKHNvcnRPcmRlciA9PT0gXCJhc2NcIikge1xuICAgICAgcmV0dXJuIGNvbXBhcmVWYWx1ZXMoYUtleSwgYktleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb21wYXJlVmFsdWVzKGJLZXksIGFLZXkpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGZpcnN0TG9hZGVkUGFnZSA9IHNvcnRlZFBhZ2VzWzBdO1xuICBpZiAoZmlyc3RMb2FkZWRQYWdlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZmlyc3RQYWdlS2V5ID0gc29ydEtleUZyb21JdGVtKGZpcnN0TG9hZGVkUGFnZS52YWx1ZS5wYWdlWzBdKTtcbiAgY29uc3QgaXNCZWZvcmVGaXJzdFBhZ2UgPSBzb3J0T3JkZXIgPT09IFwiYXNjXCIgPyBjb21wYXJlVmFsdWVzKGluc2VydGVkS2V5LCBmaXJzdFBhZ2VLZXkpIDw9IDAgOiBjb21wYXJlVmFsdWVzKGluc2VydGVkS2V5LCBmaXJzdFBhZ2VLZXkpID49IDA7XG4gIGlmIChpc0JlZm9yZUZpcnN0UGFnZSkge1xuICAgIGlmIChmaXJzdExvYWRlZFBhZ2UuYXJncy5wYWdpbmF0aW9uT3B0cy5jdXJzb3IgPT09IG51bGwpIHtcbiAgICAgIGxvY2FsUXVlcnlTdG9yZS5zZXRRdWVyeShwYWdpbmF0ZWRRdWVyeSwgZmlyc3RMb2FkZWRQYWdlLmFyZ3MsIHtcbiAgICAgICAgLi4uZmlyc3RMb2FkZWRQYWdlLnZhbHVlLFxuICAgICAgICBwYWdlOiBbaXRlbSwgLi4uZmlyc3RMb2FkZWRQYWdlLnZhbHVlLnBhZ2VdXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbGFzdExvYWRlZFBhZ2UgPSBzb3J0ZWRQYWdlc1tzb3J0ZWRQYWdlcy5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3RMb2FkZWRQYWdlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbGFzdFBhZ2VLZXkgPSBzb3J0S2V5RnJvbUl0ZW0oXG4gICAgbGFzdExvYWRlZFBhZ2UudmFsdWUucGFnZVtsYXN0TG9hZGVkUGFnZS52YWx1ZS5wYWdlLmxlbmd0aCAtIDFdXG4gICk7XG4gIGNvbnN0IGlzQWZ0ZXJMYXN0UGFnZSA9IHNvcnRPcmRlciA9PT0gXCJhc2NcIiA/IGNvbXBhcmVWYWx1ZXMoaW5zZXJ0ZWRLZXksIGxhc3RQYWdlS2V5KSA+PSAwIDogY29tcGFyZVZhbHVlcyhpbnNlcnRlZEtleSwgbGFzdFBhZ2VLZXkpIDw9IDA7XG4gIGlmIChpc0FmdGVyTGFzdFBhZ2UpIHtcbiAgICBpZiAobGFzdExvYWRlZFBhZ2UudmFsdWUuaXNEb25lKSB7XG4gICAgICBsb2NhbFF1ZXJ5U3RvcmUuc2V0UXVlcnkocGFnaW5hdGVkUXVlcnksIGxhc3RMb2FkZWRQYWdlLmFyZ3MsIHtcbiAgICAgICAgLi4ubGFzdExvYWRlZFBhZ2UudmFsdWUsXG4gICAgICAgIHBhZ2U6IFsuLi5sYXN0TG9hZGVkUGFnZS52YWx1ZS5wYWdlLCBpdGVtXVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdWNjZXNzb3JQYWdlSW5kZXggPSBzb3J0ZWRQYWdlcy5maW5kSW5kZXgoXG4gICAgKHApID0+IHNvcnRPcmRlciA9PT0gXCJhc2NcIiA/IGNvbXBhcmVWYWx1ZXMoc29ydEtleUZyb21JdGVtKHAudmFsdWUucGFnZVswXSksIGluc2VydGVkS2V5KSA+IDAgOiBjb21wYXJlVmFsdWVzKHNvcnRLZXlGcm9tSXRlbShwLnZhbHVlLnBhZ2VbMF0pLCBpbnNlcnRlZEtleSkgPCAwXG4gICk7XG4gIGNvbnN0IHBhZ2VUb1VwZGF0ZSA9IHN1Y2Nlc3NvclBhZ2VJbmRleCA9PT0gLTEgPyBzb3J0ZWRQYWdlc1tzb3J0ZWRQYWdlcy5sZW5ndGggLSAxXSA6IHNvcnRlZFBhZ2VzW3N1Y2Nlc3NvclBhZ2VJbmRleCAtIDFdO1xuICBpZiAocGFnZVRvVXBkYXRlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaW5kZXhXaXRoaW5QYWdlID0gcGFnZVRvVXBkYXRlLnZhbHVlLnBhZ2UuZmluZEluZGV4KFxuICAgIChlKSA9PiBzb3J0T3JkZXIgPT09IFwiYXNjXCIgPyBjb21wYXJlVmFsdWVzKHNvcnRLZXlGcm9tSXRlbShlKSwgaW5zZXJ0ZWRLZXkpID49IDAgOiBjb21wYXJlVmFsdWVzKHNvcnRLZXlGcm9tSXRlbShlKSwgaW5zZXJ0ZWRLZXkpIDw9IDBcbiAgKTtcbiAgY29uc3QgbmV3UGFnZSA9IGluZGV4V2l0aGluUGFnZSA9PT0gLTEgPyBbLi4ucGFnZVRvVXBkYXRlLnZhbHVlLnBhZ2UsIGl0ZW1dIDogW1xuICAgIC4uLnBhZ2VUb1VwZGF0ZS52YWx1ZS5wYWdlLnNsaWNlKDAsIGluZGV4V2l0aGluUGFnZSksXG4gICAgaXRlbSxcbiAgICAuLi5wYWdlVG9VcGRhdGUudmFsdWUucGFnZS5zbGljZShpbmRleFdpdGhpblBhZ2UpXG4gIF07XG4gIGxvY2FsUXVlcnlTdG9yZS5zZXRRdWVyeShwYWdpbmF0ZWRRdWVyeSwgcGFnZVRvVXBkYXRlLmFyZ3MsIHtcbiAgICAuLi5wYWdlVG9VcGRhdGUudmFsdWUsXG4gICAgcGFnZTogbmV3UGFnZVxuICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZV9wYWdpbmF0ZWRfcXVlcnkuanMubWFwXG4iXSwibmFtZXMiOlsidXNlTWVtbyIsInVzZVN0YXRlIiwiQ29udmV4RXJyb3IiLCJjb252ZXhUb0pzb24iLCJ1c2VRdWVyaWVzIiwiZ2V0RnVuY3Rpb25OYW1lIiwidXNlQ29udmV4IiwiY29tcGFyZVZhbHVlcyIsInNwbGl0UXVlcnkiLCJrZXkiLCJzcGxpdEN1cnNvciIsImNvbnRpbnVlQ3Vyc29yIiwicHJldlN0YXRlIiwicXVlcmllcyIsInNwbGl0S2V5MSIsIm5leHRQYWdlS2V5Iiwic3BsaXRLZXkyIiwicXVlcnkiLCJhcmdzIiwicGFnaW5hdGlvbk9wdHMiLCJlbmRDdXJzb3IiLCJjdXJzb3IiLCJvbmdvaW5nU3BsaXRzIiwiY29tcGxldGVTcGxpdFF1ZXJ5IiwiY29tcGxldGVkU3BsaXQiLCJwYWdlS2V5cyIsInNsaWNlIiwicGFnZUluZGV4IiwiZmluZEluZGV4IiwidiIsInVzZVBhZ2luYXRlZFF1ZXJ5Iiwib3B0aW9ucyIsInVzZXIiLCJ1c2VQYWdpbmF0ZWRRdWVyeUludGVybmFsIiwiaW5jbHVkZVBhZ2UiLCJTeW1ib2wiLCJwYWdlIiwiaW5pdGlhbE51bUl0ZW1zIiwiRXJyb3IiLCJza2lwIiwiYXJnc09iamVjdCIsInF1ZXJ5TmFtZSIsImNyZWF0ZUluaXRpYWxTdGF0ZSIsImlkIiwibmV4dFBhZ2luYXRpb25JZCIsIm51bUl0ZW1zIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0YXRlIiwic2V0U3RhdGUiLCJjdXJyU3RhdGUiLCJjb252ZXhDbGllbnQiLCJsb2dnZXIiLCJyZXN1bHRzT2JqZWN0IiwiaXNJbmNsdWRpbmdQYWdlS2V5cyIsInJlc3VsdHMiLCJtYXliZUxhc3RSZXN1bHQiLCJjdXJyUmVzdWx0IiwiYWxsSXRlbXMiLCJwYWdlS2V5IiwibWVzc2FnZSIsImluY2x1ZGVzIiwiZGF0YSIsImlzQ29udmV4U3lzdGVtRXJyb3IiLCJwYWdpbmF0aW9uRXJyb3IiLCJ3YXJuIiwib25nb2luZ1NwbGl0IiwicGFnZVN0YXR1cyIsImxlbmd0aCIsInB1c2giLCJtYXAiLCJpIiwidG9TdHJpbmciLCJzdGF0dXNPYmplY3QiLCJzdGF0dXMiLCJpc0xvYWRpbmciLCJsb2FkTW9yZSIsIl9udW1JdGVtcyIsImlzRG9uZSIsImFscmVhZHlMb2FkaW5nTW9yZSIsImludGVybmFsIiwicGFnaW5hdGlvbklkIiwicmVzZXRQYWdpbmF0aW9uSWQiLCJvcHRpbWlzdGljYWxseVVwZGF0ZVZhbHVlSW5QYWdpbmF0ZWRRdWVyeSIsImxvY2FsU3RvcmUiLCJ1cGRhdGVWYWx1ZSIsImV4cGVjdGVkQXJncyIsInF1ZXJ5UmVzdWx0IiwiZ2V0QWxsUXVlcmllcyIsInZhbHVlIiwiXyIsImlubmVyQXJncyIsIkFycmF5IiwiaXNBcnJheSIsInNldFF1ZXJ5IiwiaW5zZXJ0QXRUb3AiLCJwYWdpbmF0ZWRRdWVyeSIsImFyZ3NUb01hdGNoIiwibG9jYWxRdWVyeVN0b3JlIiwiaXRlbSIsInF1ZXJpZXNUaGF0TWF0Y2giLCJmaWx0ZXIiLCJxIiwiT2JqZWN0Iiwia2V5cyIsImV2ZXJ5IiwiayIsImZpcnN0UGFnZSIsImZpbmQiLCJpbnNlcnRBdEJvdHRvbUlmTG9hZGVkIiwibGFzdFBhZ2UiLCJpbnNlcnRBdFBvc2l0aW9uIiwic29ydE9yZGVyIiwic29ydEtleUZyb21JdGVtIiwicXVlcnlHcm91cHMiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJwYWdlUXVlcmllcyIsInZhbHVlcyIsImluc2VydEF0UG9zaXRpb25JblBhZ2VzIiwiaW5zZXJ0ZWRLZXkiLCJsb2FkZWRQYWdlcyIsInNvcnRlZFBhZ2VzIiwic29ydCIsImEiLCJiIiwiYUtleSIsImJLZXkiLCJmaXJzdExvYWRlZFBhZ2UiLCJmaXJzdFBhZ2VLZXkiLCJpc0JlZm9yZUZpcnN0UGFnZSIsImxhc3RMb2FkZWRQYWdlIiwibGFzdFBhZ2VLZXkiLCJpc0FmdGVyTGFzdFBhZ2UiLCJzdWNjZXNzb3JQYWdlSW5kZXgiLCJwIiwicGFnZVRvVXBkYXRlIiwiaW5kZXhXaXRoaW5QYWdlIiwiZSIsIm5ld1BhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/react/use_paginated_query.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/react/use_paginated_query2.js":
/*!********************************************************************!*\
  !*** ./node_modules/convex/dist/esm/react/use_paginated_query2.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resetPaginationId: function() { return /* binding */ resetPaginationId; },\n/* harmony export */   usePaginatedQuery_experimental: function() { return /* binding */ usePaginatedQuery_experimental; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _server_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server/api.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/server/api.js\");\n/* harmony import */ var _values_value_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../values/value.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/value.js\");\n/* harmony import */ var _use_queries_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./use_queries.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/use_queries.js\");\n/* harmony import */ var _values_errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../values/errors.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/errors.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./client.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/client.js\");\nvar _s = $RefreshSig$();\n\"use strict\";\n\n\n\n\n\n\nfunction usePaginatedQuery_experimental(query, args, options) {\n    _s();\n    if (typeof (options === null || options === void 0 ? void 0 : options.initialNumItems) !== \"number\" || options.initialNumItems < 0) {\n        throw new Error(\"`options.initialNumItems` must be a positive number. Received `\".concat(options === null || options === void 0 ? void 0 : options.initialNumItems, \"`.\"));\n    }\n    const skip = args === \"skip\";\n    const argsObject = skip ? {} : args;\n    const convexClient = (0,_client_js__WEBPACK_IMPORTED_MODULE_5__.useConvex)();\n    const logger = convexClient.logger;\n    const createInitialState = ()=>{\n        const id = nextPaginationId();\n        return {\n            query,\n            args: argsObject,\n            id,\n            // Queries will contain zero or one queries forever.\n            queries: skip ? {} : {\n                paginatedQuery: {\n                    query,\n                    args: {\n                        ...argsObject\n                    },\n                    paginationOptions: {\n                        initialNumItems: options.initialNumItems,\n                        id\n                    }\n                }\n            },\n            skip\n        };\n    };\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(createInitialState);\n    let currState = state;\n    if ((0,_server_api_js__WEBPACK_IMPORTED_MODULE_1__.getFunctionName)(query) !== (0,_server_api_js__WEBPACK_IMPORTED_MODULE_1__.getFunctionName)(state.query) || JSON.stringify((0,_values_value_js__WEBPACK_IMPORTED_MODULE_2__.convexToJson)(argsObject)) !== JSON.stringify((0,_values_value_js__WEBPACK_IMPORTED_MODULE_2__.convexToJson)(state.args)) || skip !== state.skip) {\n        currState = createInitialState();\n        setState(currState);\n    }\n    const resultsObject = (0,_use_queries_js__WEBPACK_IMPORTED_MODULE_3__.useQueries)(currState.queries);\n    if (!(\"paginatedQuery\" in resultsObject)) {\n        if (!skip) {\n            throw new Error(\"Why is it missing?\");\n        }\n        return {\n            results: [],\n            status: \"LoadingFirstPage\",\n            isLoading: true,\n            loadMore: function skipNOP(_numItems) {\n                return false;\n            }\n        };\n    }\n    const result = resultsObject.paginatedQuery;\n    if (result === void 0) {\n        return {\n            results: [],\n            loadMore: ()=>false,\n            isLoading: true,\n            status: \"LoadingFirstPage\"\n        };\n    }\n    if (result instanceof Error) {\n        var _result_data, _result_data1;\n        if (result.message.includes(\"InvalidCursor\") || result instanceof _values_errors_js__WEBPACK_IMPORTED_MODULE_4__.ConvexError && typeof result.data === \"object\" && ((_result_data = result.data) === null || _result_data === void 0 ? void 0 : _result_data.isConvexSystemError) === true && ((_result_data1 = result.data) === null || _result_data1 === void 0 ? void 0 : _result_data1.paginationError) === \"InvalidCursor\") {\n            logger.warn(\"usePaginatedQuery hit error, resetting pagination state: \" + result.message);\n            setState(createInitialState);\n            return {\n                results: [],\n                loadMore: ()=>false,\n                isLoading: true,\n                status: \"LoadingFirstPage\"\n            };\n        } else {\n            throw result;\n        }\n    }\n    return {\n        ...result,\n        loadMore: (num)=>{\n            return result.loadMore(num);\n        },\n        isLoading: result.status === \"LoadingFirstPage\" ? true : result.status === \"LoadingMore\" ? true : false\n    };\n}\n_s(usePaginatedQuery_experimental, \"VEFuQ9DvxUf08mvomSz6RWtgzVk=\", false, function() {\n    return [\n        _client_js__WEBPACK_IMPORTED_MODULE_5__.useConvex,\n        _use_queries_js__WEBPACK_IMPORTED_MODULE_3__.useQueries\n    ];\n});\nlet paginationId = 0;\nfunction nextPaginationId() {\n    paginationId++;\n    return paginationId;\n}\nfunction resetPaginationId() {\n    paginationId = 0;\n} //# sourceMappingURL=use_paginated_query2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vcmVhY3QvdXNlX3BhZ2luYXRlZF9xdWVyeTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDaUM7QUFDa0I7QUFDRDtBQUNKO0FBQ0k7QUFDVjtBQUNqQyxTQUFTTSwrQkFBK0JDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxPQUFPOztJQUNqRSxJQUFJLFFBQU9BLG9CQUFBQSw4QkFBQUEsUUFBU0MsZUFBZSxNQUFLLFlBQVlELFFBQVFDLGVBQWUsR0FBRyxHQUFHO1FBQy9FLE1BQU0sSUFBSUMsTUFDUixrRUFBOEYsT0FBekJGLG9CQUFBQSw4QkFBQUEsUUFBU0MsZUFBZSxFQUFDO0lBRWxHO0lBQ0EsTUFBTUUsT0FBT0osU0FBUztJQUN0QixNQUFNSyxhQUFhRCxPQUFPLENBQUMsSUFBSUo7SUFDL0IsTUFBTU0sZUFBZVQscURBQVNBO0lBQzlCLE1BQU1VLFNBQVNELGFBQWFDLE1BQU07SUFDbEMsTUFBTUMscUJBQXFCO1FBQ3pCLE1BQU1DLEtBQUtDO1FBQ1gsT0FBTztZQUNMWDtZQUNBQyxNQUFNSztZQUNOSTtZQUNBLG9EQUFvRDtZQUNwREUsU0FBU1AsT0FBTyxDQUFDLElBQUk7Z0JBQ25CUSxnQkFBZ0I7b0JBQ2RiO29CQUNBQyxNQUFNO3dCQUNKLEdBQUdLLFVBQVU7b0JBQ2Y7b0JBQ0FRLG1CQUFtQjt3QkFDakJYLGlCQUFpQkQsUUFBUUMsZUFBZTt3QkFDeENPO29CQUNGO2dCQUNGO1lBQ0Y7WUFDQUw7UUFDRjtJQUNGO0lBQ0EsTUFBTSxDQUFDVSxPQUFPQyxTQUFTLEdBQUd2QiwrQ0FBUUEsQ0FBQ2dCO0lBQ25DLElBQUlRLFlBQVlGO0lBQ2hCLElBQUlyQiwrREFBZUEsQ0FBQ00sV0FBV04sK0RBQWVBLENBQUNxQixNQUFNZixLQUFLLEtBQUtrQixLQUFLQyxTQUFTLENBQUN4Qiw4REFBWUEsQ0FBQ1csaUJBQWlCWSxLQUFLQyxTQUFTLENBQUN4Qiw4REFBWUEsQ0FBQ29CLE1BQU1kLElBQUksTUFBTUksU0FBU1UsTUFBTVYsSUFBSSxFQUFFO1FBQzNLWSxZQUFZUjtRQUNaTyxTQUFTQztJQUNYO0lBQ0EsTUFBTUcsZ0JBQWdCeEIsMkRBQVVBLENBQUNxQixVQUFVTCxPQUFPO0lBQ2xELElBQUksQ0FBRSxxQkFBb0JRLGFBQVksR0FBSTtRQUN4QyxJQUFJLENBQUNmLE1BQU07WUFDVCxNQUFNLElBQUlELE1BQU07UUFDbEI7UUFDQSxPQUFPO1lBQ0xpQixTQUFTLEVBQUU7WUFDWEMsUUFBUTtZQUNSQyxXQUFXO1lBQ1hDLFVBQVUsU0FBU0MsUUFBUUMsU0FBUztnQkFDbEMsT0FBTztZQUNUO1FBQ0Y7SUFDRjtJQUNBLE1BQU1DLFNBQVNQLGNBQWNQLGNBQWM7SUFDM0MsSUFBSWMsV0FBVyxLQUFLLEdBQUc7UUFDckIsT0FBTztZQUNMTixTQUFTLEVBQUU7WUFDWEcsVUFBVSxJQUFNO1lBQ2hCRCxXQUFXO1lBQ1hELFFBQVE7UUFDVjtJQUNGO0lBQ0EsSUFBSUssa0JBQWtCdkIsT0FBTztZQUN5RnVCLGNBQTZDQTtRQUFqSyxJQUFJQSxPQUFPQyxPQUFPLENBQUNDLFFBQVEsQ0FBQyxvQkFBb0JGLGtCQUFrQjlCLDBEQUFXQSxJQUFJLE9BQU84QixPQUFPRyxJQUFJLEtBQUssWUFBWUgsRUFBQUEsZUFBQUEsT0FBT0csSUFBSSxjQUFYSCxtQ0FBQUEsYUFBYUksbUJBQW1CLE1BQUssUUFBUUosRUFBQUEsZ0JBQUFBLE9BQU9HLElBQUksY0FBWEgsb0NBQUFBLGNBQWFLLGVBQWUsTUFBSyxpQkFBaUI7WUFDak54QixPQUFPeUIsSUFBSSxDQUNULDhEQUE4RE4sT0FBT0MsT0FBTztZQUU5RVosU0FBU1A7WUFDVCxPQUFPO2dCQUNMWSxTQUFTLEVBQUU7Z0JBQ1hHLFVBQVUsSUFBTTtnQkFDaEJELFdBQVc7Z0JBQ1hELFFBQVE7WUFDVjtRQUNGLE9BQU87WUFDTCxNQUFNSztRQUNSO0lBQ0Y7SUFDQSxPQUFPO1FBQ0wsR0FBR0EsTUFBTTtRQUNUSCxVQUFVLENBQUNVO1lBQ1QsT0FBT1AsT0FBT0gsUUFBUSxDQUFDVTtRQUN6QjtRQUNBWCxXQUFXSSxPQUFPTCxNQUFNLEtBQUsscUJBQXFCLE9BQU9LLE9BQU9MLE1BQU0sS0FBSyxnQkFBZ0IsT0FBTztJQUNwRztBQUNGO0dBcEZnQnZCOztRQVFPRCxpREFBU0E7UUE4QlJGLHVEQUFVQTs7O0FBK0NsQyxJQUFJdUMsZUFBZTtBQUNuQixTQUFTeEI7SUFDUHdCO0lBQ0EsT0FBT0E7QUFDVDtBQUNPLFNBQVNDO0lBQ2RELGVBQWU7QUFDakIsRUFDQSxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9yZWFjdC91c2VfcGFnaW5hdGVkX3F1ZXJ5Mi5qcz84MmQ3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGdldEZ1bmN0aW9uTmFtZSB9IGZyb20gXCIuLi9zZXJ2ZXIvYXBpLmpzXCI7XG5pbXBvcnQgeyBjb252ZXhUb0pzb24gfSBmcm9tIFwiLi4vdmFsdWVzL3ZhbHVlLmpzXCI7XG5pbXBvcnQgeyB1c2VRdWVyaWVzIH0gZnJvbSBcIi4vdXNlX3F1ZXJpZXMuanNcIjtcbmltcG9ydCB7IENvbnZleEVycm9yIH0gZnJvbSBcIi4uL3ZhbHVlcy9lcnJvcnMuanNcIjtcbmltcG9ydCB7IHVzZUNvbnZleCB9IGZyb20gXCIuL2NsaWVudC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhZ2luYXRlZFF1ZXJ5X2V4cGVyaW1lbnRhbChxdWVyeSwgYXJncywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnM/LmluaXRpYWxOdW1JdGVtcyAhPT0gXCJudW1iZXJcIiB8fCBvcHRpb25zLmluaXRpYWxOdW1JdGVtcyA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgXFxgb3B0aW9ucy5pbml0aWFsTnVtSXRlbXNcXGAgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlci4gUmVjZWl2ZWQgXFxgJHtvcHRpb25zPy5pbml0aWFsTnVtSXRlbXN9XFxgLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IHNraXAgPSBhcmdzID09PSBcInNraXBcIjtcbiAgY29uc3QgYXJnc09iamVjdCA9IHNraXAgPyB7fSA6IGFyZ3M7XG4gIGNvbnN0IGNvbnZleENsaWVudCA9IHVzZUNvbnZleCgpO1xuICBjb25zdCBsb2dnZXIgPSBjb252ZXhDbGllbnQubG9nZ2VyO1xuICBjb25zdCBjcmVhdGVJbml0aWFsU3RhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgaWQgPSBuZXh0UGFnaW5hdGlvbklkKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgYXJnczogYXJnc09iamVjdCxcbiAgICAgIGlkLFxuICAgICAgLy8gUXVlcmllcyB3aWxsIGNvbnRhaW4gemVybyBvciBvbmUgcXVlcmllcyBmb3JldmVyLlxuICAgICAgcXVlcmllczogc2tpcCA/IHt9IDoge1xuICAgICAgICBwYWdpbmF0ZWRRdWVyeToge1xuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIGFyZ3M6IHtcbiAgICAgICAgICAgIC4uLmFyZ3NPYmplY3RcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhZ2luYXRpb25PcHRpb25zOiB7XG4gICAgICAgICAgICBpbml0aWFsTnVtSXRlbXM6IG9wdGlvbnMuaW5pdGlhbE51bUl0ZW1zLFxuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBza2lwXG4gICAgfTtcbiAgfTtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZShjcmVhdGVJbml0aWFsU3RhdGUpO1xuICBsZXQgY3VyclN0YXRlID0gc3RhdGU7XG4gIGlmIChnZXRGdW5jdGlvbk5hbWUocXVlcnkpICE9PSBnZXRGdW5jdGlvbk5hbWUoc3RhdGUucXVlcnkpIHx8IEpTT04uc3RyaW5naWZ5KGNvbnZleFRvSnNvbihhcmdzT2JqZWN0KSkgIT09IEpTT04uc3RyaW5naWZ5KGNvbnZleFRvSnNvbihzdGF0ZS5hcmdzKSkgfHwgc2tpcCAhPT0gc3RhdGUuc2tpcCkge1xuICAgIGN1cnJTdGF0ZSA9IGNyZWF0ZUluaXRpYWxTdGF0ZSgpO1xuICAgIHNldFN0YXRlKGN1cnJTdGF0ZSk7XG4gIH1cbiAgY29uc3QgcmVzdWx0c09iamVjdCA9IHVzZVF1ZXJpZXMoY3VyclN0YXRlLnF1ZXJpZXMpO1xuICBpZiAoIShcInBhZ2luYXRlZFF1ZXJ5XCIgaW4gcmVzdWx0c09iamVjdCkpIHtcbiAgICBpZiAoIXNraXApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldoeSBpcyBpdCBtaXNzaW5nP1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdHM6IFtdLFxuICAgICAgc3RhdHVzOiBcIkxvYWRpbmdGaXJzdFBhZ2VcIixcbiAgICAgIGlzTG9hZGluZzogdHJ1ZSxcbiAgICAgIGxvYWRNb3JlOiBmdW5jdGlvbiBza2lwTk9QKF9udW1JdGVtcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSByZXN1bHRzT2JqZWN0LnBhZ2luYXRlZFF1ZXJ5O1xuICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0czogW10sXG4gICAgICBsb2FkTW9yZTogKCkgPT4gZmFsc2UsXG4gICAgICBpc0xvYWRpbmc6IHRydWUsXG4gICAgICBzdGF0dXM6IFwiTG9hZGluZ0ZpcnN0UGFnZVwiXG4gICAgfTtcbiAgfVxuICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBpZiAocmVzdWx0Lm1lc3NhZ2UuaW5jbHVkZXMoXCJJbnZhbGlkQ3Vyc29yXCIpIHx8IHJlc3VsdCBpbnN0YW5jZW9mIENvbnZleEVycm9yICYmIHR5cGVvZiByZXN1bHQuZGF0YSA9PT0gXCJvYmplY3RcIiAmJiByZXN1bHQuZGF0YT8uaXNDb252ZXhTeXN0ZW1FcnJvciA9PT0gdHJ1ZSAmJiByZXN1bHQuZGF0YT8ucGFnaW5hdGlvbkVycm9yID09PSBcIkludmFsaWRDdXJzb3JcIikge1xuICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgIFwidXNlUGFnaW5hdGVkUXVlcnkgaGl0IGVycm9yLCByZXNldHRpbmcgcGFnaW5hdGlvbiBzdGF0ZTogXCIgKyByZXN1bHQubWVzc2FnZVxuICAgICAgKTtcbiAgICAgIHNldFN0YXRlKGNyZWF0ZUluaXRpYWxTdGF0ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHRzOiBbXSxcbiAgICAgICAgbG9hZE1vcmU6ICgpID0+IGZhbHNlLFxuICAgICAgICBpc0xvYWRpbmc6IHRydWUsXG4gICAgICAgIHN0YXR1czogXCJMb2FkaW5nRmlyc3RQYWdlXCJcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN1bHQsXG4gICAgbG9hZE1vcmU6IChudW0pID0+IHtcbiAgICAgIHJldHVybiByZXN1bHQubG9hZE1vcmUobnVtKTtcbiAgICB9LFxuICAgIGlzTG9hZGluZzogcmVzdWx0LnN0YXR1cyA9PT0gXCJMb2FkaW5nRmlyc3RQYWdlXCIgPyB0cnVlIDogcmVzdWx0LnN0YXR1cyA9PT0gXCJMb2FkaW5nTW9yZVwiID8gdHJ1ZSA6IGZhbHNlXG4gIH07XG59XG5sZXQgcGFnaW5hdGlvbklkID0gMDtcbmZ1bmN0aW9uIG5leHRQYWdpbmF0aW9uSWQoKSB7XG4gIHBhZ2luYXRpb25JZCsrO1xuICByZXR1cm4gcGFnaW5hdGlvbklkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0UGFnaW5hdGlvbklkKCkge1xuICBwYWdpbmF0aW9uSWQgPSAwO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlX3BhZ2luYXRlZF9xdWVyeTIuanMubWFwXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJnZXRGdW5jdGlvbk5hbWUiLCJjb252ZXhUb0pzb24iLCJ1c2VRdWVyaWVzIiwiQ29udmV4RXJyb3IiLCJ1c2VDb252ZXgiLCJ1c2VQYWdpbmF0ZWRRdWVyeV9leHBlcmltZW50YWwiLCJxdWVyeSIsImFyZ3MiLCJvcHRpb25zIiwiaW5pdGlhbE51bUl0ZW1zIiwiRXJyb3IiLCJza2lwIiwiYXJnc09iamVjdCIsImNvbnZleENsaWVudCIsImxvZ2dlciIsImNyZWF0ZUluaXRpYWxTdGF0ZSIsImlkIiwibmV4dFBhZ2luYXRpb25JZCIsInF1ZXJpZXMiLCJwYWdpbmF0ZWRRdWVyeSIsInBhZ2luYXRpb25PcHRpb25zIiwic3RhdGUiLCJzZXRTdGF0ZSIsImN1cnJTdGF0ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXN1bHRzT2JqZWN0IiwicmVzdWx0cyIsInN0YXR1cyIsImlzTG9hZGluZyIsImxvYWRNb3JlIiwic2tpcE5PUCIsIl9udW1JdGVtcyIsInJlc3VsdCIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsImRhdGEiLCJpc0NvbnZleFN5c3RlbUVycm9yIiwicGFnaW5hdGlvbkVycm9yIiwid2FybiIsIm51bSIsInBhZ2luYXRpb25JZCIsInJlc2V0UGFnaW5hdGlvbklkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/react/use_paginated_query2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/react/use_queries.js":
/*!***********************************************************!*\
  !*** ./node_modules/convex/dist/esm/react/use_queries.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useQueries: function() { return /* binding */ useQueries; },\n/* harmony export */   useQueriesHelper: function() { return /* binding */ useQueriesHelper; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/client.js\");\n/* harmony import */ var _queries_observer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./queries_observer.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/queries_observer.js\");\n/* harmony import */ var _use_subscription_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./use_subscription.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/react/use_subscription.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\"use strict\";\n\n\n\n\nfunction useQueries(queries) {\n    _s();\n    const convex = (0,_client_js__WEBPACK_IMPORTED_MODULE_1__.useConvex)();\n    if (convex === void 0) {\n        throw new Error(\"Could not find Convex client! `useQuery` must be used in the React component tree under `ConvexProvider`. Did you forget it? See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app\");\n    }\n    const createWatch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return (query, args, param)=>{\n            let { journal, paginationOptions } = param;\n            if (paginationOptions) {\n                return convex.watchPaginatedQuery(query, args, paginationOptions);\n            } else {\n                return convex.watchQuery(query, args, journal ? {\n                    journal\n                } : {});\n            }\n        };\n    }, [\n        convex\n    ]);\n    return useQueriesHelper(queries, createWatch);\n}\n_s(useQueries, \"L8QDMxsIBv80IhJOS8T1rIETIcw=\", false, function() {\n    return [\n        _client_js__WEBPACK_IMPORTED_MODULE_1__.useConvex,\n        useQueriesHelper\n    ];\n});\nfunction useQueriesHelper(queries, createWatch) {\n    _s1();\n    const [observer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new _queries_observer_js__WEBPACK_IMPORTED_MODULE_2__.QueriesObserver(createWatch));\n    if (observer.createWatch !== createWatch) {\n        observer.setCreateWatch(createWatch);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>()=>observer.destroy(), [\n        observer\n    ]);\n    const subscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            getCurrentValue: ()=>{\n                return observer.getLocalResults(queries);\n            },\n            subscribe: (callback)=>{\n                observer.setQueries(queries);\n                return observer.subscribe(callback);\n            }\n        }), [\n        observer,\n        queries\n    ]);\n    return (0,_use_subscription_js__WEBPACK_IMPORTED_MODULE_3__.useSubscription)(subscription);\n} //# sourceMappingURL=use_queries.js.map\n_s1(useQueriesHelper, \"jq3pUGLtCNynNmtoDJeiAnA5YYo=\", false, function() {\n    return [\n        _use_subscription_js__WEBPACK_IMPORTED_MODULE_3__.useSubscription\n    ];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vcmVhY3QvdXNlX3F1ZXJpZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ3FEO0FBQ2I7QUFDZ0I7QUFDQTtBQUNqRCxTQUFTTSxXQUFXQyxPQUFPOztJQUNoQyxNQUFNQyxTQUFTTCxxREFBU0E7SUFDeEIsSUFBSUssV0FBVyxLQUFLLEdBQUc7UUFDckIsTUFBTSxJQUFJQyxNQUNSO0lBRUo7SUFDQSxNQUFNQyxjQUFjVCw4Q0FBT0EsQ0FBQztRQUMxQixPQUFPLENBQUNVLE9BQU9DO2dCQUFNLEVBQ25CQyxPQUFPLEVBQ1BDLGlCQUFpQixFQUNsQjtZQUNDLElBQUlBLG1CQUFtQjtnQkFDckIsT0FBT04sT0FBT08sbUJBQW1CLENBQUNKLE9BQU9DLE1BQU1FO1lBQ2pELE9BQU87Z0JBQ0wsT0FBT04sT0FBT1EsVUFBVSxDQUFDTCxPQUFPQyxNQUFNQyxVQUFVO29CQUFFQTtnQkFBUSxJQUFJLENBQUM7WUFDakU7UUFDRjtJQUNGLEdBQUc7UUFBQ0w7S0FBTztJQUNYLE9BQU9TLGlCQUFpQlYsU0FBU0c7QUFDbkM7R0FwQmdCSjs7UUFDQ0gsaURBQVNBO1FBa0JqQmM7OztBQUVGLFNBQVNBLGlCQUFpQlYsT0FBTyxFQUFFRyxXQUFXOztJQUNuRCxNQUFNLENBQUNRLFNBQVMsR0FBR2hCLCtDQUFRQSxDQUFDLElBQU0sSUFBSUUsaUVBQWVBLENBQUNNO0lBQ3RELElBQUlRLFNBQVNSLFdBQVcsS0FBS0EsYUFBYTtRQUN4Q1EsU0FBU0MsY0FBYyxDQUFDVDtJQUMxQjtJQUNBVixnREFBU0EsQ0FBQyxJQUFNLElBQU1rQixTQUFTRSxPQUFPLElBQUk7UUFBQ0Y7S0FBUztJQUNwRCxNQUFNRyxlQUFlcEIsOENBQU9BLENBQzFCLElBQU87WUFDTHFCLGlCQUFpQjtnQkFDZixPQUFPSixTQUFTSyxlQUFlLENBQUNoQjtZQUNsQztZQUNBaUIsV0FBVyxDQUFDQztnQkFDVlAsU0FBU1EsVUFBVSxDQUFDbkI7Z0JBQ3BCLE9BQU9XLFNBQVNNLFNBQVMsQ0FBQ0M7WUFDNUI7UUFDRixJQUNBO1FBQUNQO1FBQVVYO0tBQVE7SUFFckIsT0FBT0YscUVBQWVBLENBQUNnQjtBQUN6QixFQUNBLHVDQUF1QztJQXBCdkJKOztRQWtCUFosaUVBQWVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vcmVhY3QvdXNlX3F1ZXJpZXMuanM/OGUyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUNvbnZleCB9IGZyb20gXCIuL2NsaWVudC5qc1wiO1xuaW1wb3J0IHsgUXVlcmllc09ic2VydmVyIH0gZnJvbSBcIi4vcXVlcmllc19vYnNlcnZlci5qc1wiO1xuaW1wb3J0IHsgdXNlU3Vic2NyaXB0aW9uIH0gZnJvbSBcIi4vdXNlX3N1YnNjcmlwdGlvbi5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVF1ZXJpZXMocXVlcmllcykge1xuICBjb25zdCBjb252ZXggPSB1c2VDb252ZXgoKTtcbiAgaWYgKGNvbnZleCA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJDb3VsZCBub3QgZmluZCBDb252ZXggY2xpZW50ISBgdXNlUXVlcnlgIG11c3QgYmUgdXNlZCBpbiB0aGUgUmVhY3QgY29tcG9uZW50IHRyZWUgdW5kZXIgYENvbnZleFByb3ZpZGVyYC4gRGlkIHlvdSBmb3JnZXQgaXQ/IFNlZSBodHRwczovL2RvY3MuY29udmV4LmRldi9xdWljay1zdGFydCNzZXQtdXAtY29udmV4LWluLXlvdXItcmVhY3QtYXBwXCJcbiAgICApO1xuICB9XG4gIGNvbnN0IGNyZWF0ZVdhdGNoID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIChxdWVyeSwgYXJncywge1xuICAgICAgam91cm5hbCxcbiAgICAgIHBhZ2luYXRpb25PcHRpb25zXG4gICAgfSkgPT4ge1xuICAgICAgaWYgKHBhZ2luYXRpb25PcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBjb252ZXgud2F0Y2hQYWdpbmF0ZWRRdWVyeShxdWVyeSwgYXJncywgcGFnaW5hdGlvbk9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnZleC53YXRjaFF1ZXJ5KHF1ZXJ5LCBhcmdzLCBqb3VybmFsID8geyBqb3VybmFsIH0gOiB7fSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2NvbnZleF0pO1xuICByZXR1cm4gdXNlUXVlcmllc0hlbHBlcihxdWVyaWVzLCBjcmVhdGVXYXRjaCk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlUXVlcmllc0hlbHBlcihxdWVyaWVzLCBjcmVhdGVXYXRjaCkge1xuICBjb25zdCBbb2JzZXJ2ZXJdID0gdXNlU3RhdGUoKCkgPT4gbmV3IFF1ZXJpZXNPYnNlcnZlcihjcmVhdGVXYXRjaCkpO1xuICBpZiAob2JzZXJ2ZXIuY3JlYXRlV2F0Y2ggIT09IGNyZWF0ZVdhdGNoKSB7XG4gICAgb2JzZXJ2ZXIuc2V0Q3JlYXRlV2F0Y2goY3JlYXRlV2F0Y2gpO1xuICB9XG4gIHVzZUVmZmVjdCgoKSA9PiAoKSA9PiBvYnNlcnZlci5kZXN0cm95KCksIFtvYnNlcnZlcl0pO1xuICBjb25zdCBzdWJzY3JpcHRpb24gPSB1c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBnZXRDdXJyZW50VmFsdWU6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyLmdldExvY2FsUmVzdWx0cyhxdWVyaWVzKTtcbiAgICAgIH0sXG4gICAgICBzdWJzY3JpYmU6IChjYWxsYmFjaykgPT4ge1xuICAgICAgICBvYnNlcnZlci5zZXRRdWVyaWVzKHF1ZXJpZXMpO1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBbb2JzZXJ2ZXIsIHF1ZXJpZXNdXG4gICk7XG4gIHJldHVybiB1c2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZV9xdWVyaWVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VTdGF0ZSIsInVzZUNvbnZleCIsIlF1ZXJpZXNPYnNlcnZlciIsInVzZVN1YnNjcmlwdGlvbiIsInVzZVF1ZXJpZXMiLCJxdWVyaWVzIiwiY29udmV4IiwiRXJyb3IiLCJjcmVhdGVXYXRjaCIsInF1ZXJ5IiwiYXJncyIsImpvdXJuYWwiLCJwYWdpbmF0aW9uT3B0aW9ucyIsIndhdGNoUGFnaW5hdGVkUXVlcnkiLCJ3YXRjaFF1ZXJ5IiwidXNlUXVlcmllc0hlbHBlciIsIm9ic2VydmVyIiwic2V0Q3JlYXRlV2F0Y2giLCJkZXN0cm95Iiwic3Vic2NyaXB0aW9uIiwiZ2V0Q3VycmVudFZhbHVlIiwiZ2V0TG9jYWxSZXN1bHRzIiwic3Vic2NyaWJlIiwiY2FsbGJhY2siLCJzZXRRdWVyaWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/react/use_queries.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/react/use_subscription.js":
/*!****************************************************************!*\
  !*** ./node_modules/convex/dist/esm/react/use_subscription.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSubscription: function() { return /* binding */ useSubscription; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar _s = $RefreshSig$();\n\"use strict\";\n\nfunction useSubscription(param) {\n    let { // (Synchronously) returns the current value of our subscription.\n    getCurrentValue, // This function is passed an event handler to attach to the subscription.\n    // It should return an unsubscribe function that removes the handler.\n    subscribe } = param;\n    _s();\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>({\n            getCurrentValue,\n            subscribe,\n            value: getCurrentValue()\n        }));\n    let valueToReturn = state.value;\n    if (state.getCurrentValue !== getCurrentValue || state.subscribe !== subscribe) {\n        valueToReturn = getCurrentValue();\n        setState({\n            getCurrentValue,\n            subscribe,\n            value: valueToReturn\n        });\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let didUnsubscribe = false;\n        const checkForUpdates = ()=>{\n            if (didUnsubscribe) {\n                return;\n            }\n            setState((prevState)=>{\n                if (prevState.getCurrentValue !== getCurrentValue || prevState.subscribe !== subscribe) {\n                    return prevState;\n                }\n                const value = getCurrentValue();\n                if (prevState.value === value) {\n                    return prevState;\n                }\n                return {\n                    ...prevState,\n                    value\n                };\n            });\n        };\n        const unsubscribe = subscribe(checkForUpdates);\n        checkForUpdates();\n        return ()=>{\n            didUnsubscribe = true;\n            unsubscribe();\n        };\n    }, [\n        getCurrentValue,\n        subscribe\n    ]);\n    return valueToReturn;\n} //# sourceMappingURL=use_subscription.js.map\n_s(useSubscription, \"Dtm03pS3jKGb5Mj0EFZUcLolbbI=\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vcmVhY3QvdXNlX3N1YnNjcmlwdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUM0QztBQUNyQyxTQUFTRSxnQkFBZ0IsS0FNL0I7UUFOK0IsRUFDOUIsaUVBQWlFO0lBQ2pFQyxlQUFlLEVBQ2YsMEVBQTBFO0lBQzFFLHFFQUFxRTtJQUNyRUMsU0FBUyxFQUNWLEdBTitCOztJQU85QixNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR0wsK0NBQVFBLENBQUMsSUFBTztZQUN4Q0U7WUFDQUM7WUFDQUcsT0FBT0o7UUFDVDtJQUNBLElBQUlLLGdCQUFnQkgsTUFBTUUsS0FBSztJQUMvQixJQUFJRixNQUFNRixlQUFlLEtBQUtBLG1CQUFtQkUsTUFBTUQsU0FBUyxLQUFLQSxXQUFXO1FBQzlFSSxnQkFBZ0JMO1FBQ2hCRyxTQUFTO1lBQ1BIO1lBQ0FDO1lBQ0FHLE9BQU9DO1FBQ1Q7SUFDRjtJQUNBUixnREFBU0EsQ0FBQztRQUNSLElBQUlTLGlCQUFpQjtRQUNyQixNQUFNQyxrQkFBa0I7WUFDdEIsSUFBSUQsZ0JBQWdCO2dCQUNsQjtZQUNGO1lBQ0FILFNBQVMsQ0FBQ0s7Z0JBQ1IsSUFBSUEsVUFBVVIsZUFBZSxLQUFLQSxtQkFBbUJRLFVBQVVQLFNBQVMsS0FBS0EsV0FBVztvQkFDdEYsT0FBT087Z0JBQ1Q7Z0JBQ0EsTUFBTUosUUFBUUo7Z0JBQ2QsSUFBSVEsVUFBVUosS0FBSyxLQUFLQSxPQUFPO29CQUM3QixPQUFPSTtnQkFDVDtnQkFDQSxPQUFPO29CQUFFLEdBQUdBLFNBQVM7b0JBQUVKO2dCQUFNO1lBQy9CO1FBQ0Y7UUFDQSxNQUFNSyxjQUFjUixVQUFVTTtRQUM5QkE7UUFDQSxPQUFPO1lBQ0xELGlCQUFpQjtZQUNqQkc7UUFDRjtJQUNGLEdBQUc7UUFBQ1Q7UUFBaUJDO0tBQVU7SUFDL0IsT0FBT0k7QUFDVCxFQUNBLDRDQUE0QztHQS9DNUJOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vcmVhY3QvdXNlX3N1YnNjcmlwdGlvbi5qcz85ZmQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN1YnNjcmlwdGlvbih7XG4gIC8vIChTeW5jaHJvbm91c2x5KSByZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIG91ciBzdWJzY3JpcHRpb24uXG4gIGdldEN1cnJlbnRWYWx1ZSxcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXNzZWQgYW4gZXZlbnQgaGFuZGxlciB0byBhdHRhY2ggdG8gdGhlIHN1YnNjcmlwdGlvbi5cbiAgLy8gSXQgc2hvdWxkIHJldHVybiBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbiB0aGF0IHJlbW92ZXMgdGhlIGhhbmRsZXIuXG4gIHN1YnNjcmliZVxufSkge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlKCgpID0+ICh7XG4gICAgZ2V0Q3VycmVudFZhbHVlLFxuICAgIHN1YnNjcmliZSxcbiAgICB2YWx1ZTogZ2V0Q3VycmVudFZhbHVlKClcbiAgfSkpO1xuICBsZXQgdmFsdWVUb1JldHVybiA9IHN0YXRlLnZhbHVlO1xuICBpZiAoc3RhdGUuZ2V0Q3VycmVudFZhbHVlICE9PSBnZXRDdXJyZW50VmFsdWUgfHwgc3RhdGUuc3Vic2NyaWJlICE9PSBzdWJzY3JpYmUpIHtcbiAgICB2YWx1ZVRvUmV0dXJuID0gZ2V0Q3VycmVudFZhbHVlKCk7XG4gICAgc2V0U3RhdGUoe1xuICAgICAgZ2V0Q3VycmVudFZhbHVlLFxuICAgICAgc3Vic2NyaWJlLFxuICAgICAgdmFsdWU6IHZhbHVlVG9SZXR1cm5cbiAgICB9KTtcbiAgfVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBkaWRVbnN1YnNjcmliZSA9IGZhbHNlO1xuICAgIGNvbnN0IGNoZWNrRm9yVXBkYXRlcyA9ICgpID0+IHtcbiAgICAgIGlmIChkaWRVbnN1YnNjcmliZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRTdGF0ZSgocHJldlN0YXRlKSA9PiB7XG4gICAgICAgIGlmIChwcmV2U3RhdGUuZ2V0Q3VycmVudFZhbHVlICE9PSBnZXRDdXJyZW50VmFsdWUgfHwgcHJldlN0YXRlLnN1YnNjcmliZSAhPT0gc3Vic2NyaWJlKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEN1cnJlbnRWYWx1ZSgpO1xuICAgICAgICBpZiAocHJldlN0YXRlLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgLi4ucHJldlN0YXRlLCB2YWx1ZSB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN1YnNjcmliZShjaGVja0ZvclVwZGF0ZXMpO1xuICAgIGNoZWNrRm9yVXBkYXRlcygpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkaWRVbnN1YnNjcmliZSA9IHRydWU7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFtnZXRDdXJyZW50VmFsdWUsIHN1YnNjcmliZV0pO1xuICByZXR1cm4gdmFsdWVUb1JldHVybjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZV9zdWJzY3JpcHRpb24uanMubWFwXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VTdWJzY3JpcHRpb24iLCJnZXRDdXJyZW50VmFsdWUiLCJzdWJzY3JpYmUiLCJzdGF0ZSIsInNldFN0YXRlIiwidmFsdWUiLCJ2YWx1ZVRvUmV0dXJuIiwiZGlkVW5zdWJzY3JpYmUiLCJjaGVja0ZvclVwZGF0ZXMiLCJwcmV2U3RhdGUiLCJ1bnN1YnNjcmliZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/react/use_subscription.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/server/api.js":
/*!****************************************************!*\
  !*** ./node_modules/convex/dist/esm/server/api.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   anyApi: function() { return /* binding */ anyApi; },\n/* harmony export */   filterApi: function() { return /* binding */ filterApi; },\n/* harmony export */   getFunctionName: function() { return /* binding */ getFunctionName; },\n/* harmony export */   justActions: function() { return /* binding */ justActions; },\n/* harmony export */   justInternal: function() { return /* binding */ justInternal; },\n/* harmony export */   justMutations: function() { return /* binding */ justMutations; },\n/* harmony export */   justPaginatedQueries: function() { return /* binding */ justPaginatedQueries; },\n/* harmony export */   justPublic: function() { return /* binding */ justPublic; },\n/* harmony export */   justQueries: function() { return /* binding */ justQueries; },\n/* harmony export */   justSchedulable: function() { return /* binding */ justSchedulable; },\n/* harmony export */   makeFunctionReference: function() { return /* binding */ makeFunctionReference; }\n/* harmony export */ });\n/* harmony import */ var _functionName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functionName.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/server/functionName.js\");\n/* harmony import */ var _components_paths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/paths.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/server/components/paths.js\");\n\n\n\nfunction getFunctionName(functionReference) {\n    const address = (0,_components_paths_js__WEBPACK_IMPORTED_MODULE_1__.getFunctionAddress)(functionReference);\n    if (address.name === void 0) {\n        if (address.functionHandle !== void 0) {\n            throw new Error('Expected function reference like \"api.file.func\" or \"internal.file.func\", but received function handle '.concat(address.functionHandle));\n        } else if (address.reference !== void 0) {\n            throw new Error('Expected function reference in the current component like \"api.file.func\" or \"internal.file.func\", but received reference '.concat(address.reference));\n        }\n        throw new Error('Expected function reference like \"api.file.func\" or \"internal.file.func\", but received '.concat(JSON.stringify(address)));\n    }\n    if (typeof functionReference === \"string\") return functionReference;\n    const name = functionReference[_functionName_js__WEBPACK_IMPORTED_MODULE_0__.functionName];\n    if (!name) {\n        throw new Error(\"\".concat(functionReference, \" is not a functionReference\"));\n    }\n    return name;\n}\nfunction makeFunctionReference(name) {\n    return {\n        [_functionName_js__WEBPACK_IMPORTED_MODULE_0__.functionName]: name\n    };\n}\nfunction createApi() {\n    let pathParts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    const handler = {\n        get (_, prop) {\n            if (typeof prop === \"string\") {\n                const newParts = [\n                    ...pathParts,\n                    prop\n                ];\n                return createApi(newParts);\n            } else if (prop === _functionName_js__WEBPACK_IMPORTED_MODULE_0__.functionName) {\n                if (pathParts.length < 2) {\n                    const found = [\n                        \"api\",\n                        ...pathParts\n                    ].join(\".\");\n                    throw new Error(\"API path is expected to be of the form `api.moduleName.functionName`. Found: `\".concat(found, \"`\"));\n                }\n                const path = pathParts.slice(0, -1).join(\"/\");\n                const exportName = pathParts[pathParts.length - 1];\n                if (exportName === \"default\") {\n                    return path;\n                } else {\n                    return path + \":\" + exportName;\n                }\n            } else if (prop === Symbol.toStringTag) {\n                return \"FunctionReference\";\n            } else {\n                return void 0;\n            }\n        }\n    };\n    return new Proxy({}, handler);\n}\nfunction filterApi(api) {\n    return api;\n}\nfunction justInternal(api) {\n    return api;\n}\nfunction justPublic(api) {\n    return api;\n}\nfunction justQueries(api) {\n    return api;\n}\nfunction justMutations(api) {\n    return api;\n}\nfunction justActions(api) {\n    return api;\n}\nfunction justPaginatedQueries(api) {\n    return api;\n}\nfunction justSchedulable(api) {\n    return api;\n}\nconst anyApi = createApi(); //# sourceMappingURL=api.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vc2VydmVyL2FwaS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDb0M7QUFDVTtBQUNwRCxTQUFTRSxnQkFBZ0JDLGlCQUFpQjtJQUMvQyxNQUFNQyxVQUFVSCx3RUFBa0JBLENBQUNFO0lBQ25DLElBQUlDLFFBQVFDLElBQUksS0FBSyxLQUFLLEdBQUc7UUFDM0IsSUFBSUQsUUFBUUUsY0FBYyxLQUFLLEtBQUssR0FBRztZQUNyQyxNQUFNLElBQUlDLE1BQ1IsMEdBQWlJLE9BQXZCSCxRQUFRRSxjQUFjO1FBRXBJLE9BQU8sSUFBSUYsUUFBUUksU0FBUyxLQUFLLEtBQUssR0FBRztZQUN2QyxNQUFNLElBQUlELE1BQ1IsNkhBQStJLE9BQWxCSCxRQUFRSSxTQUFTO1FBRWxKO1FBQ0EsTUFBTSxJQUFJRCxNQUNSLDBGQUFrSCxPQUF4QkUsS0FBS0MsU0FBUyxDQUFDTjtJQUU3RztJQUNBLElBQUksT0FBT0Qsc0JBQXNCLFVBQVUsT0FBT0E7SUFDbEQsTUFBTUUsT0FBT0YsaUJBQWlCLENBQUNILDBEQUFZQSxDQUFDO0lBQzVDLElBQUksQ0FBQ0ssTUFBTTtRQUNULE1BQU0sSUFBSUUsTUFBTSxHQUFxQixPQUFsQkosbUJBQWtCO0lBQ3ZDO0lBQ0EsT0FBT0U7QUFDVDtBQUNPLFNBQVNNLHNCQUFzQk4sSUFBSTtJQUN4QyxPQUFPO1FBQUUsQ0FBQ0wsMERBQVlBLENBQUMsRUFBRUs7SUFBSztBQUNoQztBQUNBLFNBQVNPO1FBQVVDLFlBQUFBLGlFQUFZLEVBQUU7SUFDL0IsTUFBTUMsVUFBVTtRQUNkQyxLQUFJQyxDQUFDLEVBQUVDLElBQUk7WUFDVCxJQUFJLE9BQU9BLFNBQVMsVUFBVTtnQkFDNUIsTUFBTUMsV0FBVzt1QkFBSUw7b0JBQVdJO2lCQUFLO2dCQUNyQyxPQUFPTCxVQUFVTTtZQUNuQixPQUFPLElBQUlELFNBQVNqQiwwREFBWUEsRUFBRTtnQkFDaEMsSUFBSWEsVUFBVU0sTUFBTSxHQUFHLEdBQUc7b0JBQ3hCLE1BQU1DLFFBQVE7d0JBQUM7MkJBQVVQO3FCQUFVLENBQUNRLElBQUksQ0FBQztvQkFDekMsTUFBTSxJQUFJZCxNQUNSLGlGQUEwRixPQUFOYSxPQUFNO2dCQUU5RjtnQkFDQSxNQUFNRSxPQUFPVCxVQUFVVSxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUdGLElBQUksQ0FBQztnQkFDekMsTUFBTUcsYUFBYVgsU0FBUyxDQUFDQSxVQUFVTSxNQUFNLEdBQUcsRUFBRTtnQkFDbEQsSUFBSUssZUFBZSxXQUFXO29CQUM1QixPQUFPRjtnQkFDVCxPQUFPO29CQUNMLE9BQU9BLE9BQU8sTUFBTUU7Z0JBQ3RCO1lBQ0YsT0FBTyxJQUFJUCxTQUFTUSxPQUFPQyxXQUFXLEVBQUU7Z0JBQ3RDLE9BQU87WUFDVCxPQUFPO2dCQUNMLE9BQU8sS0FBSztZQUNkO1FBQ0Y7SUFDRjtJQUNBLE9BQU8sSUFBSUMsTUFBTSxDQUFDLEdBQUdiO0FBQ3ZCO0FBQ08sU0FBU2MsVUFBVUMsR0FBRztJQUMzQixPQUFPQTtBQUNUO0FBQ08sU0FBU0MsYUFBYUQsR0FBRztJQUM5QixPQUFPQTtBQUNUO0FBQ08sU0FBU0UsV0FBV0YsR0FBRztJQUM1QixPQUFPQTtBQUNUO0FBQ08sU0FBU0csWUFBWUgsR0FBRztJQUM3QixPQUFPQTtBQUNUO0FBQ08sU0FBU0ksY0FBY0osR0FBRztJQUMvQixPQUFPQTtBQUNUO0FBQ08sU0FBU0ssWUFBWUwsR0FBRztJQUM3QixPQUFPQTtBQUNUO0FBQ08sU0FBU00scUJBQXFCTixHQUFHO0lBQ3RDLE9BQU9BO0FBQ1Q7QUFDTyxTQUFTTyxnQkFBZ0JQLEdBQUc7SUFDakMsT0FBT0E7QUFDVDtBQUNPLE1BQU1RLFNBQVN6QixZQUFZLENBQ2xDLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3NlcnZlci9hcGkuanM/NmMxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGZ1bmN0aW9uTmFtZSB9IGZyb20gXCIuL2Z1bmN0aW9uTmFtZS5qc1wiO1xuaW1wb3J0IHsgZ2V0RnVuY3Rpb25BZGRyZXNzIH0gZnJvbSBcIi4vY29tcG9uZW50cy9wYXRocy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShmdW5jdGlvblJlZmVyZW5jZSkge1xuICBjb25zdCBhZGRyZXNzID0gZ2V0RnVuY3Rpb25BZGRyZXNzKGZ1bmN0aW9uUmVmZXJlbmNlKTtcbiAgaWYgKGFkZHJlc3MubmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgaWYgKGFkZHJlc3MuZnVuY3Rpb25IYW5kbGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGxpa2UgXCJhcGkuZmlsZS5mdW5jXCIgb3IgXCJpbnRlcm5hbC5maWxlLmZ1bmNcIiwgYnV0IHJlY2VpdmVkIGZ1bmN0aW9uIGhhbmRsZSAke2FkZHJlc3MuZnVuY3Rpb25IYW5kbGV9YFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGFkZHJlc3MucmVmZXJlbmNlICE9PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEV4cGVjdGVkIGZ1bmN0aW9uIHJlZmVyZW5jZSBpbiB0aGUgY3VycmVudCBjb21wb25lbnQgbGlrZSBcImFwaS5maWxlLmZ1bmNcIiBvciBcImludGVybmFsLmZpbGUuZnVuY1wiLCBidXQgcmVjZWl2ZWQgcmVmZXJlbmNlICR7YWRkcmVzcy5yZWZlcmVuY2V9YFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIGZ1bmN0aW9uIHJlZmVyZW5jZSBsaWtlIFwiYXBpLmZpbGUuZnVuY1wiIG9yIFwiaW50ZXJuYWwuZmlsZS5mdW5jXCIsIGJ1dCByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KGFkZHJlc3MpfWBcbiAgICApO1xuICB9XG4gIGlmICh0eXBlb2YgZnVuY3Rpb25SZWZlcmVuY2UgPT09IFwic3RyaW5nXCIpIHJldHVybiBmdW5jdGlvblJlZmVyZW5jZTtcbiAgY29uc3QgbmFtZSA9IGZ1bmN0aW9uUmVmZXJlbmNlW2Z1bmN0aW9uTmFtZV07XG4gIGlmICghbmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvblJlZmVyZW5jZX0gaXMgbm90IGEgZnVuY3Rpb25SZWZlcmVuY2VgKTtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRnVuY3Rpb25SZWZlcmVuY2UobmFtZSkge1xuICByZXR1cm4geyBbZnVuY3Rpb25OYW1lXTogbmFtZSB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQXBpKHBhdGhQYXJ0cyA9IFtdKSB7XG4gIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgZ2V0KF8sIHByb3ApIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBuZXdQYXJ0cyA9IFsuLi5wYXRoUGFydHMsIHByb3BdO1xuICAgICAgICByZXR1cm4gY3JlYXRlQXBpKG5ld1BhcnRzKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgIGlmIChwYXRoUGFydHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIGNvbnN0IGZvdW5kID0gW1wiYXBpXCIsIC4uLnBhdGhQYXJ0c10uam9pbihcIi5cIik7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEFQSSBwYXRoIGlzIGV4cGVjdGVkIHRvIGJlIG9mIHRoZSBmb3JtIFxcYGFwaS5tb2R1bGVOYW1lLmZ1bmN0aW9uTmFtZVxcYC4gRm91bmQ6IFxcYCR7Zm91bmR9XFxgYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aCA9IHBhdGhQYXJ0cy5zbGljZSgwLCAtMSkuam9pbihcIi9cIik7XG4gICAgICAgIGNvbnN0IGV4cG9ydE5hbWUgPSBwYXRoUGFydHNbcGF0aFBhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZXhwb3J0TmFtZSA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcGF0aCArIFwiOlwiICsgZXhwb3J0TmFtZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiAgICAgICAgcmV0dXJuIFwiRnVuY3Rpb25SZWZlcmVuY2VcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KHt9LCBoYW5kbGVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJBcGkoYXBpKSB7XG4gIHJldHVybiBhcGk7XG59XG5leHBvcnQgZnVuY3Rpb24ganVzdEludGVybmFsKGFwaSkge1xuICByZXR1cm4gYXBpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGp1c3RQdWJsaWMoYXBpKSB7XG4gIHJldHVybiBhcGk7XG59XG5leHBvcnQgZnVuY3Rpb24ganVzdFF1ZXJpZXMoYXBpKSB7XG4gIHJldHVybiBhcGk7XG59XG5leHBvcnQgZnVuY3Rpb24ganVzdE11dGF0aW9ucyhhcGkpIHtcbiAgcmV0dXJuIGFwaTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBqdXN0QWN0aW9ucyhhcGkpIHtcbiAgcmV0dXJuIGFwaTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBqdXN0UGFnaW5hdGVkUXVlcmllcyhhcGkpIHtcbiAgcmV0dXJuIGFwaTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBqdXN0U2NoZWR1bGFibGUoYXBpKSB7XG4gIHJldHVybiBhcGk7XG59XG5leHBvcnQgY29uc3QgYW55QXBpID0gY3JlYXRlQXBpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwXG4iXSwibmFtZXMiOlsiZnVuY3Rpb25OYW1lIiwiZ2V0RnVuY3Rpb25BZGRyZXNzIiwiZ2V0RnVuY3Rpb25OYW1lIiwiZnVuY3Rpb25SZWZlcmVuY2UiLCJhZGRyZXNzIiwibmFtZSIsImZ1bmN0aW9uSGFuZGxlIiwiRXJyb3IiLCJyZWZlcmVuY2UiLCJKU09OIiwic3RyaW5naWZ5IiwibWFrZUZ1bmN0aW9uUmVmZXJlbmNlIiwiY3JlYXRlQXBpIiwicGF0aFBhcnRzIiwiaGFuZGxlciIsImdldCIsIl8iLCJwcm9wIiwibmV3UGFydHMiLCJsZW5ndGgiLCJmb3VuZCIsImpvaW4iLCJwYXRoIiwic2xpY2UiLCJleHBvcnROYW1lIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJQcm94eSIsImZpbHRlckFwaSIsImFwaSIsImp1c3RJbnRlcm5hbCIsImp1c3RQdWJsaWMiLCJqdXN0UXVlcmllcyIsImp1c3RNdXRhdGlvbnMiLCJqdXN0QWN0aW9ucyIsImp1c3RQYWdpbmF0ZWRRdWVyaWVzIiwianVzdFNjaGVkdWxhYmxlIiwiYW55QXBpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/server/api.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/server/components/paths.js":
/*!*****************************************************************!*\
  !*** ./node_modules/convex/dist/esm/server/components/paths.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractReferencePath: function() { return /* binding */ extractReferencePath; },\n/* harmony export */   getFunctionAddress: function() { return /* binding */ getFunctionAddress; },\n/* harmony export */   isFunctionHandle: function() { return /* binding */ isFunctionHandle; },\n/* harmony export */   setReferencePath: function() { return /* binding */ setReferencePath; },\n/* harmony export */   toReferencePath: function() { return /* binding */ toReferencePath; }\n/* harmony export */ });\n/* harmony import */ var _functionName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functionName.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/server/functionName.js\");\n\n\nconst toReferencePath = Symbol.for(\"toReferencePath\");\nfunction setReferencePath(obj, value) {\n    obj[toReferencePath] = value;\n}\nfunction extractReferencePath(reference) {\n    var _reference_toReferencePath;\n    return (_reference_toReferencePath = reference[toReferencePath]) !== null && _reference_toReferencePath !== void 0 ? _reference_toReferencePath : null;\n}\nfunction isFunctionHandle(s) {\n    return s.startsWith(\"function://\");\n}\nfunction getFunctionAddress(functionReference) {\n    let functionAddress;\n    if (typeof functionReference === \"string\") {\n        if (isFunctionHandle(functionReference)) {\n            functionAddress = {\n                functionHandle: functionReference\n            };\n        } else {\n            functionAddress = {\n                name: functionReference\n            };\n        }\n    } else if (functionReference[_functionName_js__WEBPACK_IMPORTED_MODULE_0__.functionName]) {\n        functionAddress = {\n            name: functionReference[_functionName_js__WEBPACK_IMPORTED_MODULE_0__.functionName]\n        };\n    } else {\n        const referencePath = extractReferencePath(functionReference);\n        if (!referencePath) {\n            throw new Error(\"\".concat(functionReference, \" is not a functionReference\"));\n        }\n        functionAddress = {\n            reference: referencePath\n        };\n    }\n    return functionAddress;\n} //# sourceMappingURL=paths.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vc2VydmVyL2NvbXBvbmVudHMvcGF0aHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWE7QUFDcUM7QUFDM0MsTUFBTUMsa0JBQWtCQyxPQUFPQyxHQUFHLENBQUMsbUJBQW1CO0FBQ3RELFNBQVNDLGlCQUFpQkMsR0FBRyxFQUFFQyxLQUFLO0lBQ3pDRCxHQUFHLENBQUNKLGdCQUFnQixHQUFHSztBQUN6QjtBQUNPLFNBQVNDLHFCQUFxQkMsU0FBUztRQUNyQ0E7SUFBUCxPQUFPQSxDQUFBQSw2QkFBQUEsU0FBUyxDQUFDUCxnQkFBZ0IsY0FBMUJPLHdDQUFBQSw2QkFBOEI7QUFDdkM7QUFDTyxTQUFTQyxpQkFBaUJDLENBQUM7SUFDaEMsT0FBT0EsRUFBRUMsVUFBVSxDQUFDO0FBQ3RCO0FBQ08sU0FBU0MsbUJBQW1CQyxpQkFBaUI7SUFDbEQsSUFBSUM7SUFDSixJQUFJLE9BQU9ELHNCQUFzQixVQUFVO1FBQ3pDLElBQUlKLGlCQUFpQkksb0JBQW9CO1lBQ3ZDQyxrQkFBa0I7Z0JBQUVDLGdCQUFnQkY7WUFBa0I7UUFDeEQsT0FBTztZQUNMQyxrQkFBa0I7Z0JBQUVFLE1BQU1IO1lBQWtCO1FBQzlDO0lBQ0YsT0FBTyxJQUFJQSxpQkFBaUIsQ0FBQ2IsMERBQVlBLENBQUMsRUFBRTtRQUMxQ2Msa0JBQWtCO1lBQUVFLE1BQU1ILGlCQUFpQixDQUFDYiwwREFBWUEsQ0FBQztRQUFDO0lBQzVELE9BQU87UUFDTCxNQUFNaUIsZ0JBQWdCVixxQkFBcUJNO1FBQzNDLElBQUksQ0FBQ0ksZUFBZTtZQUNsQixNQUFNLElBQUlDLE1BQU0sR0FBcUIsT0FBbEJMLG1CQUFrQjtRQUN2QztRQUNBQyxrQkFBa0I7WUFBRU4sV0FBV1M7UUFBYztJQUMvQztJQUNBLE9BQU9IO0FBQ1QsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9zZXJ2ZXIvY29tcG9uZW50cy9wYXRocy5qcz8wMmU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZnVuY3Rpb25OYW1lIH0gZnJvbSBcIi4uL2Z1bmN0aW9uTmFtZS5qc1wiO1xuZXhwb3J0IGNvbnN0IHRvUmVmZXJlbmNlUGF0aCA9IFN5bWJvbC5mb3IoXCJ0b1JlZmVyZW5jZVBhdGhcIik7XG5leHBvcnQgZnVuY3Rpb24gc2V0UmVmZXJlbmNlUGF0aChvYmosIHZhbHVlKSB7XG4gIG9ialt0b1JlZmVyZW5jZVBhdGhdID0gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFJlZmVyZW5jZVBhdGgocmVmZXJlbmNlKSB7XG4gIHJldHVybiByZWZlcmVuY2VbdG9SZWZlcmVuY2VQYXRoXSA/PyBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb25IYW5kbGUocykge1xuICByZXR1cm4gcy5zdGFydHNXaXRoKFwiZnVuY3Rpb246Ly9cIik7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RnVuY3Rpb25BZGRyZXNzKGZ1bmN0aW9uUmVmZXJlbmNlKSB7XG4gIGxldCBmdW5jdGlvbkFkZHJlc3M7XG4gIGlmICh0eXBlb2YgZnVuY3Rpb25SZWZlcmVuY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoaXNGdW5jdGlvbkhhbmRsZShmdW5jdGlvblJlZmVyZW5jZSkpIHtcbiAgICAgIGZ1bmN0aW9uQWRkcmVzcyA9IHsgZnVuY3Rpb25IYW5kbGU6IGZ1bmN0aW9uUmVmZXJlbmNlIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bmN0aW9uQWRkcmVzcyA9IHsgbmFtZTogZnVuY3Rpb25SZWZlcmVuY2UgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZnVuY3Rpb25SZWZlcmVuY2VbZnVuY3Rpb25OYW1lXSkge1xuICAgIGZ1bmN0aW9uQWRkcmVzcyA9IHsgbmFtZTogZnVuY3Rpb25SZWZlcmVuY2VbZnVuY3Rpb25OYW1lXSB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJlZmVyZW5jZVBhdGggPSBleHRyYWN0UmVmZXJlbmNlUGF0aChmdW5jdGlvblJlZmVyZW5jZSk7XG4gICAgaWYgKCFyZWZlcmVuY2VQYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25SZWZlcmVuY2V9IGlzIG5vdCBhIGZ1bmN0aW9uUmVmZXJlbmNlYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uQWRkcmVzcyA9IHsgcmVmZXJlbmNlOiByZWZlcmVuY2VQYXRoIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uQWRkcmVzcztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGhzLmpzLm1hcFxuIl0sIm5hbWVzIjpbImZ1bmN0aW9uTmFtZSIsInRvUmVmZXJlbmNlUGF0aCIsIlN5bWJvbCIsImZvciIsInNldFJlZmVyZW5jZVBhdGgiLCJvYmoiLCJ2YWx1ZSIsImV4dHJhY3RSZWZlcmVuY2VQYXRoIiwicmVmZXJlbmNlIiwiaXNGdW5jdGlvbkhhbmRsZSIsInMiLCJzdGFydHNXaXRoIiwiZ2V0RnVuY3Rpb25BZGRyZXNzIiwiZnVuY3Rpb25SZWZlcmVuY2UiLCJmdW5jdGlvbkFkZHJlc3MiLCJmdW5jdGlvbkhhbmRsZSIsIm5hbWUiLCJyZWZlcmVuY2VQYXRoIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/server/components/paths.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/server/functionName.js":
/*!*************************************************************!*\
  !*** ./node_modules/convex/dist/esm/server/functionName.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   functionName: function() { return /* binding */ functionName; }\n/* harmony export */ });\n\nconst functionName = Symbol.for(\"functionName\"); //# sourceMappingURL=functionName.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vc2VydmVyL2Z1bmN0aW9uTmFtZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWE7QUFDTixNQUFNQSxlQUFlQyxPQUFPQyxHQUFHLENBQUMsZ0JBQWdCLENBQ3ZELHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3NlcnZlci9mdW5jdGlvbk5hbWUuanM/N2IyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydCBjb25zdCBmdW5jdGlvbk5hbWUgPSBTeW1ib2wuZm9yKFwiZnVuY3Rpb25OYW1lXCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb25OYW1lLmpzLm1hcFxuIl0sIm5hbWVzIjpbImZ1bmN0aW9uTmFtZSIsIlN5bWJvbCIsImZvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/server/functionName.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/values/base64.js":
/*!*******************************************************!*\
  !*** ./node_modules/convex/dist/esm/values/base64.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   byteLength: function() { return /* binding */ byteLength; },\n/* harmony export */   fromByteArray: function() { return /* binding */ fromByteArray; },\n/* harmony export */   fromByteArrayUrlSafeNoPadding: function() { return /* binding */ fromByteArrayUrlSafeNoPadding; },\n/* harmony export */   toByteArray: function() { return /* binding */ toByteArray; }\n/* harmony export */ });\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = Uint8Array;\nvar code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nfor(var i = 0, len = code.length; i < len; ++i){\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n}\nrevLookup[\"-\".charCodeAt(0)] = 62;\nrevLookup[\"_\".charCodeAt(0)] = 63;\nfunction getLens(b64) {\n    var len = b64.length;\n    if (len % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    }\n    var validLen = b64.indexOf(\"=\");\n    if (validLen === -1) validLen = len;\n    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n    return [\n        validLen,\n        placeHoldersLen\n    ];\n}\nfunction byteLength(b64) {\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction _byteLength(_b64, validLen, placeHoldersLen) {\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction toByteArray(b64) {\n    var tmp;\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n    var curByte = 0;\n    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n    var i;\n    for(i = 0; i < len; i += 4){\n        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n        arr[curByte++] = tmp >> 16 & 255;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n    }\n    if (placeHoldersLen === 2) {\n        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[curByte++] = tmp & 255;\n    }\n    if (placeHoldersLen === 1) {\n        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n    }\n    return arr;\n}\nfunction tripletToBase64(num) {\n    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n}\nfunction encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for(var i = start; i < end; i += 3){\n        tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);\n        output.push(tripletToBase64(tmp));\n    }\n    return output.join(\"\");\n}\nfunction fromByteArray(uint8) {\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3;\n    var parts = [];\n    var maxChunkLength = 16383;\n    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength){\n        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    }\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\");\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\");\n    }\n    return parts.join(\"\");\n}\nfunction fromByteArrayUrlSafeNoPadding(uint8) {\n    return fromByteArray(uint8).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n} //# sourceMappingURL=base64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmFsdWVzL2Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWE7QUFDYixJQUFJQSxTQUFTLEVBQUU7QUFDZixJQUFJQyxZQUFZLEVBQUU7QUFDbEIsSUFBSUMsTUFBTUM7QUFDVixJQUFJQyxPQUFPO0FBQ1gsSUFBSyxJQUFJQyxJQUFJLEdBQUdDLE1BQU1GLEtBQUtHLE1BQU0sRUFBRUYsSUFBSUMsS0FBSyxFQUFFRCxFQUFHO0lBQy9DTCxNQUFNLENBQUNLLEVBQUUsR0FBR0QsSUFBSSxDQUFDQyxFQUFFO0lBQ25CSixTQUFTLENBQUNHLEtBQUtJLFVBQVUsQ0FBQ0gsR0FBRyxHQUFHQTtBQUNsQztBQUNBSixTQUFTLENBQUMsSUFBSU8sVUFBVSxDQUFDLEdBQUcsR0FBRztBQUMvQlAsU0FBUyxDQUFDLElBQUlPLFVBQVUsQ0FBQyxHQUFHLEdBQUc7QUFDL0IsU0FBU0MsUUFBUUMsR0FBRztJQUNsQixJQUFJSixNQUFNSSxJQUFJSCxNQUFNO0lBQ3BCLElBQUlELE1BQU0sSUFBSSxHQUFHO1FBQ2YsTUFBTSxJQUFJSyxNQUFNO0lBQ2xCO0lBQ0EsSUFBSUMsV0FBV0YsSUFBSUcsT0FBTyxDQUFDO0lBQzNCLElBQUlELGFBQWEsQ0FBQyxHQUFHQSxXQUFXTjtJQUNoQyxJQUFJUSxrQkFBa0JGLGFBQWFOLE1BQU0sSUFBSSxJQUFJTSxXQUFXO0lBQzVELE9BQU87UUFBQ0E7UUFBVUU7S0FBZ0I7QUFDcEM7QUFDTyxTQUFTQyxXQUFXTCxHQUFHO0lBQzVCLElBQUlNLE9BQU9QLFFBQVFDO0lBQ25CLElBQUlFLFdBQVdJLElBQUksQ0FBQyxFQUFFO0lBQ3RCLElBQUlGLGtCQUFrQkUsSUFBSSxDQUFDLEVBQUU7SUFDN0IsT0FBTyxDQUFDSixXQUFXRSxlQUFjLElBQUssSUFBSSxJQUFJQTtBQUNoRDtBQUNBLFNBQVNHLFlBQVlDLElBQUksRUFBRU4sUUFBUSxFQUFF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L0IsS0FBSzhCLGVBQWdCO1FBQ3RFRCxNQUFNSixJQUFJLENBQ1JMLFlBQ0VDLE9BQ0FyQixHQUNBQSxJQUFJOEIsaUJBQWlCQyxPQUFPQSxPQUFPL0IsSUFBSThCO0lBRzdDO0lBQ0EsSUFBSUYsZUFBZSxHQUFHO1FBQ3BCYixNQUFNTSxLQUFLLENBQUNwQixNQUFNLEVBQUU7UUFDcEI0QixNQUFNSixJQUFJLENBQUM5QixNQUFNLENBQUNvQixPQUFPLEVBQUUsR0FBR3BCLE1BQU0sQ0FBQ29CLE9BQU8sSUFBSSxHQUFHLEdBQUc7SUFDeEQsT0FBTyxJQUFJYSxlQUFlLEdBQUc7UUFDM0JiLE1BQU0sQ0FBQ00sS0FBSyxDQUFDcEIsTUFBTSxFQUFFLElBQUksS0FBS29CLEtBQUssQ0FBQ3BCLE1BQU0sRUFBRTtRQUM1QzRCLE1BQU1KLElBQUksQ0FDUjlCLE1BQU0sQ0FBQ29CLE9BQU8sR0FBRyxHQUFHcEIsTUFBTSxDQUFDb0IsT0FBTyxJQUFJLEdBQUcsR0FBR3BCLE1BQU0sQ0FBQ29CLE9BQU8sSUFBSSxHQUFHLEdBQUc7SUFFeEU7SUFDQSxPQUFPYyxNQUFNSCxJQUFJLENBQUM7QUFDcEI7QUFDTyxTQUFTTSw4QkFBOEJYLEtBQUs7SUFDakQsT0FBT00sY0FBY04sT0FBT1ksT0FBTyxDQUFDLE9BQU8sS0FBS0EsT0FBTyxDQUFDLE9BQU8sS0FBS0EsT0FBTyxDQUFDLE1BQU07QUFDcEYsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS92YWx1ZXMvYmFzZTY0LmpzP2QzZGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbG9va3VwID0gW107XG52YXIgcmV2TG9va3VwID0gW107XG52YXIgQXJyID0gVWludDhBcnJheTtcbnZhciBjb2RlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldO1xuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7XG59XG5yZXZMb29rdXBbXCItXCIuY2hhckNvZGVBdCgwKV0gPSA2MjtcbnJldkxvb2t1cFtcIl9cIi5jaGFyQ29kZUF0KDApXSA9IDYzO1xuZnVuY3Rpb24gZ2V0TGVucyhiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGg7XG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDRcIik7XG4gIH1cbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoXCI9XCIpO1xuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlbjtcbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW4gPyAwIDogNCAtIHZhbGlkTGVuICUgNDtcbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlTGVuZ3RoKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KTtcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXTtcbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV07XG4gIHJldHVybiAodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQgLSBwbGFjZUhvbGRlcnNMZW47XG59XG5mdW5jdGlvbiBfYnl0ZUxlbmd0aChfYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQgLSBwbGFjZUhvbGRlcnNMZW47XG59XG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlQXJyYXkoYjY0KSB7XG4gIHZhciB0bXA7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpO1xuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdO1xuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXTtcbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSk7XG4gIHZhciBjdXJCeXRlID0gMDtcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDAgPyB2YWxpZExlbiAtIDQgOiB2YWxpZExlbjtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTggfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXTtcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiAxNiAmIDI1NTtcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiA4ICYgMjU1O1xuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1O1xuICB9XG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0O1xuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1O1xuICB9XG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDI7XG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gOCAmIDI1NTtcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDI1NTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDYzXSArIGxvb2t1cFtudW0gPj4gMTIgJiA2M10gKyBsb29rdXBbbnVtID4+IDYgJiA2M10gKyBsb29rdXBbbnVtICYgNjNdO1xufVxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcDtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNiAmIDE2NzExNjgwKSArICh1aW50OFtpICsgMV0gPDwgOCAmIDY1MjgwKSArICh1aW50OFtpICsgMl0gJiAyNTUpO1xuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSh1aW50OCkge1xuICB2YXIgdG1wO1xuICB2YXIgbGVuID0gdWludDgubGVuZ3RoO1xuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDM7XG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goXG4gICAgICBlbmNvZGVDaHVuayhcbiAgICAgICAgdWludDgsXG4gICAgICAgIGksXG4gICAgICAgIGkgKyBtYXhDaHVua0xlbmd0aCA+IGxlbjIgPyBsZW4yIDogaSArIG1heENodW5rTGVuZ3RoXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdO1xuICAgIHBhcnRzLnB1c2gobG9va3VwW3RtcCA+PiAyXSArIGxvb2t1cFt0bXAgPDwgNCAmIDYzXSArIFwiPT1cIik7XG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdO1xuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArIGxvb2t1cFt0bXAgPj4gNCAmIDYzXSArIGxvb2t1cFt0bXAgPDwgMiAmIDYzXSArIFwiPVwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQnl0ZUFycmF5VXJsU2FmZU5vUGFkZGluZyh1aW50OCkge1xuICByZXR1cm4gZnJvbUJ5dGVBcnJheSh1aW50OCkucmVwbGFjZSgvXFwrL2csIFwiLVwiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoLz0vZywgXCJcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuanMubWFwXG4iXSwibmFtZXMiOlsibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiVWludDhBcnJheSIsImNvZGUiLCJpIiwibGVuIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsImdldExlbnMiLCJiNjQiLCJFcnJvciIsInZhbGlkTGVuIiwiaW5kZXhPZiIsInBsYWNlSG9sZGVyc0xlbiIsImJ5dGVMZW5ndGgiLCJsZW5zIiwiX2J5dGVMZW5ndGgiLCJfYjY0IiwidG9CeXRlQXJyYXkiLCJ0bXAiLCJhcnIiLCJjdXJCeXRlIiwidHJpcGxldFRvQmFzZTY0IiwibnVtIiwiZW5jb2RlQ2h1bmsiLCJ1aW50OCIsInN0YXJ0IiwiZW5kIiwib3V0cHV0IiwicHVzaCIsImpvaW4iLCJmcm9tQnl0ZUFycmF5IiwiZXh0cmFCeXRlcyIsInBhcnRzIiwibWF4Q2h1bmtMZW5ndGgiLCJsZW4yIiwiZnJvbUJ5dGVBcnJheVVybFNhZmVOb1BhZGRpbmciLCJyZXBsYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/values/base64.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/values/compare.js":
/*!********************************************************!*\
  !*** ./node_modules/convex/dist/esm/values/compare.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compareValues: function() { return /* binding */ compareValues; }\n/* harmony export */ });\n/* harmony import */ var _compare_utf8_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compare_utf8.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/compare_utf8.js\");\n\n\nfunction compareValues(k1, k2) {\n    return compareAsTuples(makeComparable(k1), makeComparable(k2));\n}\nfunction compareAsTuples(a, b) {\n    if (a[0] === b[0]) {\n        return compareSameTypeValues(a[1], b[1]);\n    } else if (a[0] < b[0]) {\n        return -1;\n    }\n    return 1;\n}\nfunction compareSameTypeValues(v1, v2) {\n    if (v1 === void 0 || v1 === null) {\n        return 0;\n    }\n    if (typeof v1 === \"number\") {\n        if (typeof v2 !== \"number\") {\n            throw new Error(\"Unexpected type \".concat(v2));\n        }\n        return compareNumbers(v1, v2);\n    }\n    if (typeof v1 === \"string\") {\n        if (typeof v2 !== \"string\") {\n            throw new Error(\"Unexpected type \".concat(v2));\n        }\n        return (0,_compare_utf8_js__WEBPACK_IMPORTED_MODULE_0__.compareUTF8)(v1, v2);\n    }\n    if (typeof v1 === \"bigint\" || typeof v1 === \"boolean\" || typeof v1 === \"string\") {\n        return v1 < v2 ? -1 : v1 === v2 ? 0 : 1;\n    }\n    if (!Array.isArray(v1) || !Array.isArray(v2)) {\n        throw new Error(\"Unexpected type \".concat(v1));\n    }\n    for(let i = 0; i < v1.length && i < v2.length; i++){\n        const cmp = compareAsTuples(v1[i], v2[i]);\n        if (cmp !== 0) {\n            return cmp;\n        }\n    }\n    if (v1.length < v2.length) {\n        return -1;\n    }\n    if (v1.length > v2.length) {\n        return 1;\n    }\n    return 0;\n}\nfunction compareNumbers(v1, v2) {\n    if (isNaN(v1) || isNaN(v2)) {\n        const buffer1 = new ArrayBuffer(8);\n        const buffer2 = new ArrayBuffer(8);\n        new DataView(buffer1).setFloat64(0, v1, /* little-endian */ true);\n        new DataView(buffer2).setFloat64(0, v2, /* little-endian */ true);\n        const v1Bits = BigInt(new DataView(buffer1).getBigInt64(0, /* little-endian */ true));\n        const v2Bits = BigInt(new DataView(buffer2).getBigInt64(0, /* little-endian */ true));\n        const v1Sign = (v1Bits & 0x8000000000000000n) !== 0n;\n        const v2Sign = (v2Bits & 0x8000000000000000n) !== 0n;\n        if (isNaN(v1) !== isNaN(v2)) {\n            if (isNaN(v1)) {\n                return v1Sign ? -1 : 1;\n            }\n            return v2Sign ? 1 : -1;\n        }\n        if (v1Sign !== v2Sign) {\n            return v1Sign ? -1 : 1;\n        }\n        return v1Bits < v2Bits ? -1 : v1Bits === v2Bits ? 0 : 1;\n    }\n    if (Object.is(v1, v2)) {\n        return 0;\n    }\n    if (Object.is(v1, -0)) {\n        return Object.is(v2, 0) ? -1 : -Math.sign(v2);\n    }\n    if (Object.is(v2, -0)) {\n        return Object.is(v1, 0) ? 1 : Math.sign(v1);\n    }\n    return v1 < v2 ? -1 : 1;\n}\nfunction makeComparable(v) {\n    if (v === void 0) {\n        return [\n            0,\n            void 0\n        ];\n    }\n    if (v === null) {\n        return [\n            1,\n            null\n        ];\n    }\n    if (typeof v === \"bigint\") {\n        return [\n            2,\n            v\n        ];\n    }\n    if (typeof v === \"number\") {\n        return [\n            3,\n            v\n        ];\n    }\n    if (typeof v === \"boolean\") {\n        return [\n            4,\n            v\n        ];\n    }\n    if (typeof v === \"string\") {\n        return [\n            5,\n            v\n        ];\n    }\n    if (v instanceof ArrayBuffer) {\n        return [\n            6,\n            Array.from(new Uint8Array(v)).map(makeComparable)\n        ];\n    }\n    if (Array.isArray(v)) {\n        return [\n            7,\n            v.map(makeComparable)\n        ];\n    }\n    const keys = Object.keys(v).sort();\n    const pojo = keys.map((k)=>[\n            k,\n            v[k]\n        ]);\n    return [\n        8,\n        pojo.map(makeComparable)\n    ];\n} //# sourceMappingURL=compare.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmFsdWVzL2NvbXBhcmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBYTtBQUNtQztBQUN6QyxTQUFTQyxjQUFjQyxFQUFFLEVBQUVDLEVBQUU7SUFDbEMsT0FBT0MsZ0JBQWdCQyxlQUFlSCxLQUFLRyxlQUFlRjtBQUM1RDtBQUNBLFNBQVNDLGdCQUFnQkUsQ0FBQyxFQUFFQyxDQUFDO0lBQzNCLElBQUlELENBQUMsQ0FBQyxFQUFFLEtBQUtDLENBQUMsQ0FBQyxFQUFFLEVBQUU7UUFDakIsT0FBT0Msc0JBQXNCRixDQUFDLENBQUMsRUFBRSxFQUFFQyxDQUFDLENBQUMsRUFBRTtJQUN6QyxPQUFPLElBQUlELENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEVBQUU7UUFDdEIsT0FBTyxDQUFDO0lBQ1Y7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxTQUFTQyxzQkFBc0JDLEVBQUUsRUFBRUMsRUFBRTtJQUNuQyxJQUFJRCxPQUFPLEtBQUssS0FBS0EsT0FBTyxNQUFNO1FBQ2hDLE9BQU87SUFDVDtJQUNBLElBQUksT0FBT0EsT0FBTyxVQUFVO1FBQzFCLElBQUksT0FBT0MsT0FBTyxVQUFVO1lBQzFCLE1BQU0sSUFBSUMsTUFBTSxtQkFBc0IsT0FBSEQ7UUFDckM7UUFDQSxPQUFPRSxlQUFlSCxJQUFJQztJQUM1QjtJQUNBLElBQUksT0FBT0QsT0FBTyxVQUFVO1FBQzFCLElBQUksT0FBT0MsT0FBTyxVQUFVO1lBQzFCLE1BQU0sSUFBSUMsTUFBTSxtQkFBc0IsT0FBSEQ7UUFDckM7UUFDQSxPQUFPViw2REFBV0EsQ0FBQ1MsSUFBSUM7SUFDekI7SUFDQSxJQUFJLE9BQU9ELE9BQU8sWUFBWSxPQUFPQSxPQUFPLGFBQWEsT0FBT0EsT0FBTyxVQUFVO1FBQy9FLE9BQU9BLEtBQUtDLEtBQUssQ0FBQyxJQUFJRCxPQUFPQyxLQUFLLElBQUk7SUFDeEM7SUFDQSxJQUFJ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VTtRQUN6QixPQUFPO1lBQUM7WUFBR0E7U0FBRTtJQUNmO0lBQ0EsSUFBSUEsYUFBYWQsYUFBYTtRQUM1QixPQUFPO1lBQUM7WUFBR1AsTUFBTXNCLElBQUksQ0FBQyxJQUFJQyxXQUFXRixJQUFJRyxHQUFHLENBQUNoQztTQUFnQjtJQUMvRDtJQUNBLElBQUlRLE1BQU1DLE9BQU8sQ0FBQ29CLElBQUk7UUFDcEIsT0FBTztZQUFDO1lBQUdBLEVBQUVHLEdBQUcsQ0FBQ2hDO1NBQWdCO0lBQ25DO0lBQ0EsTUFBTWlDLE9BQU9SLE9BQU9RLElBQUksQ0FBQ0osR0FBR0ssSUFBSTtJQUNoQyxNQUFNQyxPQUFPRixLQUFLRCxHQUFHLENBQUMsQ0FBQ0ksSUFBTTtZQUFDQTtZQUFHUCxDQUFDLENBQUNPLEVBQUU7U0FBQztJQUN0QyxPQUFPO1FBQUM7UUFBR0QsS0FBS0gsR0FBRyxDQUFDaEM7S0FBZ0I7QUFDdEMsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS92YWx1ZXMvY29tcGFyZS5qcz9iZjYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgY29tcGFyZVVURjggfSBmcm9tIFwiLi9jb21wYXJlX3V0ZjguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlVmFsdWVzKGsxLCBrMikge1xuICByZXR1cm4gY29tcGFyZUFzVHVwbGVzKG1ha2VDb21wYXJhYmxlKGsxKSwgbWFrZUNvbXBhcmFibGUoazIpKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVBc1R1cGxlcyhhLCBiKSB7XG4gIGlmIChhWzBdID09PSBiWzBdKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVTYW1lVHlwZVZhbHVlcyhhWzFdLCBiWzFdKTtcbiAgfSBlbHNlIGlmIChhWzBdIDwgYlswXSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVTYW1lVHlwZVZhbHVlcyh2MSwgdjIpIHtcbiAgaWYgKHYxID09PSB2b2lkIDAgfHwgdjEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAodHlwZW9mIHYxID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKHR5cGVvZiB2MiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHR5cGUgJHt2Mn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBhcmVOdW1iZXJzKHYxLCB2Mik7XG4gIH1cbiAgaWYgKHR5cGVvZiB2MSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmICh0eXBlb2YgdjIgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB0eXBlICR7djJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wYXJlVVRGOCh2MSwgdjIpO1xuICB9XG4gIGlmICh0eXBlb2YgdjEgPT09IFwiYmlnaW50XCIgfHwgdHlwZW9mIHYxID09PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgdjEgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdjEgPCB2MiA/IC0xIDogdjEgPT09IHYyID8gMCA6IDE7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCAhQXJyYXkuaXNBcnJheSh2MikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSAke3YxfWApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdjEubGVuZ3RoICYmIGkgPCB2Mi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNtcCA9IGNvbXBhcmVBc1R1cGxlcyh2MVtpXSwgdjJbaV0pO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICB9XG4gIGlmICh2MS5sZW5ndGggPCB2Mi5sZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHYxLmxlbmd0aCA+IHYyLmxlbmd0aCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gY29tcGFyZU51bWJlcnModjEsIHYyKSB7XG4gIGlmIChpc05hTih2MSkgfHwgaXNOYU4odjIpKSB7XG4gICAgY29uc3QgYnVmZmVyMSA9IG5ldyBBcnJheUJ1ZmZlcig4KTtcbiAgICBjb25zdCBidWZmZXIyID0gbmV3IEFycmF5QnVmZmVyKDgpO1xuICAgIG5ldyBEYXRhVmlldyhidWZmZXIxKS5zZXRGbG9hdDY0KFxuICAgICAgMCxcbiAgICAgIHYxLFxuICAgICAgLyogbGl0dGxlLWVuZGlhbiAqL1xuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgbmV3IERhdGFWaWV3KGJ1ZmZlcjIpLnNldEZsb2F0NjQoXG4gICAgICAwLFxuICAgICAgdjIsXG4gICAgICAvKiBsaXR0bGUtZW5kaWFuICovXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBjb25zdCB2MUJpdHMgPSBCaWdJbnQoXG4gICAgICBuZXcgRGF0YVZpZXcoYnVmZmVyMSkuZ2V0QmlnSW50NjQoXG4gICAgICAgIDAsXG4gICAgICAgIC8qIGxpdHRsZS1lbmRpYW4gKi9cbiAgICAgICAgdHJ1ZVxuICAgICAgKVxuICAgICk7XG4gICAgY29uc3QgdjJCaXRzID0gQmlnSW50KFxuICAgICAgbmV3IERhdGFWaWV3KGJ1ZmZlcjIpLmdldEJpZ0ludDY0KFxuICAgICAgICAwLFxuICAgICAgICAvKiBsaXR0bGUtZW5kaWFuICovXG4gICAgICAgIHRydWVcbiAgICAgIClcbiAgICApO1xuICAgIGNvbnN0IHYxU2lnbiA9ICh2MUJpdHMgJiAweDgwMDAwMDAwMDAwMDAwMDBuKSAhPT0gMG47XG4gICAgY29uc3QgdjJTaWduID0gKHYyQml0cyAmIDB4ODAwMDAwMDAwMDAwMDAwMG4pICE9PSAwbjtcbiAgICBpZiAoaXNOYU4odjEpICE9PSBpc05hTih2MikpIHtcbiAgICAgIGlmIChpc05hTih2MSkpIHtcbiAgICAgICAgcmV0dXJuIHYxU2lnbiA/IC0xIDogMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2MlNpZ24gPyAxIDogLTE7XG4gICAgfVxuICAgIGlmICh2MVNpZ24gIT09IHYyU2lnbikge1xuICAgICAgcmV0dXJuIHYxU2lnbiA/IC0xIDogMTtcbiAgICB9XG4gICAgcmV0dXJuIHYxQml0cyA8IHYyQml0cyA/IC0xIDogdjFCaXRzID09PSB2MkJpdHMgPyAwIDogMTtcbiAgfVxuICBpZiAoT2JqZWN0LmlzKHYxLCB2MikpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoT2JqZWN0LmlzKHYxLCAtMCkpIHtcbiAgICByZXR1cm4gT2JqZWN0LmlzKHYyLCAwKSA/IC0xIDogLU1hdGguc2lnbih2Mik7XG4gIH1cbiAgaWYgKE9iamVjdC5pcyh2MiwgLTApKSB7XG4gICAgcmV0dXJuIE9iamVjdC5pcyh2MSwgMCkgPyAxIDogTWF0aC5zaWduKHYxKTtcbiAgfVxuICByZXR1cm4gdjEgPCB2MiA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIG1ha2VDb21wYXJhYmxlKHYpIHtcbiAgaWYgKHYgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBbMCwgdm9pZCAwXTtcbiAgfVxuICBpZiAodiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbMSwgbnVsbF07XG4gIH1cbiAgaWYgKHR5cGVvZiB2ID09PSBcImJpZ2ludFwiKSB7XG4gICAgcmV0dXJuIFsyLCB2XTtcbiAgfVxuICBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gWzMsIHZdO1xuICB9XG4gIGlmICh0eXBlb2YgdiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gWzQsIHZdO1xuICB9XG4gIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBbNSwgdl07XG4gIH1cbiAgaWYgKHYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBbNiwgQXJyYXkuZnJvbShuZXcgVWludDhBcnJheSh2KSkubWFwKG1ha2VDb21wYXJhYmxlKV07XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICByZXR1cm4gWzcsIHYubWFwKG1ha2VDb21wYXJhYmxlKV07XG4gIH1cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHYpLnNvcnQoKTtcbiAgY29uc3QgcG9qbyA9IGtleXMubWFwKChrKSA9PiBbaywgdltrXV0pO1xuICByZXR1cm4gWzgsIHBvam8ubWFwKG1ha2VDb21wYXJhYmxlKV07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wYXJlLmpzLm1hcFxuIl0sIm5hbWVzIjpbImNvbXBhcmVVVEY4IiwiY29tcGFyZVZhbHVlcyIsImsxIiwiazIiLCJjb21wYXJlQXNUdXBsZXMiLCJtYWtlQ29tcGFyYWJsZSIsImEiLCJiIiwiY29tcGFyZVNhbWVUeXBlVmFsdWVzIiwidjEiLCJ2MiIsIkVycm9yIiwiY29tcGFyZU51bWJlcnMiLCJBcnJheSIsImlzQXJyYXkiLCJpIiwibGVuZ3RoIiwiY21wIiwiaXNOYU4iLCJidWZmZXIxIiwiQXJyYXlCdWZmZXIiLCJidWZmZXIyIiwiRGF0YVZpZXciLCJzZXRGbG9hdDY0IiwidjFCaXRzIiwiQmlnSW50IiwiZ2V0QmlnSW50NjQiLCJ2MkJpdHMiLCJ2MVNpZ24iLCJ2MlNpZ24iLCJPYmplY3QiLCJpcyIsIk1hdGgiLCJzaWduIiwidiIsImZyb20iLCJVaW50OEFycmF5IiwibWFwIiwia2V5cyIsInNvcnQiLCJwb2pvIiwiayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/values/compare.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/values/compare_utf8.js":
/*!*************************************************************!*\
  !*** ./node_modules/convex/dist/esm/values/compare_utf8.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compareUTF8: function() { return /* binding */ compareUTF8; },\n/* harmony export */   greaterThan: function() { return /* binding */ greaterThan; },\n/* harmony export */   greaterThanEq: function() { return /* binding */ greaterThanEq; },\n/* harmony export */   lessThan: function() { return /* binding */ lessThan; },\n/* harmony export */   lessThanEq: function() { return /* binding */ lessThanEq; },\n/* harmony export */   utf16LengthForCodePoint: function() { return /* binding */ utf16LengthForCodePoint; }\n/* harmony export */ });\n\nfunction compareUTF8(a, b) {\n    const aLength = a.length;\n    const bLength = b.length;\n    const length = Math.min(aLength, bLength);\n    for(let i = 0; i < length;){\n        const aCodePoint = a.codePointAt(i);\n        const bCodePoint = b.codePointAt(i);\n        if (aCodePoint !== bCodePoint) {\n            if (aCodePoint < 128 && bCodePoint < 128) {\n                return aCodePoint - bCodePoint;\n            }\n            const aLength2 = utf8Bytes(aCodePoint, aBytes);\n            const bLength2 = utf8Bytes(bCodePoint, bBytes);\n            return compareArrays(aBytes, aLength2, bBytes, bLength2);\n        }\n        i += utf16LengthForCodePoint(aCodePoint);\n    }\n    return aLength - bLength;\n}\nfunction compareArrays(a, aLength, b, bLength) {\n    const length = Math.min(aLength, bLength);\n    for(let i = 0; i < length; i++){\n        const aValue = a[i];\n        const bValue = b[i];\n        if (aValue !== bValue) {\n            return aValue - bValue;\n        }\n    }\n    return aLength - bLength;\n}\nfunction utf16LengthForCodePoint(aCodePoint) {\n    return aCodePoint > 65535 ? 2 : 1;\n}\nconst arr = ()=>Array.from({\n        length: 4\n    }, ()=>0);\nconst aBytes = arr();\nconst bBytes = arr();\nfunction utf8Bytes(codePoint, bytes) {\n    if (codePoint < 128) {\n        bytes[0] = codePoint;\n        return 1;\n    }\n    let count;\n    let offset;\n    if (codePoint <= 2047) {\n        count = 1;\n        offset = 192;\n    } else if (codePoint <= 65535) {\n        count = 2;\n        offset = 224;\n    } else if (codePoint <= 1114111) {\n        count = 3;\n        offset = 240;\n    } else {\n        throw new Error(\"Invalid code point\");\n    }\n    bytes[0] = (codePoint >> 6 * count) + offset;\n    let i = 1;\n    for(; count > 0; count--){\n        const temp = codePoint >> 6 * (count - 1);\n        bytes[i++] = 128 | temp & 63;\n    }\n    return i;\n}\nfunction greaterThan(a, b) {\n    return compareUTF8(a, b) > 0;\n}\nfunction greaterThanEq(a, b) {\n    return compareUTF8(a, b) >= 0;\n}\nfunction lessThan(a, b) {\n    return compareUTF8(a, b) < 0;\n}\nfunction lessThanEq(a, b) {\n    return compareUTF8(a, b) <= 0;\n} //# sourceMappingURL=compare_utf8.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmFsdWVzL2NvbXBhcmVfdXRmOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNOLFNBQVNBLFlBQVlDLENBQUMsRUFBRUMsQ0FBQztJQUM5QixNQUFNQyxVQUFVRixFQUFFRyxNQUFNO0lBQ3hCLE1BQU1DLFVBQVVILEVBQUVFLE1BQU07SUFDeEIsTUFBTUEsU0FBU0UsS0FBS0MsR0FBRyxDQUFDSixTQUFTRTtJQUNqQyxJQUFLLElBQUlHLElBQUksR0FBR0EsSUFBSUosUUFBVTtRQUM1QixNQUFNSyxhQUFhUixFQUFFUyxXQUFXLENBQUNGO1FBQ2pDLE1BQU1HLGFBQWFULEVBQUVRLFdBQVcsQ0FBQ0Y7UUFDakMsSUFBSUMsZUFBZUUsWUFBWTtZQUM3QixJQUFJRixhQUFhLE9BQU9FLGFBQWEsS0FBSztnQkFDeEMsT0FBT0YsYUFBYUU7WUFDdEI7WUFDQSxNQUFNQyxXQUFXQyxVQUFVSixZQUFZSztZQUN2QyxNQUFNQyxXQUFXRixVQUFVRixZQUFZSztZQUN2QyxPQUFPQyxjQUFjSCxRQUFRRixVQUFVSSxRQUFRRDtRQUNqRDtRQUNBUCxLQUFLVSx3QkFBd0JUO0lBQy9CO0lBQ0EsT0FBT04sVUFBVUU7QUFDbkI7QUFDQSxTQUFTWSxjQUFjaEIsQ0FBQyxFQUFFRSxPQUFPLEVBQUVELENBQUMsRUFBRUcsT0FBTztJQUMzQyxNQUFNRCxTQUFTRSxLQUFLQyxHQUFHLENBQUNKLFNBQVNFO0lBQ2pDLElBQUssSUFBSUcsSUFBSSxHQUFHQSxJQUFJSixRQUFRSSxJQUFLO1FBQy9CLE1BQU1XLFNBQVNsQixDQUFDLENBQUNPLEVBQUU7UUFDbkIsTUFBTVksU0FBU2xCLENBQUMsQ0FBQ00sRUFBRTtRQUNuQixJQUFJVyxXQUFXQyxRQUFRO1lBQ3JCLE9BQU9ELFNBQVNDO1FBQ2xCO0lBQ0Y7SUFDQSxPQUFPakIsVUFBVUU7QUFDbkI7QUFDTyxTQUFTYSx3QkFBd0JULFVBQVU7SUFDaEQsT0FBT0EsYUFBYSxRQUFRLElBQUk7QUFDbEM7QUFDQSxNQUFNWSxNQUFNLElBQU1DLE1BQU1DLElBQUksQ0FBQztRQUFFbkIsUUFBUTtJQUFFLEdBQUcsSUFBTTtBQUNsRCxNQUFNVSxTQUFTTztBQUNmLE1BQU1MLFNBQVNLO0FBQ2YsU0FBU1IsVUFBVVcsU0FBUyxFQUFFQyxLQUFLO0lBQ2pDLElBQUlELFlBQVksS0FBSztRQUNuQkMsS0FBSyxDQUFDLEVBQUUsR0FBR0Q7UUFDWCxPQUFPO0lBQ1Q7SUFDQSxJQUFJRTtJQUNKLElBQUlDO0lBQ0osSUFBSUgsYUFBYSxNQUFNO1FBQ3JCRSxRQUFRO1FBQ1JDLFNBQVM7SUFDWCxPQUFPLElBQUlILGFBQWEsT0FBTztRQUM3QkUsUUFBUTtRQUNSQyxTQUFTO0lBQ1gsT0FBTyxJQUFJSCxhQUFhLFNBQVM7UUFDL0JFLFFBQVE7UUFDUkMsU0FBUztJQUNYLE9BQU87UUFDTCxNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFDQUgsS0FBSyxDQUFDLEVBQUUsR0FBRyxDQUFDRCxhQUFhLElBQUlFLEtBQUksSUFBS0M7SUFDdEMsSUFBSW5CLElBQUk7SUFDUixNQUFPa0IsUUFBUSxHQUFHQSxRQUFTO1FBQ3pCLE1BQU1HLE9BQU9MLGFBQWEsSUFBS0UsQ0FBQUEsUUFBUTtRQUN2Q0QsS0FBSyxDQUFDakIsSUFBSSxHQUFHLE1BQU1xQixPQUFPO0lBQzVCO0lBQ0EsT0FBT3JCO0FBQ1Q7QUFDTyxTQUFTc0IsWUFBWTdCLENBQUMsRUFBRUMsQ0FBQztJQUM5QixPQUFPRixZQUFZQyxHQUFHQyxLQUFLO0FBQzdCO0FBQ08sU0FBUzZCLGNBQWM5QixDQUFDLEVBQUVDLENBQUM7SUFDaEMsT0FBT0YsWUFBWUMsR0FBR0MsTUFBTTtBQUM5QjtBQUNPLFNBQVM4QixTQUFTL0IsQ0FBQyxFQUFFQyxDQUFDO0lBQzNCLE9BQU9GLFlBQVlDLEdBQUdDLEtBQUs7QUFDN0I7QUFDTyxTQUFTK0IsV0FBV2hDLENBQUMsRUFBRUMsQ0FBQztJQUM3QixPQUFPRixZQUFZQyxHQUFHQyxNQUFNO0FBQzlCLEVBQ0Esd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmFsdWVzL2NvbXBhcmVfdXRmOC5qcz8xNjUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVVVEY4KGEsIGIpIHtcbiAgY29uc3QgYUxlbmd0aCA9IGEubGVuZ3RoO1xuICBjb25zdCBiTGVuZ3RoID0gYi5sZW5ndGg7XG4gIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKGFMZW5ndGgsIGJMZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKSB7XG4gICAgY29uc3QgYUNvZGVQb2ludCA9IGEuY29kZVBvaW50QXQoaSk7XG4gICAgY29uc3QgYkNvZGVQb2ludCA9IGIuY29kZVBvaW50QXQoaSk7XG4gICAgaWYgKGFDb2RlUG9pbnQgIT09IGJDb2RlUG9pbnQpIHtcbiAgICAgIGlmIChhQ29kZVBvaW50IDwgMTI4ICYmIGJDb2RlUG9pbnQgPCAxMjgpIHtcbiAgICAgICAgcmV0dXJuIGFDb2RlUG9pbnQgLSBiQ29kZVBvaW50O1xuICAgICAgfVxuICAgICAgY29uc3QgYUxlbmd0aDIgPSB1dGY4Qnl0ZXMoYUNvZGVQb2ludCwgYUJ5dGVzKTtcbiAgICAgIGNvbnN0IGJMZW5ndGgyID0gdXRmOEJ5dGVzKGJDb2RlUG9pbnQsIGJCeXRlcyk7XG4gICAgICByZXR1cm4gY29tcGFyZUFycmF5cyhhQnl0ZXMsIGFMZW5ndGgyLCBiQnl0ZXMsIGJMZW5ndGgyKTtcbiAgICB9XG4gICAgaSArPSB1dGYxNkxlbmd0aEZvckNvZGVQb2ludChhQ29kZVBvaW50KTtcbiAgfVxuICByZXR1cm4gYUxlbmd0aCAtIGJMZW5ndGg7XG59XG5mdW5jdGlvbiBjb21wYXJlQXJyYXlzKGEsIGFMZW5ndGgsIGIsIGJMZW5ndGgpIHtcbiAgY29uc3QgbGVuZ3RoID0gTWF0aC5taW4oYUxlbmd0aCwgYkxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhVmFsdWUgPSBhW2ldO1xuICAgIGNvbnN0IGJWYWx1ZSA9IGJbaV07XG4gICAgaWYgKGFWYWx1ZSAhPT0gYlZhbHVlKSB7XG4gICAgICByZXR1cm4gYVZhbHVlIC0gYlZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYUxlbmd0aCAtIGJMZW5ndGg7XG59XG5leHBvcnQgZnVuY3Rpb24gdXRmMTZMZW5ndGhGb3JDb2RlUG9pbnQoYUNvZGVQb2ludCkge1xuICByZXR1cm4gYUNvZGVQb2ludCA+IDY1NTM1ID8gMiA6IDE7XG59XG5jb25zdCBhcnIgPSAoKSA9PiBBcnJheS5mcm9tKHsgbGVuZ3RoOiA0IH0sICgpID0+IDApO1xuY29uc3QgYUJ5dGVzID0gYXJyKCk7XG5jb25zdCBiQnl0ZXMgPSBhcnIoKTtcbmZ1bmN0aW9uIHV0ZjhCeXRlcyhjb2RlUG9pbnQsIGJ5dGVzKSB7XG4gIGlmIChjb2RlUG9pbnQgPCAxMjgpIHtcbiAgICBieXRlc1swXSA9IGNvZGVQb2ludDtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBsZXQgY291bnQ7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChjb2RlUG9pbnQgPD0gMjA0Nykge1xuICAgIGNvdW50ID0gMTtcbiAgICBvZmZzZXQgPSAxOTI7XG4gIH0gZWxzZSBpZiAoY29kZVBvaW50IDw9IDY1NTM1KSB7XG4gICAgY291bnQgPSAyO1xuICAgIG9mZnNldCA9IDIyNDtcbiAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPD0gMTExNDExMSkge1xuICAgIGNvdW50ID0gMztcbiAgICBvZmZzZXQgPSAyNDA7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50XCIpO1xuICB9XG4gIGJ5dGVzWzBdID0gKGNvZGVQb2ludCA+PiA2ICogY291bnQpICsgb2Zmc2V0O1xuICBsZXQgaSA9IDE7XG4gIGZvciAoOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICBjb25zdCB0ZW1wID0gY29kZVBvaW50ID4+IDYgKiAoY291bnQgLSAxKTtcbiAgICBieXRlc1tpKytdID0gMTI4IHwgdGVtcCAmIDYzO1xuICB9XG4gIHJldHVybiBpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmVVVEY4KGEsIGIpID4gMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBncmVhdGVyVGhhbkVxKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmVVVEY4KGEsIGIpID49IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gbGVzc1RoYW4oYSwgYikge1xuICByZXR1cm4gY29tcGFyZVVURjgoYSwgYikgPCAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxlc3NUaGFuRXEoYSwgYikge1xuICByZXR1cm4gY29tcGFyZVVURjgoYSwgYikgPD0gMDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBhcmVfdXRmOC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjb21wYXJlVVRGOCIsImEiLCJiIiwiYUxlbmd0aCIsImxlbmd0aCIsImJMZW5ndGgiLCJNYXRoIiwibWluIiwiaSIsImFDb2RlUG9pbnQiLCJjb2RlUG9pbnRBdCIsImJDb2RlUG9pbnQiLCJhTGVuZ3RoMiIsInV0ZjhCeXRlcyIsImFCeXRlcyIsImJMZW5ndGgyIiwiYkJ5dGVzIiwiY29tcGFyZUFycmF5cyIsInV0ZjE2TGVuZ3RoRm9yQ29kZVBvaW50IiwiYVZhbHVlIiwiYlZhbHVlIiwiYXJyIiwiQXJyYXkiLCJmcm9tIiwiY29kZVBvaW50IiwiYnl0ZXMiLCJjb3VudCIsIm9mZnNldCIsIkVycm9yIiwidGVtcCIsImdyZWF0ZXJUaGFuIiwiZ3JlYXRlclRoYW5FcSIsImxlc3NUaGFuIiwibGVzc1RoYW5FcSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/values/compare_utf8.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/values/errors.js":
/*!*******************************************************!*\
  !*** ./node_modules/convex/dist/esm/values/errors.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConvexError: function() { return /* binding */ ConvexError; }\n/* harmony export */ });\n/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/value.js\");\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar _a, _b;\n\nconst IDENTIFYING_FIELD = Symbol.for(\"ConvexError\");\nclass ConvexError extends (_b = Error, _a = IDENTIFYING_FIELD, _b) {\n    constructor(data){\n        super(typeof data === \"string\" ? data : (0,_value_js__WEBPACK_IMPORTED_MODULE_0__.stringifyValueForError)(data));\n        __publicField(this, \"name\", \"ConvexError\");\n        __publicField(this, \"data\");\n        __publicField(this, _a, true);\n        this.data = data;\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmFsdWVzL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxrQkFBa0IsQ0FBQ0MsS0FBS0MsS0FBS0MsUUFBVUQsT0FBT0QsTUFBTUosVUFBVUksS0FBS0MsS0FBSztRQUFFRSxZQUFZO1FBQU1DLGNBQWM7UUFBTUMsVUFBVTtRQUFNSDtJQUFNLEtBQUtGLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztBQUMxSixJQUFJSSxnQkFBZ0IsQ0FBQ04sS0FBS0MsS0FBS0MsUUFBVUgsZ0JBQWdCQyxLQUFLLE9BQU9DLFFBQVEsV0FBV0EsTUFBTSxLQUFLQSxLQUFLQztBQUN4RyxJQUFJSyxJQUFJQztBQUM0QztBQUNwRCxNQUFNRSxvQkFBb0JDLE9BQU9DLEdBQUcsQ0FBQztBQUM5QixNQUFNQyxvQkFBcUJMLENBQUFBLEtBQUtNLE9BQU9QLEtBQUtHLG1CQUFtQkYsRUFBQztJQUNyRU8sWUFBWUMsSUFBSSxDQUFFO1FBQ2hCLEtBQUssQ0FBQyxPQUFPQSxTQUFTLFdBQVdBLE9BQU9QLGlFQUFzQkEsQ0FBQ087UUFDL0RWLGNBQWMsSUFBSSxFQUFFLFFBQVE7UUFDNUJBLGNBQWMsSUFBSSxFQUFFO1FBQ3BCQSxjQUFjLElBQUksRUFBRUMsSUFBSTtRQUN4QixJQUFJLENBQUNTLElBQUksR0FBR0E7SUFDZDtBQUNGLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmFsdWVzL2Vycm9ycy5qcz81OWQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbnZhciBfYSwgX2I7XG5pbXBvcnQgeyBzdHJpbmdpZnlWYWx1ZUZvckVycm9yIH0gZnJvbSBcIi4vdmFsdWUuanNcIjtcbmNvbnN0IElERU5USUZZSU5HX0ZJRUxEID0gU3ltYm9sLmZvcihcIkNvbnZleEVycm9yXCIpO1xuZXhwb3J0IGNsYXNzIENvbnZleEVycm9yIGV4dGVuZHMgKF9iID0gRXJyb3IsIF9hID0gSURFTlRJRllJTkdfRklFTEQsIF9iKSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcih0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGRhdGEgOiBzdHJpbmdpZnlWYWx1ZUZvckVycm9yKGRhdGEpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibmFtZVwiLCBcIkNvbnZleEVycm9yXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkYXRhXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgX2EsIHRydWUpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX19wdWJsaWNGaWVsZCIsIl9hIiwiX2IiLCJzdHJpbmdpZnlWYWx1ZUZvckVycm9yIiwiSURFTlRJRllJTkdfRklFTEQiLCJTeW1ib2wiLCJmb3IiLCJDb252ZXhFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJkYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/values/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/values/index.js":
/*!******************************************************!*\
  !*** ./node_modules/convex/dist/esm/values/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Base64: function() { return /* reexport module object */ _base64_js__WEBPACK_IMPORTED_MODULE_2__; },\n/* harmony export */   ConvexError: function() { return /* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.ConvexError; },\n/* harmony export */   asObjectValidator: function() { return /* reexport safe */ _validator_js__WEBPACK_IMPORTED_MODULE_1__.asObjectValidator; },\n/* harmony export */   compareValues: function() { return /* reexport safe */ _compare_js__WEBPACK_IMPORTED_MODULE_4__.compareValues; },\n/* harmony export */   convexToJson: function() { return /* reexport safe */ _value_js__WEBPACK_IMPORTED_MODULE_0__.convexToJson; },\n/* harmony export */   jsonToConvex: function() { return /* reexport safe */ _value_js__WEBPACK_IMPORTED_MODULE_0__.jsonToConvex; },\n/* harmony export */   v: function() { return /* reexport safe */ _validator_js__WEBPACK_IMPORTED_MODULE_1__.v; }\n/* harmony export */ });\n/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/value.js\");\n/* harmony import */ var _validator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./validator.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/validator.js\");\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base64.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/base64.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/errors.js\");\n/* harmony import */ var _compare_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./compare.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/compare.js\");\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmFsdWVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFhO0FBQzJDO0FBQ0Y7QUFDaEI7QUFDcEI7QUFDVTtBQUNpQixDQUM3QyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS92YWx1ZXMvaW5kZXguanM/NDA1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydCB7IGNvbnZleFRvSnNvbiwganNvblRvQ29udmV4IH0gZnJvbSBcIi4vdmFsdWUuanNcIjtcbmV4cG9ydCB7IHYsIGFzT2JqZWN0VmFsaWRhdG9yIH0gZnJvbSBcIi4vdmFsaWRhdG9yLmpzXCI7XG5pbXBvcnQgKiBhcyBCYXNlNjQgZnJvbSBcIi4vYmFzZTY0LmpzXCI7XG5leHBvcnQgeyBCYXNlNjQgfTtcbmV4cG9ydCAqIGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZXhwb3J0IHsgY29tcGFyZVZhbHVlcyB9IGZyb20gXCIuL2NvbXBhcmUuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbImNvbnZleFRvSnNvbiIsImpzb25Ub0NvbnZleCIsInYiLCJhc09iamVjdFZhbGlkYXRvciIsIkJhc2U2NCIsImNvbXBhcmVWYWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/values/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/values/validator.js":
/*!**********************************************************!*\
  !*** ./node_modules/convex/dist/esm/values/validator.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asObjectValidator: function() { return /* binding */ asObjectValidator; },\n/* harmony export */   isValidator: function() { return /* binding */ isValidator; },\n/* harmony export */   v: function() { return /* binding */ v; }\n/* harmony export */ });\n/* harmony import */ var _validators_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validators.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/validators.js\");\n\n\nfunction isValidator(v2) {\n    return !!v2.isConvexValidator;\n}\nfunction asObjectValidator(obj) {\n    if (isValidator(obj)) {\n        return obj;\n    } else {\n        return v.object(obj);\n    }\n}\nconst v = {\n    /**\n   * Validates that the value corresponds to an ID of a document in given table.\n   * @param tableName The name of the table.\n   */ id: (tableName)=>{\n        return new _validators_js__WEBPACK_IMPORTED_MODULE_0__.VId({\n            isOptional: \"required\",\n            tableName\n        });\n    },\n    /**\n   * Validates that the value is of type Null.\n   */ null: ()=>{\n        return new _validators_js__WEBPACK_IMPORTED_MODULE_0__.VNull({\n            isOptional: \"required\"\n        });\n    },\n    /**\n   * Validates that the value is of Convex type Float64 (Number in JS).\n   *\n   * Alias for `v.float64()`\n   */ number: ()=>{\n        return new _validators_js__WEBPACK_IMPORTED_MODULE_0__.VFloat64({\n            isOptional: \"required\"\n        });\n    },\n    /**\n   * Validates that the value is of Convex type Float64 (Number in JS).\n   */ float64: ()=>{\n        return new _validators_js__WEBPACK_IMPORTED_MODULE_0__.VFloat64({\n            isOptional: \"required\"\n        });\n    },\n    /**\n   * @deprecated Use `v.int64()` instead\n   */ bigint: ()=>{\n        return new _validators_js__WEBPACK_IMPORTED_MODULE_0__.VInt64({\n            isOptional: \"required\"\n        });\n    },\n    /**\n   * Validates that the value is of Convex type Int64 (BigInt in JS).\n   */ int64: ()=>{\n        return new _validators_js__WEBPACK_IMPORTED_MODULE_0__.VInt64({\n            isOptional: \"required\"\n        });\n    },\n    /**\n   * Validates that the value is of type Boolean.\n   */ boolean: ()=>{\n        return new _validators_js__WEBPACK_IMPORTED_MODULE_0__.VBoolean({\n            isOptional: \"required\"\n        });\n    },\n    /**\n   * Validates that the value is of type String.\n   */ string: ()=>{\n        return new _validators_js__WEBPACK_IMPORTED_MODULE_0__.VString({\n            isOptional: \"required\"\n        });\n    },\n    /**\n   * Validates that the value is of Convex type Bytes (constructed in JS via `ArrayBuffer`).\n   */ bytes: ()=>{\n        return new _validators_js__WEBPACK_IMPORTED_MODULE_0__.VBytes({\n            isOptional: \"required\"\n        });\n    },\n    /**\n   * Validates that the value is equal to the given literal value.\n   * @param literal The literal value to compare against.\n   */ literal: (literal)=>{\n        return new _validators_js__WEBPACK_IMPORTED_MODULE_0__.VLiteral({\n            isOptional: \"required\",\n            value: literal\n        });\n    },\n    /**\n   * Validates that the value is an Array of the given element type.\n   * @param element The validator for the elements of the array.\n   */ array: (element)=>{\n        return new _validators_js__WEBPACK_IMPORTED_MODULE_0__.VArray({\n            isOptional: \"required\",\n            element\n        });\n    },\n    /**\n   * Validates that the value is an Object with the given properties.\n   * @param fields An object specifying the validator for each property.\n   */ object: (fields)=>{\n        return new _validators_js__WEBPACK_IMPORTED_MODULE_0__.VObject({\n            isOptional: \"required\",\n            fields\n        });\n    },\n    /**\n   * Validates that the value is a Record with keys and values that match the given types.\n   * @param keys The validator for the keys of the record. This cannot contain string literals.\n   * @param values The validator for the values of the record.\n   */ record: (keys, values)=>{\n        return new _validators_js__WEBPACK_IMPORTED_MODULE_0__.VRecord({\n            isOptional: \"required\",\n            key: keys,\n            value: values\n        });\n    },\n    /**\n   * Validates that the value matches one of the given validators.\n   * @param members The validators to match against.\n   */ union: function() {\n        for(var _len = arguments.length, members = new Array(_len), _key = 0; _key < _len; _key++){\n            members[_key] = arguments[_key];\n        }\n        return new _validators_js__WEBPACK_IMPORTED_MODULE_0__.VUnion({\n            isOptional: \"required\",\n            members\n        });\n    },\n    /**\n   * Does not validate the value.\n   */ any: ()=>{\n        return new _validators_js__WEBPACK_IMPORTED_MODULE_0__.VAny({\n            isOptional: \"required\"\n        });\n    },\n    /**\n   * Allows not specifying a value for a property in an Object.\n   * @param value The property value validator to make optional.\n   *\n   * ```typescript\n   * const objectWithOptionalFields = v.object({\n   *   requiredField: v.string(),\n   *   optionalField: v.optional(v.string()),\n   * });\n   * ```\n   */ optional: (value)=>{\n        return value.asOptional();\n    },\n    /**\n   * Allows specifying a value or null.\n   */ nullable: (value)=>{\n        return v.union(value, v.null());\n    }\n}; //# sourceMappingURL=validator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmFsdWVzL3ZhbGlkYXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWE7QUFlWTtBQUNsQixTQUFTYSxZQUFZQyxFQUFFO0lBQzVCLE9BQU8sQ0FBQyxDQUFDQSxHQUFHQyxpQkFBaUI7QUFDL0I7QUFDTyxTQUFTQyxrQkFBa0JDLEdBQUc7SUFDbkMsSUFBSUosWUFBWUksTUFBTTtRQUNwQixPQUFPQTtJQUNULE9BQU87UUFDTCxPQUFPQyxFQUFFQyxNQUFNLENBQUNGO0lBQ2xCO0FBQ0Y7QUFDTyxNQUFNQyxJQUFJO0lBQ2Y7OztHQUdDLEdBQ0RFLElBQUksQ0FBQ0M7UUFDSCxPQUFPLElBQUloQiwrQ0FBR0EsQ0FBQztZQUNiaUIsWUFBWTtZQUNaRDtRQUNGO0lBQ0Y7SUFDQTs7R0FFQyxHQUNERSxNQUFNO1FBQ0osT0FBTyxJQUFJZixpREFBS0EsQ0FBQztZQUFFYyxZQUFZO1FBQVc7SUFDNUM7SUFDQTs7OztHQUlDLEdBQ0RFLFFBQVE7UUFDTixPQUFPLElBQUlwQixvREFBUUEsQ0FBQztZQUFFa0IsWUFBWTtRQUFXO0lBQy9DO0lBQ0E7O0dBRUMsR0FDREcsU0FBUztRQUNQLE9BQU8sSUFBSXJCLG9EQUFRQSxDQUFDO1lBQUVrQixZQUFZO1FBQVc7SUFDL0M7SUFDQTs7R0FFQyxHQUNESSxRQUFRO1FBQ04sT0FBTyxJQUFJcEIsa0RBQU1BLENBQUM7WUFBRWdCLFlBQVk7UUFBVztJQUM3QztJQUNBOztHQUVDLEdBQ0RLLE9BQU87UUFDTCxPQUFPLElBQUlyQixrREFBTUEsQ0FBQztZQUFFZ0IsWUFBWTtRQUFXO0lBQzdDO0lBQ0E7O0dBRUMsR0FDRE0sU0FBUztRQUNQLE9BQU8sSUFBSTFCLG9EQUFRQSxDQUFDO1lBQUVvQixZQUFZO1FBQVc7SUFDL0M7SUFDQTs7R0FFQyxHQUNETyxRQUFRO1FBQ04sT0FBTyxJQUFJbEIsbURBQU9BLENBQUM7WUFBRVcsWUFBWTtRQUFXO0lBQzlDO0lBQ0E7O0dBRUMsR0FDRFEsT0FBTztRQUNMLE9BQU8sSUFBSTNCLGtEQUFNQSxDQUFDO1lBQUVtQixZQUFZO1FBQVc7SUFDN0M7SUFDQTs7O0dBR0MsR0FDRFMsU0FBUyxDQUFDQTtRQUNSLE9BQU8sSUFBSXhCLG9EQUFRQSxDQUFDO1lBQUVlLFlBQVk7WUFBWVUsT0FBT0Q7UUFBUTtJQUMvRDtJQUNBOzs7R0FHQyxHQUNERSxPQUFPLENBQUNDO1FBQ04sT0FBTyxJQUFJakMsa0RBQU1BLENBQUM7WUFBRXFCLFlBQVk7WUFBWVk7UUFBUTtJQUN0RDtJQUNBOzs7R0FHQyxHQUNEZixRQUFRLENBQUNnQjtRQUNQLE9BQU8sSUFBSTFCLG1EQUFPQSxDQUFDO1lBQUVhLFlBQVk7WUFBWWE7UUFBTztJQUN0RDtJQUNBOzs7O0dBSUMsR0FDREMsUUFBUSxDQUFDQyxNQUFNQztRQUNiLE9BQU8sSUFBSTVCLG1EQUFPQSxDQUFDO1lBQ2pCWSxZQUFZO1lBQ1ppQixLQUFLRjtZQUNMTCxPQUFPTTtRQUNUO0lBQ0Y7SUFDQTs7O0dBR0MsR0FDREUsT0FBTzt5Q0FBSUM7WUFBQUE7O1FBQ1QsT0FBTyxJQUFJN0Isa0RBQU1BLENBQUM7WUFDaEJVLFlBQVk7WUFDWm1CO1FBQ0Y7SUFDRjtJQUNBOztHQUVDLEdBQ0RDLEtBQUs7UUFDSCxPQUFPLElBQUkxQyxnREFBSUEsQ0FBQztZQUFFc0IsWUFBWTtRQUFXO0lBQzNDO0lBQ0E7Ozs7Ozs7Ozs7R0FVQyxHQUNEcUIsVUFBVSxDQUFDWDtRQUNULE9BQU9BLE1BQU1ZLFVBQVU7SUFDekI7SUFDQTs7R0FFQyxHQUNEQyxVQUFVLENBQUNiO1FBQ1QsT0FBT2QsRUFBRXNCLEtBQUssQ0FBQ1IsT0FBT2QsRUFBRUssSUFBSTtJQUM5QjtBQUNGLEVBQUUsQ0FDRixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS92YWx1ZXMvdmFsaWRhdG9yLmpzP2Q1OTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQge1xuICBWQW55LFxuICBWQXJyYXksXG4gIFZCb29sZWFuLFxuICBWQnl0ZXMsXG4gIFZGbG9hdDY0LFxuICBWSWQsXG4gIFZJbnQ2NCxcbiAgVkxpdGVyYWwsXG4gIFZOdWxsLFxuICBWT2JqZWN0LFxuICBWUmVjb3JkLFxuICBWU3RyaW5nLFxuICBWVW5pb25cbn0gZnJvbSBcIi4vdmFsaWRhdG9ycy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRhdG9yKHYyKSB7XG4gIHJldHVybiAhIXYyLmlzQ29udmV4VmFsaWRhdG9yO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzT2JqZWN0VmFsaWRhdG9yKG9iaikge1xuICBpZiAoaXNWYWxpZGF0b3Iob2JqKSkge1xuICAgIHJldHVybiBvYmo7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHYub2JqZWN0KG9iaik7XG4gIH1cbn1cbmV4cG9ydCBjb25zdCB2ID0ge1xuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGNvcnJlc3BvbmRzIHRvIGFuIElEIG9mIGEgZG9jdW1lbnQgaW4gZ2l2ZW4gdGFibGUuXG4gICAqIEBwYXJhbSB0YWJsZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHRhYmxlLlxuICAgKi9cbiAgaWQ6ICh0YWJsZU5hbWUpID0+IHtcbiAgICByZXR1cm4gbmV3IFZJZCh7XG4gICAgICBpc09wdGlvbmFsOiBcInJlcXVpcmVkXCIsXG4gICAgICB0YWJsZU5hbWVcbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBvZiB0eXBlIE51bGwuXG4gICAqL1xuICBudWxsOiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBWTnVsbCh7IGlzT3B0aW9uYWw6IFwicmVxdWlyZWRcIiB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBvZiBDb252ZXggdHlwZSBGbG9hdDY0IChOdW1iZXIgaW4gSlMpLlxuICAgKlxuICAgKiBBbGlhcyBmb3IgYHYuZmxvYXQ2NCgpYFxuICAgKi9cbiAgbnVtYmVyOiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBWRmxvYXQ2NCh7IGlzT3B0aW9uYWw6IFwicmVxdWlyZWRcIiB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBvZiBDb252ZXggdHlwZSBGbG9hdDY0IChOdW1iZXIgaW4gSlMpLlxuICAgKi9cbiAgZmxvYXQ2NDogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgVkZsb2F0NjQoeyBpc09wdGlvbmFsOiBcInJlcXVpcmVkXCIgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYHYuaW50NjQoKWAgaW5zdGVhZFxuICAgKi9cbiAgYmlnaW50OiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBWSW50NjQoeyBpc09wdGlvbmFsOiBcInJlcXVpcmVkXCIgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgb2YgQ29udmV4IHR5cGUgSW50NjQgKEJpZ0ludCBpbiBKUykuXG4gICAqL1xuICBpbnQ2NDogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgVkludDY0KHsgaXNPcHRpb25hbDogXCJyZXF1aXJlZFwiIH0pO1xuICB9LFxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGlzIG9mIHR5cGUgQm9vbGVhbi5cbiAgICovXG4gIGJvb2xlYW46ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFZCb29sZWFuKHsgaXNPcHRpb25hbDogXCJyZXF1aXJlZFwiIH0pO1xuICB9LFxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGlzIG9mIHR5cGUgU3RyaW5nLlxuICAgKi9cbiAgc3RyaW5nOiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBWU3RyaW5nKHsgaXNPcHRpb25hbDogXCJyZXF1aXJlZFwiIH0pO1xuICB9LFxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGlzIG9mIENvbnZleCB0eXBlIEJ5dGVzIChjb25zdHJ1Y3RlZCBpbiBKUyB2aWEgYEFycmF5QnVmZmVyYCkuXG4gICAqL1xuICBieXRlczogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgVkJ5dGVzKHsgaXNPcHRpb25hbDogXCJyZXF1aXJlZFwiIH0pO1xuICB9LFxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGlzIGVxdWFsIHRvIHRoZSBnaXZlbiBsaXRlcmFsIHZhbHVlLlxuICAgKiBAcGFyYW0gbGl0ZXJhbCBUaGUgbGl0ZXJhbCB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gICAqL1xuICBsaXRlcmFsOiAobGl0ZXJhbCkgPT4ge1xuICAgIHJldHVybiBuZXcgVkxpdGVyYWwoeyBpc09wdGlvbmFsOiBcInJlcXVpcmVkXCIsIHZhbHVlOiBsaXRlcmFsIH0pO1xuICB9LFxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGlzIGFuIEFycmF5IG9mIHRoZSBnaXZlbiBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBlbGVtZW50IFRoZSB2YWxpZGF0b3IgZm9yIHRoZSBlbGVtZW50cyBvZiB0aGUgYXJyYXkuXG4gICAqL1xuICBhcnJheTogKGVsZW1lbnQpID0+IHtcbiAgICByZXR1cm4gbmV3IFZBcnJheSh7IGlzT3B0aW9uYWw6IFwicmVxdWlyZWRcIiwgZWxlbWVudCB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBhbiBPYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydGllcy5cbiAgICogQHBhcmFtIGZpZWxkcyBBbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgdmFsaWRhdG9yIGZvciBlYWNoIHByb3BlcnR5LlxuICAgKi9cbiAgb2JqZWN0OiAoZmllbGRzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBWT2JqZWN0KHsgaXNPcHRpb25hbDogXCJyZXF1aXJlZFwiLCBmaWVsZHMgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgYSBSZWNvcmQgd2l0aCBrZXlzIGFuZCB2YWx1ZXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gdHlwZXMuXG4gICAqIEBwYXJhbSBrZXlzIFRoZSB2YWxpZGF0b3IgZm9yIHRoZSBrZXlzIG9mIHRoZSByZWNvcmQuIFRoaXMgY2Fubm90IGNvbnRhaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgKiBAcGFyYW0gdmFsdWVzIFRoZSB2YWxpZGF0b3IgZm9yIHRoZSB2YWx1ZXMgb2YgdGhlIHJlY29yZC5cbiAgICovXG4gIHJlY29yZDogKGtleXMsIHZhbHVlcykgPT4ge1xuICAgIHJldHVybiBuZXcgVlJlY29yZCh7XG4gICAgICBpc09wdGlvbmFsOiBcInJlcXVpcmVkXCIsXG4gICAgICBrZXk6IGtleXMsXG4gICAgICB2YWx1ZTogdmFsdWVzXG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlIGdpdmVuIHZhbGlkYXRvcnMuXG4gICAqIEBwYXJhbSBtZW1iZXJzIFRoZSB2YWxpZGF0b3JzIHRvIG1hdGNoIGFnYWluc3QuXG4gICAqL1xuICB1bmlvbjogKC4uLm1lbWJlcnMpID0+IHtcbiAgICByZXR1cm4gbmV3IFZVbmlvbih7XG4gICAgICBpc09wdGlvbmFsOiBcInJlcXVpcmVkXCIsXG4gICAgICBtZW1iZXJzXG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBEb2VzIG5vdCB2YWxpZGF0ZSB0aGUgdmFsdWUuXG4gICAqL1xuICBhbnk6ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFZBbnkoeyBpc09wdGlvbmFsOiBcInJlcXVpcmVkXCIgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBBbGxvd3Mgbm90IHNwZWNpZnlpbmcgYSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBpbiBhbiBPYmplY3QuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgcHJvcGVydHkgdmFsdWUgdmFsaWRhdG9yIHRvIG1ha2Ugb3B0aW9uYWwuXG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3Qgb2JqZWN0V2l0aE9wdGlvbmFsRmllbGRzID0gdi5vYmplY3Qoe1xuICAgKiAgIHJlcXVpcmVkRmllbGQ6IHYuc3RyaW5nKCksXG4gICAqICAgb3B0aW9uYWxGaWVsZDogdi5vcHRpb25hbCh2LnN0cmluZygpKSxcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgb3B0aW9uYWw6ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZS5hc09wdGlvbmFsKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBBbGxvd3Mgc3BlY2lmeWluZyBhIHZhbHVlIG9yIG51bGwuXG4gICAqL1xuICBudWxsYWJsZTogKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHYudW5pb24odmFsdWUsIHYubnVsbCgpKTtcbiAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRvci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJWQW55IiwiVkFycmF5IiwiVkJvb2xlYW4iLCJWQnl0ZXMiLCJWRmxvYXQ2NCIsIlZJZCIsIlZJbnQ2NCIsIlZMaXRlcmFsIiwiVk51bGwiLCJWT2JqZWN0IiwiVlJlY29yZCIsIlZTdHJpbmciLCJWVW5pb24iLCJpc1ZhbGlkYXRvciIsInYyIiwiaXNDb252ZXhWYWxpZGF0b3IiLCJhc09iamVjdFZhbGlkYXRvciIsIm9iaiIsInYiLCJvYmplY3QiLCJpZCIsInRhYmxlTmFtZSIsImlzT3B0aW9uYWwiLCJudWxsIiwibnVtYmVyIiwiZmxvYXQ2NCIsImJpZ2ludCIsImludDY0IiwiYm9vbGVhbiIsInN0cmluZyIsImJ5dGVzIiwibGl0ZXJhbCIsInZhbHVlIiwiYXJyYXkiLCJlbGVtZW50IiwiZmllbGRzIiwicmVjb3JkIiwia2V5cyIsInZhbHVlcyIsImtleSIsInVuaW9uIiwibWVtYmVycyIsImFueSIsIm9wdGlvbmFsIiwiYXNPcHRpb25hbCIsIm51bGxhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/values/validator.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/values/validators.js":
/*!***********************************************************!*\
  !*** ./node_modules/convex/dist/esm/values/validators.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VAny: function() { return /* binding */ VAny; },\n/* harmony export */   VArray: function() { return /* binding */ VArray; },\n/* harmony export */   VBoolean: function() { return /* binding */ VBoolean; },\n/* harmony export */   VBytes: function() { return /* binding */ VBytes; },\n/* harmony export */   VFloat64: function() { return /* binding */ VFloat64; },\n/* harmony export */   VId: function() { return /* binding */ VId; },\n/* harmony export */   VInt64: function() { return /* binding */ VInt64; },\n/* harmony export */   VLiteral: function() { return /* binding */ VLiteral; },\n/* harmony export */   VNull: function() { return /* binding */ VNull; },\n/* harmony export */   VObject: function() { return /* binding */ VObject; },\n/* harmony export */   VRecord: function() { return /* binding */ VRecord; },\n/* harmony export */   VString: function() { return /* binding */ VString; },\n/* harmony export */   VUnion: function() { return /* binding */ VUnion; }\n/* harmony export */ });\n/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/value.js\");\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\nclass BaseValidator {\n    constructor({ isOptional }){\n        /**\n     * Only for TypeScript, the TS type of the JS values validated\n     * by this validator.\n     */ __publicField(this, \"type\");\n        /**\n     * Only for TypeScript, if this an Object validator, then\n     * this is the TS type of its property names.\n     */ __publicField(this, \"fieldPaths\");\n        /**\n     * Whether this is an optional Object property value validator.\n     */ __publicField(this, \"isOptional\");\n        /**\n     * Always `\"true\"`.\n     */ __publicField(this, \"isConvexValidator\");\n        this.isOptional = isOptional;\n        this.isConvexValidator = true;\n    }\n}\nclass VId extends BaseValidator {\n    /** @internal */ get json() {\n        return {\n            type: \"id\",\n            tableName: this.tableName\n        };\n    }\n    /** @internal */ asOptional() {\n        return new VId({\n            isOptional: \"optional\",\n            tableName: this.tableName\n        });\n    }\n    /**\n   * Usually you'd use `v.id(tableName)` instead.\n   */ constructor({ isOptional, tableName }){\n        super({\n            isOptional\n        });\n        /**\n     * The name of the table that the validated IDs must belong to.\n     */ __publicField(this, \"tableName\");\n        /**\n     * The kind of validator, `\"id\"`.\n     */ __publicField(this, \"kind\", \"id\");\n        if (typeof tableName !== \"string\") {\n            throw new Error(\"v.id(tableName) requires a string\");\n        }\n        this.tableName = tableName;\n    }\n}\nclass VFloat64 extends BaseValidator {\n    /** @internal */ get json() {\n        return {\n            type: \"number\"\n        };\n    }\n    /** @internal */ asOptional() {\n        return new VFloat64({\n            isOptional: \"optional\"\n        });\n    }\n    constructor(){\n        super(...arguments);\n        /**\n     * The kind of validator, `\"float64\"`.\n     */ __publicField(this, \"kind\", \"float64\");\n    }\n}\nclass VInt64 extends BaseValidator {\n    /** @internal */ get json() {\n        return {\n            type: \"bigint\"\n        };\n    }\n    /** @internal */ asOptional() {\n        return new VInt64({\n            isOptional: \"optional\"\n        });\n    }\n    constructor(){\n        super(...arguments);\n        /**\n     * The kind of validator, `\"int64\"`.\n     */ __publicField(this, \"kind\", \"int64\");\n    }\n}\nclass VBoolean extends BaseValidator {\n    /** @internal */ get json() {\n        return {\n            type: this.kind\n        };\n    }\n    /** @internal */ asOptional() {\n        return new VBoolean({\n            isOptional: \"optional\"\n        });\n    }\n    constructor(){\n        super(...arguments);\n        /**\n     * The kind of validator, `\"boolean\"`.\n     */ __publicField(this, \"kind\", \"boolean\");\n    }\n}\nclass VBytes extends BaseValidator {\n    /** @internal */ get json() {\n        return {\n            type: this.kind\n        };\n    }\n    /** @internal */ asOptional() {\n        return new VBytes({\n            isOptional: \"optional\"\n        });\n    }\n    constructor(){\n        super(...arguments);\n        /**\n     * The kind of validator, `\"bytes\"`.\n     */ __publicField(this, \"kind\", \"bytes\");\n    }\n}\nclass VString extends BaseValidator {\n    /** @internal */ get json() {\n        return {\n            type: this.kind\n        };\n    }\n    /** @internal */ asOptional() {\n        return new VString({\n            isOptional: \"optional\"\n        });\n    }\n    constructor(){\n        super(...arguments);\n        /**\n     * The kind of validator, `\"string\"`.\n     */ __publicField(this, \"kind\", \"string\");\n    }\n}\nclass VNull extends BaseValidator {\n    /** @internal */ get json() {\n        return {\n            type: this.kind\n        };\n    }\n    /** @internal */ asOptional() {\n        return new VNull({\n            isOptional: \"optional\"\n        });\n    }\n    constructor(){\n        super(...arguments);\n        /**\n     * The kind of validator, `\"null\"`.\n     */ __publicField(this, \"kind\", \"null\");\n    }\n}\nclass VAny extends BaseValidator {\n    /** @internal */ get json() {\n        return {\n            type: this.kind\n        };\n    }\n    /** @internal */ asOptional() {\n        return new VAny({\n            isOptional: \"optional\"\n        });\n    }\n    constructor(){\n        super(...arguments);\n        /**\n     * The kind of validator, `\"any\"`.\n     */ __publicField(this, \"kind\", \"any\");\n    }\n}\nclass VObject extends BaseValidator {\n    /** @internal */ get json() {\n        return {\n            type: this.kind,\n            value: globalThis.Object.fromEntries(globalThis.Object.entries(this.fields).map((param)=>{\n                let [k, v] = param;\n                return [\n                    k,\n                    {\n                        fieldType: v.json,\n                        optional: v.isOptional === \"optional\" ? true : false\n                    }\n                ];\n            }))\n        };\n    }\n    /** @internal */ asOptional() {\n        return new VObject({\n            isOptional: \"optional\",\n            fields: this.fields\n        });\n    }\n    /**\n   * Create a new VObject with the specified fields omitted.\n   * @param fields The field names to omit from this VObject.\n   */ omit() {\n        for(var _len = arguments.length, fields = new Array(_len), _key = 0; _key < _len; _key++){\n            fields[_key] = arguments[_key];\n        }\n        const newFields = {\n            ...this.fields\n        };\n        for (const field of fields){\n            delete newFields[field];\n        }\n        return new VObject({\n            isOptional: this.isOptional,\n            fields: newFields\n        });\n    }\n    /**\n   * Create a new VObject with only the specified fields.\n   * @param fields The field names to pick from this VObject.\n   */ pick() {\n        for(var _len = arguments.length, fields = new Array(_len), _key = 0; _key < _len; _key++){\n            fields[_key] = arguments[_key];\n        }\n        const newFields = {};\n        for (const field of fields){\n            newFields[field] = this.fields[field];\n        }\n        return new VObject({\n            isOptional: this.isOptional,\n            fields: newFields\n        });\n    }\n    /**\n   * Create a new VObject with all fields marked as optional.\n   */ partial() {\n        const newFields = {};\n        for (const [key, validator] of globalThis.Object.entries(this.fields)){\n            newFields[key] = validator.asOptional();\n        }\n        return new VObject({\n            isOptional: this.isOptional,\n            fields: newFields\n        });\n    }\n    /**\n   * Create a new VObject with additional fields merged in.\n   * @param fields An object with additional validators to merge into this VObject.\n   */ extend(fields) {\n        return new VObject({\n            isOptional: this.isOptional,\n            fields: {\n                ...this.fields,\n                ...fields\n            }\n        });\n    }\n    /**\n   * Usually you'd use `v.object({ ... })` instead.\n   */ constructor({ isOptional, fields }){\n        super({\n            isOptional\n        });\n        /**\n     * An object with the validator for each property.\n     */ __publicField(this, \"fields\");\n        /**\n     * The kind of validator, `\"object\"`.\n     */ __publicField(this, \"kind\", \"object\");\n        globalThis.Object.values(fields).forEach((v)=>{\n            if (!v.isConvexValidator) {\n                throw new Error(\"v.object() entries must be validators\");\n            }\n        });\n        this.fields = fields;\n    }\n}\nclass VLiteral extends BaseValidator {\n    /** @internal */ get json() {\n        return {\n            type: this.kind,\n            value: (0,_value_js__WEBPACK_IMPORTED_MODULE_0__.convexToJson)(this.value)\n        };\n    }\n    /** @internal */ asOptional() {\n        return new VLiteral({\n            isOptional: \"optional\",\n            value: this.value\n        });\n    }\n    /**\n   * Usually you'd use `v.literal(value)` instead.\n   */ constructor({ isOptional, value }){\n        super({\n            isOptional\n        });\n        /**\n     * The value that the validated values must be equal to.\n     */ __publicField(this, \"value\");\n        /**\n     * The kind of validator, `\"literal\"`.\n     */ __publicField(this, \"kind\", \"literal\");\n        if (typeof value !== \"string\" && typeof value !== \"boolean\" && typeof value !== \"number\" && typeof value !== \"bigint\") {\n            throw new Error(\"v.literal(value) must be a string, number, or boolean\");\n        }\n        this.value = value;\n    }\n}\nclass VArray extends BaseValidator {\n    /** @internal */ get json() {\n        return {\n            type: this.kind,\n            value: this.element.json\n        };\n    }\n    /** @internal */ asOptional() {\n        return new VArray({\n            isOptional: \"optional\",\n            element: this.element\n        });\n    }\n    /**\n   * Usually you'd use `v.array(element)` instead.\n   */ constructor({ isOptional, element }){\n        super({\n            isOptional\n        });\n        /**\n     * The validator for the elements of the array.\n     */ __publicField(this, \"element\");\n        /**\n     * The kind of validator, `\"array\"`.\n     */ __publicField(this, \"kind\", \"array\");\n        this.element = element;\n    }\n}\nclass VRecord extends BaseValidator {\n    /** @internal */ get json() {\n        return {\n            type: this.kind,\n            // This cast is needed because TypeScript thinks the key type is too wide\n            keys: this.key.json,\n            values: {\n                fieldType: this.value.json,\n                optional: false\n            }\n        };\n    }\n    /** @internal */ asOptional() {\n        return new VRecord({\n            isOptional: \"optional\",\n            key: this.key,\n            value: this.value\n        });\n    }\n    /**\n   * Usually you'd use `v.record(key, value)` instead.\n   */ constructor({ isOptional, key, value }){\n        super({\n            isOptional\n        });\n        /**\n     * The validator for the keys of the record.\n     */ __publicField(this, \"key\");\n        /**\n     * The validator for the values of the record.\n     */ __publicField(this, \"value\");\n        /**\n     * The kind of validator, `\"record\"`.\n     */ __publicField(this, \"kind\", \"record\");\n        if (key.isOptional === \"optional\") {\n            throw new Error(\"Record validator cannot have optional keys\");\n        }\n        if (value.isOptional === \"optional\") {\n            throw new Error(\"Record validator cannot have optional values\");\n        }\n        if (!key.isConvexValidator || !value.isConvexValidator) {\n            throw new Error(\"Key and value of v.record() but be validators\");\n        }\n        this.key = key;\n        this.value = value;\n    }\n}\nclass VUnion extends BaseValidator {\n    /** @internal */ get json() {\n        return {\n            type: this.kind,\n            value: this.members.map((v)=>v.json)\n        };\n    }\n    /** @internal */ asOptional() {\n        return new VUnion({\n            isOptional: \"optional\",\n            members: this.members\n        });\n    }\n    /**\n   * Usually you'd use `v.union(...members)` instead.\n   */ constructor({ isOptional, members }){\n        super({\n            isOptional\n        });\n        /**\n     * The array of validators, one of which must match the value.\n     */ __publicField(this, \"members\");\n        /**\n     * The kind of validator, `\"union\"`.\n     */ __publicField(this, \"kind\", \"union\");\n        members.forEach((member)=>{\n            if (!member.isConvexValidator) {\n                throw new Error(\"All members of v.union() must be validators\");\n            }\n        });\n        this.members = members;\n    }\n} //# sourceMappingURL=validators.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmFsdWVzL3ZhbGlkYXRvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUNiLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsa0JBQWtCLENBQUNDLEtBQUtDLEtBQUtDLFFBQVVELE9BQU9ELE1BQU1KLFVBQVVJLEtBQUtDLEtBQUs7UUFBRUUsWUFBWTtRQUFNQyxjQUFjO1FBQU1DLFVBQVU7UUFBTUg7SUFBTSxLQUFLRixHQUFHLENBQUNDLElBQUksR0FBR0M7QUFDMUosSUFBSUksZ0JBQWdCLENBQUNOLEtBQUtDLEtBQUtDLFFBQVVILGdCQUFnQkMsS0FBSyxPQUFPQyxRQUFRLFdBQVdBLE1BQU0sS0FBS0EsS0FBS0M7QUFDOUQ7QUFDMUMsTUFBTU07SUFDSkMsWUFBWSxFQUFFQyxVQUFVLEVBQUUsQ0FBRTtRQUMxQjs7O0tBR0MsR0FDREosY0FBYyxJQUFJLEVBQUU7UUFDcEI7OztLQUdDLEdBQ0RBLGNBQWMsSUFBSSxFQUFFO1FBQ3BCOztLQUVDLEdBQ0RBLGNBQWMsSUFBSSxFQUFFO1FBQ3BCOztLQUVDLEdBQ0RBLGNBQWMsSUFBSSxFQUFFO1FBQ3BCLElBQUksQ0FBQ0ksVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLGlCQUFpQixHQUFHO0lBQzNCO0FBQ0Y7QUFDTyxNQUFNQyxZQUFZSjtJQXNCdkIsY0FBYyxHQUNkLElBQUlLLE9BQU87UUFDVCxPQUFPO1lBQUVDLE1BQU07WUFBTUMsV0FBVyxJQUFJLENBQUNBLFNBQVM7UUFBQztJQUNqRDtJQUNBLGNBQWMsR0FDZEMsYUFBYTtRQUNYLE9BQU8sSUFBSUosSUFBSTtZQUNiRixZQUFZO1lBQ1pLLFdBQVcsSUFBSSxDQUFDQSxTQUFTO1FBQzNCO0lBQ0Y7SUEvQkE7O0dBRUMsR0FDRE4sWUFBWSxFQUNWQyxVQUFVLEVBQ1ZLLFNBQVMsRUFDVixDQUFFO1FBQ0QsS0FB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QUksQ0FBQ0EsT0FBTztRQUN2QjtJQUNGO0lBakNBOztHQUVDLEdBQ0QzQyxZQUFZLEVBQUVDLFVBQVUsRUFBRTBDLE9BQU8sRUFBRSxDQUFFO1FBQ25DLEtBQUssQ0FBQztZQUFFMUM7UUFBVztRQUNuQjs7S0FFQyxHQUNESixjQUFjLElBQUksRUFBRTtRQUNwQjs7S0FFQyxHQUNEQSxjQUFjLElBQUksRUFBRSxRQUFRO1FBQzVCOEMsUUFBUVAsT0FBTyxDQUFDLENBQUNRO1lBQ2YsSUFBSSxDQUFDQSxPQUFPMUMsaUJBQWlCLEVBQUU7Z0JBQzdCLE1BQU0sSUFBSU0sTUFBTTtZQUNsQjtRQUNGO1FBQ0EsSUFBSSxDQUFDbUMsT0FBTyxHQUFHQTtJQUNqQjtBQWVGLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmFsdWVzL3ZhbGlkYXRvcnMuanM/OWRhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5pbXBvcnQgeyBjb252ZXhUb0pzb24gfSBmcm9tIFwiLi92YWx1ZS5qc1wiO1xuY2xhc3MgQmFzZVZhbGlkYXRvciB7XG4gIGNvbnN0cnVjdG9yKHsgaXNPcHRpb25hbCB9KSB7XG4gICAgLyoqXG4gICAgICogT25seSBmb3IgVHlwZVNjcmlwdCwgdGhlIFRTIHR5cGUgb2YgdGhlIEpTIHZhbHVlcyB2YWxpZGF0ZWRcbiAgICAgKiBieSB0aGlzIHZhbGlkYXRvci5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidHlwZVwiKTtcbiAgICAvKipcbiAgICAgKiBPbmx5IGZvciBUeXBlU2NyaXB0LCBpZiB0aGlzIGFuIE9iamVjdCB2YWxpZGF0b3IsIHRoZW5cbiAgICAgKiB0aGlzIGlzIHRoZSBUUyB0eXBlIG9mIGl0cyBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZmllbGRQYXRoc1wiKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgaXMgYW4gb3B0aW9uYWwgT2JqZWN0IHByb3BlcnR5IHZhbHVlIHZhbGlkYXRvci5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaXNPcHRpb25hbFwiKTtcbiAgICAvKipcbiAgICAgKiBBbHdheXMgYFwidHJ1ZVwiYC5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaXNDb252ZXhWYWxpZGF0b3JcIik7XG4gICAgdGhpcy5pc09wdGlvbmFsID0gaXNPcHRpb25hbDtcbiAgICB0aGlzLmlzQ29udmV4VmFsaWRhdG9yID0gdHJ1ZTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFZJZCBleHRlbmRzIEJhc2VWYWxpZGF0b3Ige1xuICAvKipcbiAgICogVXN1YWxseSB5b3UnZCB1c2UgYHYuaWQodGFibGVOYW1lKWAgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBpc09wdGlvbmFsLFxuICAgIHRhYmxlTmFtZVxuICB9KSB7XG4gICAgc3VwZXIoeyBpc09wdGlvbmFsIH0pO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSB0YWJsZSB0aGF0IHRoZSB2YWxpZGF0ZWQgSURzIG11c3QgYmVsb25nIHRvLlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0YWJsZU5hbWVcIik7XG4gICAgLyoqXG4gICAgICogVGhlIGtpbmQgb2YgdmFsaWRhdG9yLCBgXCJpZFwiYC5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwia2luZFwiLCBcImlkXCIpO1xuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2LmlkKHRhYmxlTmFtZSkgcmVxdWlyZXMgYSBzdHJpbmdcIik7XG4gICAgfVxuICAgIHRoaXMudGFibGVOYW1lID0gdGFibGVOYW1lO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IGpzb24oKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJpZFwiLCB0YWJsZU5hbWU6IHRoaXMudGFibGVOYW1lIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc09wdGlvbmFsKCkge1xuICAgIHJldHVybiBuZXcgVklkKHtcbiAgICAgIGlzT3B0aW9uYWw6IFwib3B0aW9uYWxcIixcbiAgICAgIHRhYmxlTmFtZTogdGhpcy50YWJsZU5hbWVcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFZGbG9hdDY0IGV4dGVuZHMgQmFzZVZhbGlkYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgLyoqXG4gICAgICogVGhlIGtpbmQgb2YgdmFsaWRhdG9yLCBgXCJmbG9hdDY0XCJgLlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJraW5kXCIsIFwiZmxvYXQ2NFwiKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBqc29uKCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwibnVtYmVyXCIgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWRmxvYXQ2NCh7XG4gICAgICBpc09wdGlvbmFsOiBcIm9wdGlvbmFsXCJcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFZJbnQ2NCBleHRlbmRzIEJhc2VWYWxpZGF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKlxuICAgICAqIFRoZSBraW5kIG9mIHZhbGlkYXRvciwgYFwiaW50NjRcImAuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImtpbmRcIiwgXCJpbnQ2NFwiKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBqc29uKCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiYmlnaW50XCIgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWSW50NjQoeyBpc09wdGlvbmFsOiBcIm9wdGlvbmFsXCIgfSk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBWQm9vbGVhbiBleHRlbmRzIEJhc2VWYWxpZGF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKlxuICAgICAqIFRoZSBraW5kIG9mIHZhbGlkYXRvciwgYFwiYm9vbGVhblwiYC5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwia2luZFwiLCBcImJvb2xlYW5cIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQganNvbigpIHtcbiAgICByZXR1cm4geyB0eXBlOiB0aGlzLmtpbmQgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWQm9vbGVhbih7XG4gICAgICBpc09wdGlvbmFsOiBcIm9wdGlvbmFsXCJcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFZCeXRlcyBleHRlbmRzIEJhc2VWYWxpZGF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKlxuICAgICAqIFRoZSBraW5kIG9mIHZhbGlkYXRvciwgYFwiYnl0ZXNcImAuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImtpbmRcIiwgXCJieXRlc1wiKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBqc29uKCkge1xuICAgIHJldHVybiB7IHR5cGU6IHRoaXMua2luZCB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXNPcHRpb25hbCgpIHtcbiAgICByZXR1cm4gbmV3IFZCeXRlcyh7IGlzT3B0aW9uYWw6IFwib3B0aW9uYWxcIiB9KTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFZTdHJpbmcgZXh0ZW5kcyBCYXNlVmFsaWRhdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKipcbiAgICAgKiBUaGUga2luZCBvZiB2YWxpZGF0b3IsIGBcInN0cmluZ1wiYC5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwia2luZFwiLCBcInN0cmluZ1wiKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBqc29uKCkge1xuICAgIHJldHVybiB7IHR5cGU6IHRoaXMua2luZCB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXNPcHRpb25hbCgpIHtcbiAgICByZXR1cm4gbmV3IFZTdHJpbmcoe1xuICAgICAgaXNPcHRpb25hbDogXCJvcHRpb25hbFwiXG4gICAgfSk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBWTnVsbCBleHRlbmRzIEJhc2VWYWxpZGF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKlxuICAgICAqIFRoZSBraW5kIG9mIHZhbGlkYXRvciwgYFwibnVsbFwiYC5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwia2luZFwiLCBcIm51bGxcIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQganNvbigpIHtcbiAgICByZXR1cm4geyB0eXBlOiB0aGlzLmtpbmQgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWTnVsbCh7IGlzT3B0aW9uYWw6IFwib3B0aW9uYWxcIiB9KTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFZBbnkgZXh0ZW5kcyBCYXNlVmFsaWRhdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKipcbiAgICAgKiBUaGUga2luZCBvZiB2YWxpZGF0b3IsIGBcImFueVwiYC5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwia2luZFwiLCBcImFueVwiKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBqc29uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0aGlzLmtpbmRcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXNPcHRpb25hbCgpIHtcbiAgICByZXR1cm4gbmV3IFZBbnkoe1xuICAgICAgaXNPcHRpb25hbDogXCJvcHRpb25hbFwiXG4gICAgfSk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBWT2JqZWN0IGV4dGVuZHMgQmFzZVZhbGlkYXRvciB7XG4gIC8qKlxuICAgKiBVc3VhbGx5IHlvdSdkIHVzZSBgdi5vYmplY3QoeyAuLi4gfSlgIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgaXNPcHRpb25hbCxcbiAgICBmaWVsZHNcbiAgfSkge1xuICAgIHN1cGVyKHsgaXNPcHRpb25hbCB9KTtcbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3Qgd2l0aCB0aGUgdmFsaWRhdG9yIGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmaWVsZHNcIik7XG4gICAgLyoqXG4gICAgICogVGhlIGtpbmQgb2YgdmFsaWRhdG9yLCBgXCJvYmplY3RcImAuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImtpbmRcIiwgXCJvYmplY3RcIik7XG4gICAgZ2xvYmFsVGhpcy5PYmplY3QudmFsdWVzKGZpZWxkcykuZm9yRWFjaCgodikgPT4ge1xuICAgICAgaWYgKCF2LmlzQ29udmV4VmFsaWRhdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInYub2JqZWN0KCkgZW50cmllcyBtdXN0IGJlIHZhbGlkYXRvcnNcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQganNvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy5raW5kLFxuICAgICAgdmFsdWU6IGdsb2JhbFRoaXMuT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBnbG9iYWxUaGlzLk9iamVjdC5lbnRyaWVzKHRoaXMuZmllbGRzKS5tYXAoKFtrLCB2XSkgPT4gW1xuICAgICAgICAgIGssXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmllbGRUeXBlOiB2Lmpzb24sXG4gICAgICAgICAgICBvcHRpb25hbDogdi5pc09wdGlvbmFsID09PSBcIm9wdGlvbmFsXCIgPyB0cnVlIDogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIF0pXG4gICAgICApXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWT2JqZWN0KHtcbiAgICAgIGlzT3B0aW9uYWw6IFwib3B0aW9uYWxcIixcbiAgICAgIGZpZWxkczogdGhpcy5maWVsZHNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFZPYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIGZpZWxkcyBvbWl0dGVkLlxuICAgKiBAcGFyYW0gZmllbGRzIFRoZSBmaWVsZCBuYW1lcyB0byBvbWl0IGZyb20gdGhpcyBWT2JqZWN0LlxuICAgKi9cbiAgb21pdCguLi5maWVsZHMpIHtcbiAgICBjb25zdCBuZXdGaWVsZHMgPSB7IC4uLnRoaXMuZmllbGRzIH07XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgIGRlbGV0ZSBuZXdGaWVsZHNbZmllbGRdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZPYmplY3Qoe1xuICAgICAgaXNPcHRpb25hbDogdGhpcy5pc09wdGlvbmFsLFxuICAgICAgZmllbGRzOiBuZXdGaWVsZHNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFZPYmplY3Qgd2l0aCBvbmx5IHRoZSBzcGVjaWZpZWQgZmllbGRzLlxuICAgKiBAcGFyYW0gZmllbGRzIFRoZSBmaWVsZCBuYW1lcyB0byBwaWNrIGZyb20gdGhpcyBWT2JqZWN0LlxuICAgKi9cbiAgcGljayguLi5maWVsZHMpIHtcbiAgICBjb25zdCBuZXdGaWVsZHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgbmV3RmllbGRzW2ZpZWxkXSA9IHRoaXMuZmllbGRzW2ZpZWxkXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBWT2JqZWN0KHtcbiAgICAgIGlzT3B0aW9uYWw6IHRoaXMuaXNPcHRpb25hbCxcbiAgICAgIGZpZWxkczogbmV3RmllbGRzXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBWT2JqZWN0IHdpdGggYWxsIGZpZWxkcyBtYXJrZWQgYXMgb3B0aW9uYWwuXG4gICAqL1xuICBwYXJ0aWFsKCkge1xuICAgIGNvbnN0IG5ld0ZpZWxkcyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsaWRhdG9yXSBvZiBnbG9iYWxUaGlzLk9iamVjdC5lbnRyaWVzKHRoaXMuZmllbGRzKSkge1xuICAgICAgbmV3RmllbGRzW2tleV0gPSB2YWxpZGF0b3IuYXNPcHRpb25hbCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZPYmplY3Qoe1xuICAgICAgaXNPcHRpb25hbDogdGhpcy5pc09wdGlvbmFsLFxuICAgICAgZmllbGRzOiBuZXdGaWVsZHNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFZPYmplY3Qgd2l0aCBhZGRpdGlvbmFsIGZpZWxkcyBtZXJnZWQgaW4uXG4gICAqIEBwYXJhbSBmaWVsZHMgQW4gb2JqZWN0IHdpdGggYWRkaXRpb25hbCB2YWxpZGF0b3JzIHRvIG1lcmdlIGludG8gdGhpcyBWT2JqZWN0LlxuICAgKi9cbiAgZXh0ZW5kKGZpZWxkcykge1xuICAgIHJldHVybiBuZXcgVk9iamVjdCh7XG4gICAgICBpc09wdGlvbmFsOiB0aGlzLmlzT3B0aW9uYWwsXG4gICAgICBmaWVsZHM6IHsgLi4udGhpcy5maWVsZHMsIC4uLmZpZWxkcyB9XG4gICAgfSk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBWTGl0ZXJhbCBleHRlbmRzIEJhc2VWYWxpZGF0b3Ige1xuICAvKipcbiAgICogVXN1YWxseSB5b3UnZCB1c2UgYHYubGl0ZXJhbCh2YWx1ZSlgIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGlzT3B0aW9uYWwsIHZhbHVlIH0pIHtcbiAgICBzdXBlcih7IGlzT3B0aW9uYWwgfSk7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHRoYXQgdGhlIHZhbGlkYXRlZCB2YWx1ZXMgbXVzdCBiZSBlcXVhbCB0by5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmFsdWVcIik7XG4gICAgLyoqXG4gICAgICogVGhlIGtpbmQgb2YgdmFsaWRhdG9yLCBgXCJsaXRlcmFsXCJgLlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJraW5kXCIsIFwibGl0ZXJhbFwiKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJib29sZWFuXCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJiaWdpbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidi5saXRlcmFsKHZhbHVlKSBtdXN0IGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIGJvb2xlYW5cIik7XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBqc29uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0aGlzLmtpbmQsXG4gICAgICB2YWx1ZTogY29udmV4VG9Kc29uKHRoaXMudmFsdWUpXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWTGl0ZXJhbCh7XG4gICAgICBpc09wdGlvbmFsOiBcIm9wdGlvbmFsXCIsXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgIH0pO1xuICB9XG59XG5leHBvcnQgY2xhc3MgVkFycmF5IGV4dGVuZHMgQmFzZVZhbGlkYXRvciB7XG4gIC8qKlxuICAgKiBVc3VhbGx5IHlvdSdkIHVzZSBgdi5hcnJheShlbGVtZW50KWAgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBpc09wdGlvbmFsLFxuICAgIGVsZW1lbnRcbiAgfSkge1xuICAgIHN1cGVyKHsgaXNPcHRpb25hbCB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsaWRhdG9yIGZvciB0aGUgZWxlbWVudHMgb2YgdGhlIGFycmF5LlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJlbGVtZW50XCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBraW5kIG9mIHZhbGlkYXRvciwgYFwiYXJyYXlcImAuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImtpbmRcIiwgXCJhcnJheVwiKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IGpzb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHRoaXMua2luZCxcbiAgICAgIHZhbHVlOiB0aGlzLmVsZW1lbnQuanNvblxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc09wdGlvbmFsKCkge1xuICAgIHJldHVybiBuZXcgVkFycmF5KHtcbiAgICAgIGlzT3B0aW9uYWw6IFwib3B0aW9uYWxcIixcbiAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudFxuICAgIH0pO1xuICB9XG59XG5leHBvcnQgY2xhc3MgVlJlY29yZCBleHRlbmRzIEJhc2VWYWxpZGF0b3Ige1xuICAvKipcbiAgICogVXN1YWxseSB5b3UnZCB1c2UgYHYucmVjb3JkKGtleSwgdmFsdWUpYCBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGlzT3B0aW9uYWwsXG4gICAga2V5LFxuICAgIHZhbHVlXG4gIH0pIHtcbiAgICBzdXBlcih7IGlzT3B0aW9uYWwgfSk7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbGlkYXRvciBmb3IgdGhlIGtleXMgb2YgdGhlIHJlY29yZC5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwia2V5XCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWxpZGF0b3IgZm9yIHRoZSB2YWx1ZXMgb2YgdGhlIHJlY29yZC5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmFsdWVcIik7XG4gICAgLyoqXG4gICAgICogVGhlIGtpbmQgb2YgdmFsaWRhdG9yLCBgXCJyZWNvcmRcImAuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImtpbmRcIiwgXCJyZWNvcmRcIik7XG4gICAgaWYgKGtleS5pc09wdGlvbmFsID09PSBcIm9wdGlvbmFsXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY29yZCB2YWxpZGF0b3IgY2Fubm90IGhhdmUgb3B0aW9uYWwga2V5c1wiKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLmlzT3B0aW9uYWwgPT09IFwib3B0aW9uYWxcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjb3JkIHZhbGlkYXRvciBjYW5ub3QgaGF2ZSBvcHRpb25hbCB2YWx1ZXNcIik7XG4gICAgfVxuICAgIGlmICgha2V5LmlzQ29udmV4VmFsaWRhdG9yIHx8ICF2YWx1ZS5pc0NvbnZleFZhbGlkYXRvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGFuZCB2YWx1ZSBvZiB2LnJlY29yZCgpIGJ1dCBiZSB2YWxpZGF0b3JzXCIpO1xuICAgIH1cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQganNvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy5raW5kLFxuICAgICAgLy8gVGhpcyBjYXN0IGlzIG5lZWRlZCBiZWNhdXNlIFR5cGVTY3JpcHQgdGhpbmtzIHRoZSBrZXkgdHlwZSBpcyB0b28gd2lkZVxuICAgICAga2V5czogdGhpcy5rZXkuanNvbixcbiAgICAgIHZhbHVlczoge1xuICAgICAgICBmaWVsZFR5cGU6IHRoaXMudmFsdWUuanNvbixcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWUmVjb3JkKHtcbiAgICAgIGlzT3B0aW9uYWw6IFwib3B0aW9uYWxcIixcbiAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgIH0pO1xuICB9XG59XG5leHBvcnQgY2xhc3MgVlVuaW9uIGV4dGVuZHMgQmFzZVZhbGlkYXRvciB7XG4gIC8qKlxuICAgKiBVc3VhbGx5IHlvdSdkIHVzZSBgdi51bmlvbiguLi5tZW1iZXJzKWAgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgaXNPcHRpb25hbCwgbWVtYmVycyB9KSB7XG4gICAgc3VwZXIoeyBpc09wdGlvbmFsIH0pO1xuICAgIC8qKlxuICAgICAqIFRoZSBhcnJheSBvZiB2YWxpZGF0b3JzLCBvbmUgb2Ygd2hpY2ggbXVzdCBtYXRjaCB0aGUgdmFsdWUuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1lbWJlcnNcIik7XG4gICAgLyoqXG4gICAgICogVGhlIGtpbmQgb2YgdmFsaWRhdG9yLCBgXCJ1bmlvblwiYC5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwia2luZFwiLCBcInVuaW9uXCIpO1xuICAgIG1lbWJlcnMuZm9yRWFjaCgobWVtYmVyKSA9PiB7XG4gICAgICBpZiAoIW1lbWJlci5pc0NvbnZleFZhbGlkYXRvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbGwgbWVtYmVycyBvZiB2LnVuaW9uKCkgbXVzdCBiZSB2YWxpZGF0b3JzXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMubWVtYmVycyA9IG1lbWJlcnM7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQganNvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy5raW5kLFxuICAgICAgdmFsdWU6IHRoaXMubWVtYmVycy5tYXAoKHYpID0+IHYuanNvbilcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXNPcHRpb25hbCgpIHtcbiAgICByZXR1cm4gbmV3IFZVbmlvbih7XG4gICAgICBpc09wdGlvbmFsOiBcIm9wdGlvbmFsXCIsXG4gICAgICBtZW1iZXJzOiB0aGlzLm1lbWJlcnNcbiAgICB9KTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdG9ycy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX19wdWJsaWNGaWVsZCIsImNvbnZleFRvSnNvbiIsIkJhc2VWYWxpZGF0b3IiLCJjb25zdHJ1Y3RvciIsImlzT3B0aW9uYWwiLCJpc0NvbnZleFZhbGlkYXRvciIsIlZJZCIsImpzb24iLCJ0eXBlIiwidGFibGVOYW1lIiwiYXNPcHRpb25hbCIsIkVycm9yIiwiVkZsb2F0NjQiLCJhcmd1bWVudHMiLCJWSW50NjQiLCJWQm9vbGVhbiIsImtpbmQiLCJWQnl0ZXMiLCJWU3RyaW5nIiwiVk51bGwiLCJWQW55IiwiVk9iamVjdCIsImdsb2JhbFRoaXMiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJmaWVsZHMiLCJtYXAiLCJrIiwidiIsImZpZWxkVHlwZSIsIm9wdGlvbmFsIiwib21pdCIsIm5ld0ZpZWxkcyIsImZpZWxkIiwicGljayIsInBhcnRpYWwiLCJ2YWxpZGF0b3IiLCJleHRlbmQiLCJ2YWx1ZXMiLCJmb3JFYWNoIiwiVkxpdGVyYWwiLCJWQXJyYXkiLCJlbGVtZW50IiwiVlJlY29yZCIsImtleXMiLCJWVW5pb24iLCJtZW1iZXJzIiwibWVtYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/values/validators.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/values/value.js":
/*!******************************************************!*\
  !*** ./node_modules/convex/dist/esm/values/value.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64ToBigInt: function() { return /* binding */ base64ToBigInt; },\n/* harmony export */   bigIntToBase64: function() { return /* binding */ bigIntToBase64; },\n/* harmony export */   convexOrUndefinedToJson: function() { return /* binding */ convexOrUndefinedToJson; },\n/* harmony export */   convexToJson: function() { return /* binding */ convexToJson; },\n/* harmony export */   jsonToConvex: function() { return /* binding */ jsonToConvex; },\n/* harmony export */   modernBase64ToBigInt: function() { return /* binding */ modernBase64ToBigInt; },\n/* harmony export */   modernBigIntToBase64: function() { return /* binding */ modernBigIntToBase64; },\n/* harmony export */   patchValueToJson: function() { return /* binding */ patchValueToJson; },\n/* harmony export */   slowBase64ToBigInt: function() { return /* binding */ slowBase64ToBigInt; },\n/* harmony export */   slowBigIntToBase64: function() { return /* binding */ slowBigIntToBase64; },\n/* harmony export */   stringifyValueForError: function() { return /* binding */ stringifyValueForError; }\n/* harmony export */ });\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/values/base64.js\");\n/* harmony import */ var _common_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/index.js */ \"(app-pages-browser)/./node_modules/convex/dist/esm/common/index.js\");\n\n\n\nconst LITTLE_ENDIAN = true;\nconst MIN_INT64 = BigInt(\"-9223372036854775808\");\nconst MAX_INT64 = BigInt(\"9223372036854775807\");\nconst ZERO = BigInt(\"0\");\nconst EIGHT = BigInt(\"8\");\nconst TWOFIFTYSIX = BigInt(\"256\");\nfunction isSpecial(n) {\n    return Number.isNaN(n) || !Number.isFinite(n) || Object.is(n, -0);\n}\nfunction slowBigIntToBase64(value) {\n    if (value < ZERO) {\n        value -= MIN_INT64 + MIN_INT64;\n    }\n    let hex = value.toString(16);\n    if (hex.length % 2 === 1) hex = \"0\" + hex;\n    const bytes = new Uint8Array(new ArrayBuffer(8));\n    let i = 0;\n    for (const hexByte of hex.match(/.{2}/g).reverse()){\n        bytes.set([\n            parseInt(hexByte, 16)\n        ], i++);\n        value >>= EIGHT;\n    }\n    return _base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(bytes);\n}\nfunction slowBase64ToBigInt(encoded) {\n    const integerBytes = _base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(encoded);\n    if (integerBytes.byteLength !== 8) {\n        throw new Error(\"Received \".concat(integerBytes.byteLength, \" bytes, expected 8 for $integer\"));\n    }\n    let value = ZERO;\n    let power = ZERO;\n    for (const byte of integerBytes){\n        value += BigInt(byte) * TWOFIFTYSIX ** power;\n        power++;\n    }\n    if (value > MAX_INT64) {\n        value += MIN_INT64 + MIN_INT64;\n    }\n    return value;\n}\nfunction modernBigIntToBase64(value) {\n    if (value < MIN_INT64 || MAX_INT64 < value) {\n        throw new Error(\"BigInt \".concat(value, \" does not fit into a 64-bit signed integer.\"));\n    }\n    const buffer = new ArrayBuffer(8);\n    new DataView(buffer).setBigInt64(0, value, true);\n    return _base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(new Uint8Array(buffer));\n}\nfunction modernBase64ToBigInt(encoded) {\n    const integerBytes = _base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(encoded);\n    if (integerBytes.byteLength !== 8) {\n        throw new Error(\"Received \".concat(integerBytes.byteLength, \" bytes, expected 8 for $integer\"));\n    }\n    const intBytesView = new DataView(integerBytes.buffer);\n    return intBytesView.getBigInt64(0, true);\n}\nconst bigIntToBase64 = DataView.prototype.setBigInt64 ? modernBigIntToBase64 : slowBigIntToBase64;\nconst base64ToBigInt = DataView.prototype.getBigInt64 ? modernBase64ToBigInt : slowBase64ToBigInt;\nconst MAX_IDENTIFIER_LEN = 1024;\nfunction validateObjectField(k) {\n    if (k.length > MAX_IDENTIFIER_LEN) {\n        throw new Error(\"Field name \".concat(k, \" exceeds maximum field name length \").concat(MAX_IDENTIFIER_LEN, \".\"));\n    }\n    if (k.startsWith(\"$\")) {\n        throw new Error(\"Field name \".concat(k, \" starts with a '$', which is reserved.\"));\n    }\n    for(let i = 0; i < k.length; i += 1){\n        const charCode = k.charCodeAt(i);\n        if (charCode < 32 || charCode >= 127) {\n            throw new Error(\"Field name \".concat(k, \" has invalid character '\").concat(k[i], \"': Field names can only contain non-control ASCII characters\"));\n        }\n    }\n}\nfunction jsonToConvex(value) {\n    if (value === null) {\n        return value;\n    }\n    if (typeof value === \"boolean\") {\n        return value;\n    }\n    if (typeof value === \"number\") {\n        return value;\n    }\n    if (typeof value === \"string\") {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        return value.map((value2)=>jsonToConvex(value2));\n    }\n    if (typeof value !== \"object\") {\n        throw new Error(\"Unexpected type of \".concat(value));\n    }\n    const entries = Object.entries(value);\n    if (entries.length === 1) {\n        const key = entries[0][0];\n        if (key === \"$bytes\") {\n            if (typeof value.$bytes !== \"string\") {\n                throw new Error(\"Malformed $bytes field on \".concat(value));\n            }\n            return _base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(value.$bytes).buffer;\n        }\n        if (key === \"$integer\") {\n            if (typeof value.$integer !== \"string\") {\n                throw new Error(\"Malformed $integer field on \".concat(value));\n            }\n            return base64ToBigInt(value.$integer);\n        }\n        if (key === \"$float\") {\n            if (typeof value.$float !== \"string\") {\n                throw new Error(\"Malformed $float field on \".concat(value));\n            }\n            const floatBytes = _base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(value.$float);\n            if (floatBytes.byteLength !== 8) {\n                throw new Error(\"Received \".concat(floatBytes.byteLength, \" bytes, expected 8 for $float\"));\n            }\n            const floatBytesView = new DataView(floatBytes.buffer);\n            const float = floatBytesView.getFloat64(0, LITTLE_ENDIAN);\n            if (!isSpecial(float)) {\n                throw new Error(\"Float \".concat(float, \" should be encoded as a number\"));\n            }\n            return float;\n        }\n        if (key === \"$set\") {\n            throw new Error(\"Received a Set which is no longer supported as a Convex type.\");\n        }\n        if (key === \"$map\") {\n            throw new Error(\"Received a Map which is no longer supported as a Convex type.\");\n        }\n    }\n    const out = {};\n    for (const [k, v] of Object.entries(value)){\n        validateObjectField(k);\n        out[k] = jsonToConvex(v);\n    }\n    return out;\n}\nconst MAX_VALUE_FOR_ERROR_LEN = 16384;\nfunction stringifyValueForError(value) {\n    const str = JSON.stringify(value, (_key, value2)=>{\n        if (value2 === void 0) {\n            return \"undefined\";\n        }\n        if (typeof value2 === \"bigint\") {\n            return \"\".concat(value2.toString(), \"n\");\n        }\n        return value2;\n    });\n    if (str.length > MAX_VALUE_FOR_ERROR_LEN) {\n        const rest = \"[...truncated]\";\n        let truncateAt = MAX_VALUE_FOR_ERROR_LEN - rest.length;\n        const codePoint = str.codePointAt(truncateAt - 1);\n        if (codePoint !== void 0 && codePoint > 65535) {\n            truncateAt -= 1;\n        }\n        return str.substring(0, truncateAt) + rest;\n    }\n    return str;\n}\nfunction convexToJsonInternal(value, originalValue, context, includeTopLevelUndefined) {\n    if (value === void 0) {\n        const contextText = context && \" (present at path \".concat(context, \" in original object \").concat(stringifyValueForError(originalValue), \")\");\n        throw new Error(\"undefined is not a valid Convex value\".concat(contextText, \". To learn about Convex's supported types, see https://docs.convex.dev/using/types.\"));\n    }\n    if (value === null) {\n        return value;\n    }\n    if (typeof value === \"bigint\") {\n        if (value < MIN_INT64 || MAX_INT64 < value) {\n            throw new Error(\"BigInt \".concat(value, \" does not fit into a 64-bit signed integer.\"));\n        }\n        return {\n            $integer: bigIntToBase64(value)\n        };\n    }\n    if (typeof value === \"number\") {\n        if (isSpecial(value)) {\n            const buffer = new ArrayBuffer(8);\n            new DataView(buffer).setFloat64(0, value, LITTLE_ENDIAN);\n            return {\n                $float: _base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(new Uint8Array(buffer))\n            };\n        } else {\n            return value;\n        }\n    }\n    if (typeof value === \"boolean\") {\n        return value;\n    }\n    if (typeof value === \"string\") {\n        return value;\n    }\n    if (value instanceof ArrayBuffer) {\n        return {\n            $bytes: _base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(new Uint8Array(value))\n        };\n    }\n    if (Array.isArray(value)) {\n        return value.map((value2, i)=>convexToJsonInternal(value2, originalValue, context + \"[\".concat(i, \"]\"), false));\n    }\n    if (value instanceof Set) {\n        throw new Error(errorMessageForUnsupportedType(context, \"Set\", [\n            ...value\n        ], originalValue));\n    }\n    if (value instanceof Map) {\n        throw new Error(errorMessageForUnsupportedType(context, \"Map\", [\n            ...value\n        ], originalValue));\n    }\n    if (!(0,_common_index_js__WEBPACK_IMPORTED_MODULE_1__.isSimpleObject)(value)) {\n        var _value_constructor;\n        const theType = value === null || value === void 0 ? void 0 : (_value_constructor = value.constructor) === null || _value_constructor === void 0 ? void 0 : _value_constructor.name;\n        const typeName = theType ? \"\".concat(theType, \" \") : \"\";\n        throw new Error(errorMessageForUnsupportedType(context, typeName, value, originalValue));\n    }\n    const out = {};\n    const entries = Object.entries(value);\n    entries.sort((param, param1)=>{\n        let [k1, _v1] = param, [k2, _v2] = param1;\n        return k1 === k2 ? 0 : k1 < k2 ? -1 : 1;\n    });\n    for (const [k, v] of entries){\n        if (v !== void 0) {\n            validateObjectField(k);\n            out[k] = convexToJsonInternal(v, originalValue, context + \".\".concat(k), false);\n        } else if (includeTopLevelUndefined) {\n            validateObjectField(k);\n            out[k] = convexOrUndefinedToJsonInternal(v, originalValue, context + \".\".concat(k));\n        }\n    }\n    return out;\n}\nfunction errorMessageForUnsupportedType(context, typeName, value, originalValue) {\n    if (context) {\n        return \"\".concat(typeName).concat(stringifyValueForError(value), \" is not a supported Convex type (present at path \").concat(context, \" in original object \").concat(stringifyValueForError(originalValue), \"). To learn about Convex's supported types, see https://docs.convex.dev/using/types.\");\n    } else {\n        return \"\".concat(typeName).concat(stringifyValueForError(value), \" is not a supported Convex type.\");\n    }\n}\nfunction convexOrUndefinedToJsonInternal(value, originalValue, context) {\n    if (value === void 0) {\n        return {\n            $undefined: null\n        };\n    } else {\n        if (originalValue === void 0) {\n            throw new Error(\"Programming error. Current value is \".concat(stringifyValueForError(value), \" but original value is undefined\"));\n        }\n        return convexToJsonInternal(value, originalValue, context, false);\n    }\n}\nfunction convexToJson(value) {\n    return convexToJsonInternal(value, value, \"\", false);\n}\nfunction convexOrUndefinedToJson(value) {\n    return convexOrUndefinedToJsonInternal(value, value, \"\");\n}\nfunction patchValueToJson(value) {\n    return convexToJsonInternal(value, value, \"\", true);\n} //# sourceMappingURL=value.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmFsdWVzL3ZhbHVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUN5QjtBQUNjO0FBQ3BELE1BQU1FLGdCQUFnQjtBQUN0QixNQUFNQyxZQUFZQyxPQUFPO0FBQ3pCLE1BQU1DLFlBQVlELE9BQU87QUFDekIsTUFBTUUsT0FBT0YsT0FBTztBQUNwQixNQUFNRyxRQUFRSCxPQUFPO0FBQ3JCLE1BQU1JLGNBQWNKLE9BQU87QUFDM0IsU0FBU0ssVUFBVUMsQ0FBQztJQUNsQixPQUFPQyxPQUFPQyxLQUFLLENBQUNGLE1BQU0sQ0FBQ0MsT0FBT0UsUUFBUSxDQUFDSCxNQUFNSSxPQUFPQyxFQUFFLENBQUNMLEdBQUcsQ0FBQztBQUNqRTtBQUNPLFNBQVNNLG1CQUFtQkMsS0FBSztJQUN0QyxJQUFJQSxRQUFRWCxNQUFNO1FBQ2hCVyxTQUFTZCxZQUFZQTtJQUN2QjtJQUNBLElBQUllLE1BQU1ELE1BQU1FLFFBQVEsQ0FBQztJQUN6QixJQUFJRCxJQUFJRSxNQUFNLEdBQUcsTUFBTSxHQUFHRixNQUFNLE1BQU1BO0lBQ3RDLE1BQU1HLFFBQVEsSUFBSUMsV0FBVyxJQUFJQyxZQUFZO0lBQzdDLElBQUlDLElBQUk7SUFDUixLQUFLLE1BQU1DLFdBQVdQLElBQUlRLEtBQUssQ0FBQyxTQUFTQyxPQUFPLEdBQUk7UUFDbEROLE1BQU1PLEdBQUcsQ0FBQztZQUFDQyxTQUFTSixTQUFTO1NBQUksRUFBRUQ7UUFDbkNQLFVBQVVWO0lBQ1o7SUFDQSxPQUFPUCxxREFBb0IsQ0FBQ3FCO0FBQzlCO0FBQ08sU0FBU1UsbUJBQW1CQyxPQUFPO0lBQ3hDLE1BQU1DLGVBQWVqQyxtREFBa0IsQ0FBQ2dDO0lBQ3hDLElBQUlDLGFBQWFFLFVBQVUsS0FBSyxHQUFHO1FBQ2pDLE1BQU0sSUFBSUMsTUFDUixZQUFvQyxPQUF4QkgsYUFBYUUsVUFBVSxFQUFDO0lBRXhDO0lBQ0EsSUFBSWxCLFFBQVFYO0lBQ1osSUFBSStCLFFBQVEvQjtJQUNaLEtBQUssTUFBTWdDLFFBQVFMLGFBQWM7UUFDL0JoQixTQUFTYixPQUFPa0MsUUFBUTlCLGVBQWU2QjtRQUN2Q0E7SUFDRjtJQUNBLElBQUlwQixRQUFRWixXQUFXO1FBQ3JCWSxTQUFTZCxZQUFZQTtJQUN2QjtJQUNBLE9BQU9jO0FBQ1Q7QUFDTyxTQUFTc0IscUJBQXFCdEIsS0FBSztJQUN4QyxJQUFJQSxRQUFRZCxhQUFhRSxZQUFZWSxPQUFPO1FBQzFDLE1BQU0sSUFBSW1CLE1BQ1IsVUFBZ0IsT0FBTm5CLE9BQU07SUFFcEI7SUFDQSxNQUFNdUIsU0FBUyxJQUFJakIsWUFBWTtJQUMvQixJQUFJa0IsU0FBU0QsUUFBUUUsV0FBVyxDQUFDLEdBQUd6QixPQUFPO0lBQzNDLE9BQU9qQixxREFBb0IsQ0FBQyxJQUFJc0IsV0FBV2tCO0FBQzdDO0FBQ08sU0FBU0cscUJBQXFCWCxPQUFPO0lBQzFDLE1BQU1DLGVBQWVqQyxtREFBa0IsQ0FBQ2dDO0lBQ3hDLElBQUlDLGFBQWFFLFVBQVUsS0FBSyxHQUFHO1FBQ2pDLE1BQU0sSUFBSUMsTUFDUixZQUFvQyxPQUF4QkgsYUFBYUUsVUFBVSxFQUFDO0lBRXhDO0lBQ0EsTUFBTVMsZUFBZSxJQUFJSCxTQUFTUixhQUFhTyxNQUFNO0lBQ3JELE9BQU9JLGFBQWFDLFdBQVcsQ0FBQyxHQUFHO0FBQ3JDO0FBQ08sTUFBTUMsaUJBQWlCTCxTQUFTTSxTQUFTLENBQUNMLFdBQVcsR0FBR0gsdUJBQXVCdkIsbUJBQW1CO0FBQ2xHLE1BQU1nQyxpQkFBaUJQLFNBQVNNLFNBQVMsQ0FBQ0YsV0FBVyxHQUFHRix1QkFBdUJaLG1CQUFtQjtBQUN6RyxNQUFNa0IscUJBQXFCO0FBQzNCLFNBQVNDLG9CQUFvQkMsQ0FBQztJQUM1QixJQUFJQSxFQUFFL0IsTUFBTSxHQUFHNkIsb0JBQW9CO1FBQ2pDLE1BQU0sSUFBSWIsTUFDUixjQUFxRGEsT0FBdkNFLEdBQUUsdUNBQXdELE9BQW5CRixvQkFBbUI7SUFFNUU7SUFDQSxJQUFJRSxFQUFFQyxVQUFVLENBQUMsTUFBTTtRQUNyQixNQUFNLElBQUloQixNQUFNLGNBQWdCLE9BQUZlLEdBQUU7SUFDbEM7SUFDQSxJQUFLLElBQUkzQixJQUFJLEdBQUdBLElBQUkyQixFQUFFL0IsTUFBTSxFQUFFSSxLQUFLLEVBQUc7UUFDcEMsTUFBTTZCLFdBQVdGLEVBQUVHLFVBQVUsQ0FBQzlCO1FBQzlCLElBQUk2QixXQUFXLE1BQU1BLFlBQVksS0FBSztZQUNwQyxNQUFNLElBQUlqQixNQUNSLGNBQTBDZSxPQUE1QkEsR0FBRSw0QkFBK0IsT0FBTEEsQ0FBQyxDQUFDM0IsRUFBRSxFQUFDO1FBRW5EO0lBQ0Y7QUFDRjtBQUNPLFNBQVMrQixhQUFhdEMsS0FBSztJQUNoQyxJQUFJQSxVQUFVLE1BQU07UUFDbEIsT0FBT0E7SUFDVDtJQUNBLElBQUksT0FBT0EsVUFBVSxXQUFXO1FBQzlCLE9BQU9BO0lBQ1Q7SUFDQSxJQUFJLE9BQU9BLFVBQVUsVUFBVTtRQUM3QixPQUFPQTtJQUNUO0lBQ0EsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDN0IsT0FBT0E7SUFDVDtJQUNBLElBQUl1QyxNQUFNQyxPQUFPLENBQUN4QyxRQUFRO1FBQ3hCLE9BQU9BLE1BQU15QyxHQUFHLENBQUMsQ0FBQ0MsU0FBV0osYUFBYUk7SUFDNUM7SUFDQSxJQUFJLE9BQU8xQyxVQUFVLFVBQVU7UUFDN0IsTUFBTSxJQUFJbUIsTUFBTSxzQkFBNEIsT0FBTm5CO0lBQ3hDO0lBQ0EsTUFBTTJDLFVBQVU5QyxPQUFPOEMsT0FBTyxDQUFDM0M7SUFDL0IsSUFBSTJDLFFBQVF4QyxNQUFNLEtBQUssR0FBRztRQUN4QixNQUFNeUMsTUFBTUQsT0FBTyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ3pCLElBQUlDLFFBQVEsVUFBVTtZQUNwQixJQUFJLE9BQU81QyxNQUFNNkMsTUFBTSxLQUFLLFVBQVU7Z0JBQ3BDLE1BQU0sSUFBSTFCLE1BQU0sNkJBQW1DLE9BQU5uQjtZQUMvQztZQUNBLE9BQU9qQixtREFBa0IsQ0FBQ2lCLE1BQU02QyxNQUFNLEVBQUV0QixNQUFNO1FBQ2hEO1FBQ0EsSUFBSXFCLFFBQVEsWUFBWTtZQUN0QixJQUFJLE9BQU81QyxNQUFNOEMsUUFBUSxLQUFLLFVBQVU7Z0JBQ3RDLE1BQU0sSUFBSTNCLE1BQU0sK0JBQXFDLE9BQU5uQjtZQUNqRDtZQUNBLE9BQU8rQixlQUFlL0IsTUFBTThDLFFBQVE7UUFDdEM7UUFDQSxJQUFJRixRQUFRLFVBQVU7WUFDcEIsSUFBSSxPQUFPNUMsTUFBTStDLE1BQU0sS0FBSyxVQUFVO2dCQUNwQyxNQUFNLElBQUk1QixNQUFNLDZCQUFtQyxPQUFObkI7WUFDL0M7WUFDQSxNQUFNZ0QsYUFBYWpFLG1EQUFrQixDQUFDaUIsTUFBTStDLE1BQU07WUFDbEQsSUFBSUMsV0FBVzlCLFVBQVUsS0FBSyxHQUFHO2dCQUMvQixNQUFNLElBQUlDLE1BQ1IsWUFBa0MsT0FBdEI2QixXQUFXOUIsVUFBVSxFQUFDO1lBRXRDO1lBQ0EsTUFBTStCLGlCQUFpQixJQUFJekIsU0FBU3dCLFdBQVd6QixNQUFNO1lBQ3JELE1BQU0yQixRQUFRRCxlQUFlRSxVQUFVLENBQUMsR0FBR2xFO1lBQzNDLElBQUksQ0FBQ08sVUFBVTBELFFBQVE7Z0JBQ3JCLE1BQU0sSUFBSS9CLE1BQU0sU0FBZSxPQUFOK0IsT0FBTTtZQUNqQztZQUNBLE9BQU9BO1FBQ1Q7UUFDQSxJQUFJTixRQUFRLFFBQVE7WUFDbEIsTUFBTSxJQUFJekIsTUFDUDtRQUVMO1FBQ0EsSUFBSXlCLFFBQVEsUUFBUTtZQUNsQixNQUFNLElBQUl6QixNQUNQO1FBRUw7SUFDRjtJQUNBLE1BQU1pQyxNQUFNLENBQUM7SUFDYixLQUFLLE1BQU0sQ0FBQ2xCLEdBQUdtQixFQUFFLElBQUl4RCxPQUFPOEMsT0FBTyxDQUFDM0MsT0FBUTtRQUMxQ2lDLG9CQUFvQkM7UUFDcEJrQixHQUFHLENBQUNsQixFQUFFLEdBQUdJLGFBQWFlO0lBQ3hCO0lBQ0EsT0FBT0Q7QUFDVDtBQUNBLE1BQU1FLDBCQUEwQjtBQUN6QixTQUFTQyx1QkFBdUJ2RCxLQUFLO0lBQzFDLE1BQU13RCxNQUFNQyxLQUFLQyxTQUFTLENBQUMxRCxPQUFPLENBQUMyRCxNQUFNakI7UUFDdkMsSUFBSUEsV0FBVyxLQUFLLEdBQUc7WUFDckIsT0FBTztRQUNUO1FBQ0EsSUFBSSxPQUFPQSxXQUFXLFVBQVU7WUFDOUIsT0FBTyxHQUFxQixPQUFsQkEsT0FBT3hDLFFBQVEsSUFBRztRQUM5QjtRQUNBLE9BQU93QztJQUNUO0lBQ0EsSUFBSWMsSUFBSXJELE1BQU0sR0FBR21ELHlCQUF5QjtRQUN4QyxNQUFNTSxPQUFPO1FBQ2IsSUFBSUMsYUFBYVAsMEJBQTBCTSxLQUFLekQsTUFBTTtRQUN0RCxNQUFNMkQsWUFBWU4sSUFBSU8sV0FBVyxDQUFDRixhQUFhO1FBQy9DLElBQUlDLGNBQWMsS0FBSyxLQUFLQSxZQUFZLE9BQU87WUFDN0NELGNBQWM7UUFDaEI7UUFDQSxPQUFPTCxJQUFJUSxTQUFTLENBQUMsR0FBR0gsY0FBY0Q7SUFDeEM7SUFDQSxPQUFPSjtBQUNUO0FBQ0EsU0FBU1MscUJBQXFCakUsS0FBSyxFQUFFa0UsYUFBYSxFQUFFQyxPQUFPLEVBQUVDLHdCQUF3QjtJQUNuRixJQUFJcEUsVUFBVSxLQUFLLEdBQUc7UUFDcEIsTUFBTXFFLGNBQWNGLFdBQVcscUJBQW1EWixPQUE5QlksU0FBUSx3QkFFMUQsT0FGZ0ZaLHVCQUNoRlcsZ0JBQ0E7UUFDRixNQUFNLElBQUkvQyxNQUNSLHdDQUFvRCxPQUFaa0QsYUFBWTtJQUV4RDtJQUNBLElBQUlyRSxVQUFVLE1BQU07UUFDbEIsT0FBT0E7SUFDVDtJQUNBLElBQUksT0FBT0EsVUFBVSxVQUFVO1FBQzdCLElBQUlBLFFBQVFkLGFBQWFFLFlBQVlZLE9BQU87WUFDMUMsTUFBTSxJQUFJbUIsTUFDUixVQUFnQixPQUFObkIsT0FBTTtRQUVwQjtRQUNBLE9BQU87WUFBRThDLFVBQVVqQixlQUFlN0I7UUFBTztJQUMzQztJQUNBLElBQUksT0FBT0EsVUFBVSxVQUFVO1FBQzdCLElBQUlSLFVBQVVRLFFBQVE7WUFDcEIsTUFBTXVCLFNBQVMsSUFBSWpCLFlBQVk7WUFDL0IsSUFBSWtCLFNBQVNELFFBQVErQyxVQUFVLENBQUMsR0FBR3RFLE9BQU9mO1lBQzFDLE9BQU87Z0JBQUU4RCxRQUFRaEUscURBQW9CLENBQUMsSUFBSXNCLFdBQVdrQjtZQUFTO1FBQ2hFLE9BQU87WUFDTCxPQUFPdkI7UUFDVDtJQUNGO0lBQ0EsSUFBSSxPQUFPQSxVQUFVLFdBQVc7UUFDOUIsT0FBT0E7SUFDVDtJQUNBLElBQUksT0FBT0EsVUFBVSxVQUFVO1FBQzdCLE9BQU9BO0lBQ1Q7SUFDQSxJQUFJQSxpQkFBaUJNLGFBQWE7UUFDaEMsT0FBTztZQUFFdUMsUUFBUTlELHFEQUFvQixDQUFDLElBQUlzQixXQUFXTDtRQUFRO0lBQy9EO0lBQ0EsSUFBSXVDLE1BQU1DLE9BQU8sQ0FBQ3hDLFFBQVE7UUFDeEIsT0FBT0EsTUFBTXlDLEdBQUcsQ0FDZCxDQUFDQyxRQUFRbkMsSUFBTTBELHFCQUFxQnZCLFFBQVF3QixlQUFlQyxVQUFVLElBQU0sT0FBRjVELEdBQUUsTUFBSTtJQUVuRjtJQUNBLElBQUlQLGlCQUFpQnVFLEtBQUs7UUFDeEIsTUFBTSxJQUFJcEQsTUFDUnFELCtCQUErQkwsU0FBUyxPQUFPO2VBQUluRTtTQUFNLEVBQUVrRTtJQUUvRDtJQUNBLElBQUlsRSxpQkFBaUJ5RSxLQUFLO1FBQ3hCLE1BQU0sSUFBSXRELE1BQ1JxRCwrQkFBK0JMLFNBQVMsT0FBTztlQUFJbkU7U0FBTSxFQUFFa0U7SUFFL0Q7SUFDQSxJQUFJLENBQUNsRixnRUFBY0EsQ0FBQ2dCLFFBQVE7WUFDVkE7UUFBaEIsTUFBTTBFLFVBQVUxRSxrQkFBQUEsNkJBQUFBLHFCQUFBQSxNQUFPMkUsV0FBVyxjQUFsQjNFLHlDQUFBQSxtQkFBb0I0RSxJQUFJO1FBQ3hDLE1BQU1DLFdBQVdILFVBQVUsR0FBVyxPQUFSQSxTQUFRLE9BQUs7UUFDM0MsTUFBTSxJQUFJdkQsTUFDUnFELCtCQUErQkwsU0FBU1UsVUFBVTdFLE9BQU9rRTtJQUU3RDtJQUNBLE1BQU1kLE1BQU0sQ0FBQztJQUNiLE1BQU1ULFVBQVU5QyxPQUFPOEMsT0FBTyxDQUFDM0M7SUFDL0IyQyxRQUFRbUMsSUFBSSxDQUFDO1lBQUMsQ0FBQ0MsSUFBSUMsSUFBSSxVQUFFLENBQUNDLElBQUlDLElBQUk7ZUFBS0gsT0FBT0UsS0FBSyxJQUFJRixLQUFLRSxLQUFLLENBQUMsSUFBSTs7SUFDdEUsS0FBSyxNQUFNLENBQUMvQyxHQUFHbUIsRUFBRSxJQUFJVixRQUFTO1FBQzVCLElBQUlVLE1BQU0sS0FBSyxHQUFHO1lBQ2hCcEIsb0JBQW9CQztZQUNwQmtCLEdBQUcsQ0FBQ2xCLEVBQUUsR0FBRytCLHFCQUFxQlosR0FBR2EsZUFBZUMsVUFBVSxJQUFNLE9BQUZqQyxJQUFLO1FBQ3JFLE9BQU8sSUFBSWtDLDBCQUEwQjtZQUNuQ25DLG9CQUFvQkM7WUFDcEJrQixHQUFHLENBQUNsQixFQUFFLEdBQUdpRCxnQ0FDUDlCLEdBQ0FhLGVBQ0FDLFVBQVUsSUFBTSxPQUFGakM7UUFFbEI7SUFDRjtJQUNBLE9BQU9rQjtBQUNUO0FBQ0EsU0FBU29CLCtCQUErQkwsT0FBTyxFQUFFVSxRQUFRLEVBQUU3RSxLQUFLLEVBQUVrRSxhQUFhO0lBQzdFLElBQUlDLFNBQVM7UUFDWCxPQUFPLEdBQWNaLE9BQVhzQixVQUUyQ1YsT0FGaENaLHVCQUNuQnZELFFBQ0EscURBQWlGdUQsT0FBOUJZLFNBQVEsd0JBRTNELE9BRmlGWix1QkFDakZXLGdCQUNBO0lBQ0osT0FBTztRQUNMLE9BQU8sR0FBY1gsT0FBWHNCLFVBRVIsT0FGbUJ0Qix1QkFDbkJ2RCxRQUNBO0lBQ0o7QUFDRjtBQUNBLFNBQVNtRixnQ0FBZ0NuRixLQUFLLEVBQUVrRSxhQUFhLEVBQUVDLE9BQU87SUFDcEUsSUFBSW5FLFVBQVUsS0FBSyxHQUFHO1FBQ3BCLE9BQU87WUFBRW9GLFlBQVk7UUFBSztJQUM1QixPQUFPO1FBQ0wsSUFBSWxCLGtCQUFrQixLQUFLLEdBQUc7WUFDNUIsTUFBTSxJQUFJL0MsTUFDUix1Q0FFRSxPQUZxQ29DLHVCQUNyQ3ZELFFBQ0E7UUFFTjtRQUNBLE9BQU9pRSxxQkFBcUJqRSxPQUFPa0UsZUFBZUMsU0FBUztJQUM3RDtBQUNGO0FBQ08sU0FBU2tCLGFBQWFyRixLQUFLO0lBQ2hDLE9BQU9pRSxxQkFBcUJqRSxPQUFPQSxPQUFPLElBQUk7QUFDaEQ7QUFDTyxTQUFTc0Ysd0JBQXdCdEYsS0FBSztJQUMzQyxPQUFPbUYsZ0NBQWdDbkYsT0FBT0EsT0FBTztBQUN2RDtBQUNPLFNBQVN1RixpQkFBaUJ2RixLQUFLO0lBQ3BDLE9BQU9pRSxxQkFBcUJqRSxPQUFPQSxPQUFPLElBQUk7QUFDaEQsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS92YWx1ZXMvdmFsdWUuanM/MTViMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCAqIGFzIEJhc2U2NCBmcm9tIFwiLi9iYXNlNjQuanNcIjtcbmltcG9ydCB7IGlzU2ltcGxlT2JqZWN0IH0gZnJvbSBcIi4uL2NvbW1vbi9pbmRleC5qc1wiO1xuY29uc3QgTElUVExFX0VORElBTiA9IHRydWU7XG5jb25zdCBNSU5fSU5UNjQgPSBCaWdJbnQoXCItOTIyMzM3MjAzNjg1NDc3NTgwOFwiKTtcbmNvbnN0IE1BWF9JTlQ2NCA9IEJpZ0ludChcIjkyMjMzNzIwMzY4NTQ3NzU4MDdcIik7XG5jb25zdCBaRVJPID0gQmlnSW50KFwiMFwiKTtcbmNvbnN0IEVJR0hUID0gQmlnSW50KFwiOFwiKTtcbmNvbnN0IFRXT0ZJRlRZU0lYID0gQmlnSW50KFwiMjU2XCIpO1xuZnVuY3Rpb24gaXNTcGVjaWFsKG4pIHtcbiAgcmV0dXJuIE51bWJlci5pc05hTihuKSB8fCAhTnVtYmVyLmlzRmluaXRlKG4pIHx8IE9iamVjdC5pcyhuLCAtMCk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2xvd0JpZ0ludFRvQmFzZTY0KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA8IFpFUk8pIHtcbiAgICB2YWx1ZSAtPSBNSU5fSU5UNjQgKyBNSU5fSU5UNjQ7XG4gIH1cbiAgbGV0IGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgaWYgKGhleC5sZW5ndGggJSAyID09PSAxKSBoZXggPSBcIjBcIiArIGhleDtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShuZXcgQXJyYXlCdWZmZXIoOCkpO1xuICBsZXQgaSA9IDA7XG4gIGZvciAoY29uc3QgaGV4Qnl0ZSBvZiBoZXgubWF0Y2goLy57Mn0vZykucmV2ZXJzZSgpKSB7XG4gICAgYnl0ZXMuc2V0KFtwYXJzZUludChoZXhCeXRlLCAxNildLCBpKyspO1xuICAgIHZhbHVlID4+PSBFSUdIVDtcbiAgfVxuICByZXR1cm4gQmFzZTY0LmZyb21CeXRlQXJyYXkoYnl0ZXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNsb3dCYXNlNjRUb0JpZ0ludChlbmNvZGVkKSB7XG4gIGNvbnN0IGludGVnZXJCeXRlcyA9IEJhc2U2NC50b0J5dGVBcnJheShlbmNvZGVkKTtcbiAgaWYgKGludGVnZXJCeXRlcy5ieXRlTGVuZ3RoICE9PSA4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFJlY2VpdmVkICR7aW50ZWdlckJ5dGVzLmJ5dGVMZW5ndGh9IGJ5dGVzLCBleHBlY3RlZCA4IGZvciAkaW50ZWdlcmBcbiAgICApO1xuICB9XG4gIGxldCB2YWx1ZSA9IFpFUk87XG4gIGxldCBwb3dlciA9IFpFUk87XG4gIGZvciAoY29uc3QgYnl0ZSBvZiBpbnRlZ2VyQnl0ZXMpIHtcbiAgICB2YWx1ZSArPSBCaWdJbnQoYnl0ZSkgKiBUV09GSUZUWVNJWCAqKiBwb3dlcjtcbiAgICBwb3dlcisrO1xuICB9XG4gIGlmICh2YWx1ZSA+IE1BWF9JTlQ2NCkge1xuICAgIHZhbHVlICs9IE1JTl9JTlQ2NCArIE1JTl9JTlQ2NDtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gbW9kZXJuQmlnSW50VG9CYXNlNjQodmFsdWUpIHtcbiAgaWYgKHZhbHVlIDwgTUlOX0lOVDY0IHx8IE1BWF9JTlQ2NCA8IHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEJpZ0ludCAke3ZhbHVlfSBkb2VzIG5vdCBmaXQgaW50byBhIDY0LWJpdCBzaWduZWQgaW50ZWdlci5gXG4gICAgKTtcbiAgfVxuICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoOCk7XG4gIG5ldyBEYXRhVmlldyhidWZmZXIpLnNldEJpZ0ludDY0KDAsIHZhbHVlLCB0cnVlKTtcbiAgcmV0dXJuIEJhc2U2NC5mcm9tQnl0ZUFycmF5KG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1vZGVybkJhc2U2NFRvQmlnSW50KGVuY29kZWQpIHtcbiAgY29uc3QgaW50ZWdlckJ5dGVzID0gQmFzZTY0LnRvQnl0ZUFycmF5KGVuY29kZWQpO1xuICBpZiAoaW50ZWdlckJ5dGVzLmJ5dGVMZW5ndGggIT09IDgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUmVjZWl2ZWQgJHtpbnRlZ2VyQnl0ZXMuYnl0ZUxlbmd0aH0gYnl0ZXMsIGV4cGVjdGVkIDggZm9yICRpbnRlZ2VyYFxuICAgICk7XG4gIH1cbiAgY29uc3QgaW50Qnl0ZXNWaWV3ID0gbmV3IERhdGFWaWV3KGludGVnZXJCeXRlcy5idWZmZXIpO1xuICByZXR1cm4gaW50Qnl0ZXNWaWV3LmdldEJpZ0ludDY0KDAsIHRydWUpO1xufVxuZXhwb3J0IGNvbnN0IGJpZ0ludFRvQmFzZTY0ID0gRGF0YVZpZXcucHJvdG90eXBlLnNldEJpZ0ludDY0ID8gbW9kZXJuQmlnSW50VG9CYXNlNjQgOiBzbG93QmlnSW50VG9CYXNlNjQ7XG5leHBvcnQgY29uc3QgYmFzZTY0VG9CaWdJbnQgPSBEYXRhVmlldy5wcm90b3R5cGUuZ2V0QmlnSW50NjQgPyBtb2Rlcm5CYXNlNjRUb0JpZ0ludCA6IHNsb3dCYXNlNjRUb0JpZ0ludDtcbmNvbnN0IE1BWF9JREVOVElGSUVSX0xFTiA9IDEwMjQ7XG5mdW5jdGlvbiB2YWxpZGF0ZU9iamVjdEZpZWxkKGspIHtcbiAgaWYgKGsubGVuZ3RoID4gTUFYX0lERU5USUZJRVJfTEVOKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEZpZWxkIG5hbWUgJHtrfSBleGNlZWRzIG1heGltdW0gZmllbGQgbmFtZSBsZW5ndGggJHtNQVhfSURFTlRJRklFUl9MRU59LmBcbiAgICApO1xuICB9XG4gIGlmIChrLnN0YXJ0c1dpdGgoXCIkXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBuYW1lICR7a30gc3RhcnRzIHdpdGggYSAnJCcsIHdoaWNoIGlzIHJlc2VydmVkLmApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgay5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGNoYXJDb2RlID0gay5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjaGFyQ29kZSA8IDMyIHx8IGNoYXJDb2RlID49IDEyNykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmllbGQgbmFtZSAke2t9IGhhcyBpbnZhbGlkIGNoYXJhY3RlciAnJHtrW2ldfSc6IEZpZWxkIG5hbWVzIGNhbiBvbmx5IGNvbnRhaW4gbm9uLWNvbnRyb2wgQVNDSUkgY2hhcmFjdGVyc2BcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24ganNvblRvQ29udmV4KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcCgodmFsdWUyKSA9PiBqc29uVG9Db252ZXgodmFsdWUyKSk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB0eXBlIG9mICR7dmFsdWV9YCk7XG4gIH1cbiAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHZhbHVlKTtcbiAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3Qga2V5ID0gZW50cmllc1swXVswXTtcbiAgICBpZiAoa2V5ID09PSBcIiRieXRlc1wiKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlLiRieXRlcyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCAkYnl0ZXMgZmllbGQgb24gJHt2YWx1ZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCYXNlNjQudG9CeXRlQXJyYXkodmFsdWUuJGJ5dGVzKS5idWZmZXI7XG4gICAgfVxuICAgIGlmIChrZXkgPT09IFwiJGludGVnZXJcIikge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZS4kaW50ZWdlciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCAkaW50ZWdlciBmaWVsZCBvbiAke3ZhbHVlfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2U2NFRvQmlnSW50KHZhbHVlLiRpbnRlZ2VyKTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gXCIkZmxvYXRcIikge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZS4kZmxvYXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYWxmb3JtZWQgJGZsb2F0IGZpZWxkIG9uICR7dmFsdWV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBmbG9hdEJ5dGVzID0gQmFzZTY0LnRvQnl0ZUFycmF5KHZhbHVlLiRmbG9hdCk7XG4gICAgICBpZiAoZmxvYXRCeXRlcy5ieXRlTGVuZ3RoICE9PSA4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgUmVjZWl2ZWQgJHtmbG9hdEJ5dGVzLmJ5dGVMZW5ndGh9IGJ5dGVzLCBleHBlY3RlZCA4IGZvciAkZmxvYXRgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBmbG9hdEJ5dGVzVmlldyA9IG5ldyBEYXRhVmlldyhmbG9hdEJ5dGVzLmJ1ZmZlcik7XG4gICAgICBjb25zdCBmbG9hdCA9IGZsb2F0Qnl0ZXNWaWV3LmdldEZsb2F0NjQoMCwgTElUVExFX0VORElBTik7XG4gICAgICBpZiAoIWlzU3BlY2lhbChmbG9hdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGbG9hdCAke2Zsb2F0fSBzaG91bGQgYmUgZW5jb2RlZCBhcyBhIG51bWJlcmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZsb2F0O1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSBcIiRzZXRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgUmVjZWl2ZWQgYSBTZXQgd2hpY2ggaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhcyBhIENvbnZleCB0eXBlLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChrZXkgPT09IFwiJG1hcFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBSZWNlaXZlZCBhIE1hcCB3aGljaCBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGFzIGEgQ29udmV4IHR5cGUuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgb3V0ID0ge307XG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgIHZhbGlkYXRlT2JqZWN0RmllbGQoayk7XG4gICAgb3V0W2tdID0ganNvblRvQ29udmV4KHYpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5jb25zdCBNQVhfVkFMVUVfRk9SX0VSUk9SX0xFTiA9IDE2Mzg0O1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeVZhbHVlRm9yRXJyb3IodmFsdWUpIHtcbiAgY29uc3Qgc3RyID0gSlNPTi5zdHJpbmdpZnkodmFsdWUsIChfa2V5LCB2YWx1ZTIpID0+IHtcbiAgICBpZiAodmFsdWUyID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlMiA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgcmV0dXJuIGAke3ZhbHVlMi50b1N0cmluZygpfW5gO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUyO1xuICB9KTtcbiAgaWYgKHN0ci5sZW5ndGggPiBNQVhfVkFMVUVfRk9SX0VSUk9SX0xFTikge1xuICAgIGNvbnN0IHJlc3QgPSBcIlsuLi50cnVuY2F0ZWRdXCI7XG4gICAgbGV0IHRydW5jYXRlQXQgPSBNQVhfVkFMVUVfRk9SX0VSUk9SX0xFTiAtIHJlc3QubGVuZ3RoO1xuICAgIGNvbnN0IGNvZGVQb2ludCA9IHN0ci5jb2RlUG9pbnRBdCh0cnVuY2F0ZUF0IC0gMSk7XG4gICAgaWYgKGNvZGVQb2ludCAhPT0gdm9pZCAwICYmIGNvZGVQb2ludCA+IDY1NTM1KSB7XG4gICAgICB0cnVuY2F0ZUF0IC09IDE7XG4gICAgfVxuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHRydW5jYXRlQXQpICsgcmVzdDtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gY29udmV4VG9Kc29uSW50ZXJuYWwodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGNvbnRleHQsIGluY2x1ZGVUb3BMZXZlbFVuZGVmaW5lZCkge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIGNvbnN0IGNvbnRleHRUZXh0ID0gY29udGV4dCAmJiBgIChwcmVzZW50IGF0IHBhdGggJHtjb250ZXh0fSBpbiBvcmlnaW5hbCBvYmplY3QgJHtzdHJpbmdpZnlWYWx1ZUZvckVycm9yKFxuICAgICAgb3JpZ2luYWxWYWx1ZVxuICAgICl9KWA7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYHVuZGVmaW5lZCBpcyBub3QgYSB2YWxpZCBDb252ZXggdmFsdWUke2NvbnRleHRUZXh0fS4gVG8gbGVhcm4gYWJvdXQgQ29udmV4J3Mgc3VwcG9ydGVkIHR5cGVzLCBzZWUgaHR0cHM6Ly9kb2NzLmNvbnZleC5kZXYvdXNpbmcvdHlwZXMuYFxuICAgICk7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICBpZiAodmFsdWUgPCBNSU5fSU5UNjQgfHwgTUFYX0lOVDY0IDwgdmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEJpZ0ludCAke3ZhbHVlfSBkb2VzIG5vdCBmaXQgaW50byBhIDY0LWJpdCBzaWduZWQgaW50ZWdlci5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4geyAkaW50ZWdlcjogYmlnSW50VG9CYXNlNjQodmFsdWUpIH07XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChpc1NwZWNpYWwodmFsdWUpKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoOCk7XG4gICAgICBuZXcgRGF0YVZpZXcoYnVmZmVyKS5zZXRGbG9hdDY0KDAsIHZhbHVlLCBMSVRUTEVfRU5ESUFOKTtcbiAgICAgIHJldHVybiB7ICRmbG9hdDogQmFzZTY0LmZyb21CeXRlQXJyYXkobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHsgJGJ5dGVzOiBCYXNlNjQuZnJvbUJ5dGVBcnJheShuZXcgVWludDhBcnJheSh2YWx1ZSkpIH07XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcChcbiAgICAgICh2YWx1ZTIsIGkpID0+IGNvbnZleFRvSnNvbkludGVybmFsKHZhbHVlMiwgb3JpZ2luYWxWYWx1ZSwgY29udGV4dCArIGBbJHtpfV1gLCBmYWxzZSlcbiAgICApO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGVycm9yTWVzc2FnZUZvclVuc3VwcG9ydGVkVHlwZShjb250ZXh0LCBcIlNldFwiLCBbLi4udmFsdWVdLCBvcmlnaW5hbFZhbHVlKVxuICAgICk7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZXJyb3JNZXNzYWdlRm9yVW5zdXBwb3J0ZWRUeXBlKGNvbnRleHQsIFwiTWFwXCIsIFsuLi52YWx1ZV0sIG9yaWdpbmFsVmFsdWUpXG4gICAgKTtcbiAgfVxuICBpZiAoIWlzU2ltcGxlT2JqZWN0KHZhbHVlKSkge1xuICAgIGNvbnN0IHRoZVR5cGUgPSB2YWx1ZT8uY29uc3RydWN0b3I/Lm5hbWU7XG4gICAgY29uc3QgdHlwZU5hbWUgPSB0aGVUeXBlID8gYCR7dGhlVHlwZX0gYCA6IFwiXCI7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZXJyb3JNZXNzYWdlRm9yVW5zdXBwb3J0ZWRUeXBlKGNvbnRleHQsIHR5cGVOYW1lLCB2YWx1ZSwgb3JpZ2luYWxWYWx1ZSlcbiAgICApO1xuICB9XG4gIGNvbnN0IG91dCA9IHt9O1xuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICBlbnRyaWVzLnNvcnQoKFtrMSwgX3YxXSwgW2syLCBfdjJdKSA9PiBrMSA9PT0gazIgPyAwIDogazEgPCBrMiA/IC0xIDogMSk7XG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIGVudHJpZXMpIHtcbiAgICBpZiAodiAhPT0gdm9pZCAwKSB7XG4gICAgICB2YWxpZGF0ZU9iamVjdEZpZWxkKGspO1xuICAgICAgb3V0W2tdID0gY29udmV4VG9Kc29uSW50ZXJuYWwodiwgb3JpZ2luYWxWYWx1ZSwgY29udGV4dCArIGAuJHtrfWAsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGluY2x1ZGVUb3BMZXZlbFVuZGVmaW5lZCkge1xuICAgICAgdmFsaWRhdGVPYmplY3RGaWVsZChrKTtcbiAgICAgIG91dFtrXSA9IGNvbnZleE9yVW5kZWZpbmVkVG9Kc29uSW50ZXJuYWwoXG4gICAgICAgIHYsXG4gICAgICAgIG9yaWdpbmFsVmFsdWUsXG4gICAgICAgIGNvbnRleHQgKyBgLiR7a31gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gZXJyb3JNZXNzYWdlRm9yVW5zdXBwb3J0ZWRUeXBlKGNvbnRleHQsIHR5cGVOYW1lLCB2YWx1ZSwgb3JpZ2luYWxWYWx1ZSkge1xuICBpZiAoY29udGV4dCkge1xuICAgIHJldHVybiBgJHt0eXBlTmFtZX0ke3N0cmluZ2lmeVZhbHVlRm9yRXJyb3IoXG4gICAgICB2YWx1ZVxuICAgICl9IGlzIG5vdCBhIHN1cHBvcnRlZCBDb252ZXggdHlwZSAocHJlc2VudCBhdCBwYXRoICR7Y29udGV4dH0gaW4gb3JpZ2luYWwgb2JqZWN0ICR7c3RyaW5naWZ5VmFsdWVGb3JFcnJvcihcbiAgICAgIG9yaWdpbmFsVmFsdWVcbiAgICApfSkuIFRvIGxlYXJuIGFib3V0IENvbnZleCdzIHN1cHBvcnRlZCB0eXBlcywgc2VlIGh0dHBzOi8vZG9jcy5jb252ZXguZGV2L3VzaW5nL3R5cGVzLmA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAke3R5cGVOYW1lfSR7c3RyaW5naWZ5VmFsdWVGb3JFcnJvcihcbiAgICAgIHZhbHVlXG4gICAgKX0gaXMgbm90IGEgc3VwcG9ydGVkIENvbnZleCB0eXBlLmA7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnZleE9yVW5kZWZpbmVkVG9Kc29uSW50ZXJuYWwodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGNvbnRleHQpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4geyAkdW5kZWZpbmVkOiBudWxsIH07XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9yaWdpbmFsVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgUHJvZ3JhbW1pbmcgZXJyb3IuIEN1cnJlbnQgdmFsdWUgaXMgJHtzdHJpbmdpZnlWYWx1ZUZvckVycm9yKFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgICl9IGJ1dCBvcmlnaW5hbCB2YWx1ZSBpcyB1bmRlZmluZWRgXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY29udmV4VG9Kc29uSW50ZXJuYWwodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGNvbnRleHQsIGZhbHNlKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZleFRvSnNvbih2YWx1ZSkge1xuICByZXR1cm4gY29udmV4VG9Kc29uSW50ZXJuYWwodmFsdWUsIHZhbHVlLCBcIlwiLCBmYWxzZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmV4T3JVbmRlZmluZWRUb0pzb24odmFsdWUpIHtcbiAgcmV0dXJuIGNvbnZleE9yVW5kZWZpbmVkVG9Kc29uSW50ZXJuYWwodmFsdWUsIHZhbHVlLCBcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXRjaFZhbHVlVG9Kc29uKHZhbHVlKSB7XG4gIHJldHVybiBjb252ZXhUb0pzb25JbnRlcm5hbCh2YWx1ZSwgdmFsdWUsIFwiXCIsIHRydWUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsdWUuanMubWFwXG4iXSwibmFtZXMiOlsiQmFzZTY0IiwiaXNTaW1wbGVPYmplY3QiLCJMSVRUTEVfRU5ESUFOIiwiTUlOX0lOVDY0IiwiQmlnSW50IiwiTUFYX0lOVDY0IiwiWkVSTyIsIkVJR0hUIiwiVFdPRklGVFlTSVgiLCJpc1NwZWNpYWwiLCJuIiwiTnVtYmVyIiwiaXNOYU4iLCJpc0Zpbml0ZSIsIk9iamVjdCIsImlzIiwic2xvd0JpZ0ludFRvQmFzZTY0IiwidmFsdWUiLCJoZXgiLCJ0b1N0cmluZyIsImxlbmd0aCIsImJ5dGVzIiwiVWludDhBcnJheSIsIkFycmF5QnVmZmVyIiwiaSIsImhleEJ5dGUiLCJtYXRjaCIsInJldmVyc2UiLCJzZXQiLCJwYXJzZUludCIsImZyb21CeXRlQXJyYXkiLCJzbG93QmFzZTY0VG9CaWdJbnQiLCJlbmNvZGVkIiwiaW50ZWdlckJ5dGVzIiwidG9CeXRlQXJyYXkiLCJieXRlTGVuZ3RoIiwiRXJyb3IiLCJwb3dlciIsImJ5dGUiLCJtb2Rlcm5CaWdJbnRUb0Jhc2U2NCIsImJ1ZmZlciIsIkRhdGFWaWV3Iiwic2V0QmlnSW50NjQiLCJtb2Rlcm5CYXNlNjRUb0JpZ0ludCIsImludEJ5dGVzVmlldyIsImdldEJpZ0ludDY0IiwiYmlnSW50VG9CYXNlNjQiLCJwcm90b3R5cGUiLCJiYXNlNjRUb0JpZ0ludCIsIk1BWF9JREVOVElGSUVSX0xFTiIsInZhbGlkYXRlT2JqZWN0RmllbGQiLCJrIiwic3RhcnRzV2l0aCIsImNoYXJDb2RlIiwiY2hhckNvZGVBdCIsImpzb25Ub0NvbnZleCIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsInZhbHVlMiIsImVudHJpZXMiLCJrZXkiLCIkYnl0ZXMiLCIkaW50ZWdlciIsIiRmbG9hdCIsImZsb2F0Qnl0ZXMiLCJmbG9hdEJ5dGVzVmlldyIsImZsb2F0IiwiZ2V0RmxvYXQ2NCIsIm91dCIsInYiLCJNQVhfVkFMVUVfRk9SX0VSUk9SX0xFTiIsInN0cmluZ2lmeVZhbHVlRm9yRXJyb3IiLCJzdHIiLCJKU09OIiwic3RyaW5naWZ5IiwiX2tleSIsInJlc3QiLCJ0cnVuY2F0ZUF0IiwiY29kZVBvaW50IiwiY29kZVBvaW50QXQiLCJzdWJzdHJpbmciLCJjb252ZXhUb0pzb25JbnRlcm5hbCIsIm9yaWdpbmFsVmFsdWUiLCJjb250ZXh0IiwiaW5jbHVkZVRvcExldmVsVW5kZWZpbmVkIiwiY29udGV4dFRleHQiLCJzZXRGbG9hdDY0IiwiU2V0IiwiZXJyb3JNZXNzYWdlRm9yVW5zdXBwb3J0ZWRUeXBlIiwiTWFwIiwidGhlVHlwZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsInR5cGVOYW1lIiwic29ydCIsImsxIiwiX3YxIiwiazIiLCJfdjIiLCJjb252ZXhPclVuZGVmaW5lZFRvSnNvbkludGVybmFsIiwiJHVuZGVmaW5lZCIsImNvbnZleFRvSnNvbiIsImNvbnZleE9yVW5kZWZpbmVkVG9Kc29uIiwicGF0Y2hWYWx1ZVRvSnNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/values/value.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/vendor/jwt-decode/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/convex/dist/esm/vendor/jwt-decode/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidTokenError: function() { return /* binding */ InvalidTokenError; },\n/* harmony export */   jwtDecode: function() { return /* binding */ jwtDecode; }\n/* harmony export */ });\n\nclass InvalidTokenError extends Error {\n}\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\nfunction b64DecodeUnicode(str) {\n    return decodeURIComponent(atob(str).replace(/(.)/g, (_m, p)=>{\n        let code = p.charCodeAt(0).toString(16).toUpperCase();\n        if (code.length < 2) {\n            code = \"0\" + code;\n        }\n        return \"%\" + code;\n    }));\n}\nfunction base64UrlDecode(str) {\n    let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch(output.length % 4){\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw new Error(\"base64 string is not of the correct length\");\n    }\n    try {\n        return b64DecodeUnicode(output);\n    } catch (e) {\n        return atob(output);\n    }\n}\nfunction jwtDecode(token, options) {\n    if (typeof token !== \"string\") {\n        throw new InvalidTokenError(\"Invalid token specified: must be a string\");\n    }\n    options || (options = {});\n    const pos = options.header === true ? 0 : 1;\n    const part = token.split(\".\")[pos];\n    if (typeof part !== \"string\") {\n        throw new InvalidTokenError(\"Invalid token specified: missing part #\".concat(pos + 1));\n    }\n    let decoded;\n    try {\n        decoded = base64UrlDecode(part);\n    } catch (e) {\n        throw new InvalidTokenError(\"Invalid token specified: invalid base64 for part #\".concat(pos + 1, \" (\").concat(e.message, \")\"));\n    }\n    try {\n        return JSON.parse(decoded);\n    } catch (e) {\n        throw new InvalidTokenError(\"Invalid token specified: invalid json for part #\".concat(pos + 1, \" (\").concat(e.message, \")\"));\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmVuZG9yL2p3dC1kZWNvZGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBYTtBQUNOLE1BQU1BLDBCQUEwQkM7QUFDdkM7QUFDQUQsa0JBQWtCRSxTQUFTLENBQUNDLElBQUksR0FBRztBQUNuQyxTQUFTQyxpQkFBaUJDLEdBQUc7SUFDM0IsT0FBT0MsbUJBQ0xDLEtBQUtGLEtBQUtHLE9BQU8sQ0FBQyxRQUFRLENBQUNDLElBQUlDO1FBQzdCLElBQUlDLE9BQU9ELEVBQUVFLFVBQVUsQ0FBQyxHQUFHQyxRQUFRLENBQUMsSUFBSUMsV0FBVztRQUNuRCxJQUFJSCxLQUFLSSxNQUFNLEdBQUcsR0FBRztZQUNuQkosT0FBTyxNQUFNQTtRQUNmO1FBQ0EsT0FBTyxNQUFNQTtJQUNmO0FBRUo7QUFDQSxTQUFTSyxnQkFBZ0JYLEdBQUc7SUFDMUIsSUFBSVksU0FBU1osSUFBSUcsT0FBTyxDQUFDLE1BQU0sS0FBS0EsT0FBTyxDQUFDLE1BQU07SUFDbEQsT0FBUVMsT0FBT0YsTUFBTSxHQUFHO1FBQ3RCLEtBQUs7WUFDSDtRQUNGLEtBQUs7WUFDSEUsVUFBVTtZQUNWO1FBQ0YsS0FBSztZQUNIQSxVQUFVO1lBQ1Y7UUFDRjtZQUNFLE1BQU0sSUFBSWhCLE1BQU07SUFDcEI7SUFDQSxJQUFJO1FBQ0YsT0FBT0csaUJBQWlCYTtJQUMxQixFQUFFLFVBQU07UUFDTixPQUFPVixLQUFLVTtJQUNkO0FBQ0Y7QUFDTyxTQUFTQyxVQUFVQyxLQUFLLEVBQUVDLE9BQU87SUFDdEMsSUFBSSxPQUFPRCxVQUFVLFVBQVU7UUFDN0IsTUFBTSxJQUFJbkIsa0JBQWtCO0lBQzlCO0lBQ0FvQixXQUFZQSxDQUFBQSxVQUFVLENBQUM7SUFDdkIsTUFBTUMsTUFBTUQsUUFBUUUsTUFBTSxLQUFLLE9BQU8sSUFBSTtJQUMxQyxNQUFNQyxPQUFPSixNQUFNSyxLQUFLLENBQUMsSUFBSSxDQUFDSCxJQUFJO0lBQ2xDLElBQUksT0FBT0UsU0FBUyxVQUFVO1FBQzVCLE1BQU0sSUFBSXZCLGtCQUNSLDBDQUFrRCxPQUFScUIsTUFBTTtJQUVwRDtJQUNBLElBQUlJO0lBQ0osSUFBSTtRQUNGQSxVQUFVVCxnQkFBZ0JPO0lBQzVCLEVBQUUsT0FBT0csR0FBRztRQUNWLE1BQU0sSUFBSTFCLGtCQUNSLHFEQUFpRTBCLE9BQVpMLE1BQU0sR0FBRSxNQUFjLE9BQVZLLEVBQUVDLE9BQU8sRUFBQztJQUUvRTtJQUNBLElBQUk7UUFDRixPQUFPQyxLQUFLQyxLQUFLLENBQUNKO0lBQ3BCLEVBQUUsT0FBT0MsR0FBRztRQUNWLE1BQU0sSUFBSTFCLGtCQUNSLG1EQUErRDBCLE9BQVpMLE1BQU0sR0FBRSxNQUFjLE9BQVZLLEVBQUVDLE9BQU8sRUFBQztJQUU3RTtBQUNGLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmVuZG9yL2p3dC1kZWNvZGUvaW5kZXguanM/ODhlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydCBjbGFzcyBJbnZhbGlkVG9rZW5FcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbkludmFsaWRUb2tlbkVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJJbnZhbGlkVG9rZW5FcnJvclwiO1xuZnVuY3Rpb24gYjY0RGVjb2RlVW5pY29kZShzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChcbiAgICBhdG9iKHN0cikucmVwbGFjZSgvKC4pL2csIChfbSwgcCkgPT4ge1xuICAgICAgbGV0IGNvZGUgPSBwLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICBpZiAoY29kZS5sZW5ndGggPCAyKSB7XG4gICAgICAgIGNvZGUgPSBcIjBcIiArIGNvZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCIlXCIgKyBjb2RlO1xuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiBiYXNlNjRVcmxEZWNvZGUoc3RyKSB7XG4gIGxldCBvdXRwdXQgPSBzdHIucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gIHN3aXRjaCAob3V0cHV0Lmxlbmd0aCAlIDQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBvdXRwdXQgKz0gXCI9PVwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgb3V0cHV0ICs9IFwiPVwiO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJhc2U2NCBzdHJpbmcgaXMgbm90IG9mIHRoZSBjb3JyZWN0IGxlbmd0aFwiKTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBiNjREZWNvZGVVbmljb2RlKG91dHB1dCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBhdG9iKG91dHB1dCk7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBqd3REZWNvZGUodG9rZW4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkVG9rZW5FcnJvcihcIkludmFsaWQgdG9rZW4gc3BlY2lmaWVkOiBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICB9XG4gIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gIGNvbnN0IHBvcyA9IG9wdGlvbnMuaGVhZGVyID09PSB0cnVlID8gMCA6IDE7XG4gIGNvbnN0IHBhcnQgPSB0b2tlbi5zcGxpdChcIi5cIilbcG9zXTtcbiAgaWYgKHR5cGVvZiBwYXJ0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUb2tlbkVycm9yKFxuICAgICAgYEludmFsaWQgdG9rZW4gc3BlY2lmaWVkOiBtaXNzaW5nIHBhcnQgIyR7cG9zICsgMX1gXG4gICAgKTtcbiAgfVxuICBsZXQgZGVjb2RlZDtcbiAgdHJ5IHtcbiAgICBkZWNvZGVkID0gYmFzZTY0VXJsRGVjb2RlKHBhcnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUb2tlbkVycm9yKFxuICAgICAgYEludmFsaWQgdG9rZW4gc3BlY2lmaWVkOiBpbnZhbGlkIGJhc2U2NCBmb3IgcGFydCAjJHtwb3MgKyAxfSAoJHtlLm1lc3NhZ2V9KWBcbiAgICApO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRva2VuRXJyb3IoXG4gICAgICBgSW52YWxpZCB0b2tlbiBzcGVjaWZpZWQ6IGludmFsaWQganNvbiBmb3IgcGFydCAjJHtwb3MgKyAxfSAoJHtlLm1lc3NhZ2V9KWBcbiAgICApO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJJbnZhbGlkVG9rZW5FcnJvciIsIkVycm9yIiwicHJvdG90eXBlIiwibmFtZSIsImI2NERlY29kZVVuaWNvZGUiLCJzdHIiLCJkZWNvZGVVUklDb21wb25lbnQiLCJhdG9iIiwicmVwbGFjZSIsIl9tIiwicCIsImNvZGUiLCJjaGFyQ29kZUF0IiwidG9TdHJpbmciLCJ0b1VwcGVyQ2FzZSIsImxlbmd0aCIsImJhc2U2NFVybERlY29kZSIsIm91dHB1dCIsImp3dERlY29kZSIsInRva2VuIiwib3B0aW9ucyIsInBvcyIsImhlYWRlciIsInBhcnQiLCJzcGxpdCIsImRlY29kZWQiLCJlIiwibWVzc2FnZSIsIkpTT04iLCJwYXJzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/vendor/jwt-decode/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/convex/dist/esm/vendor/long.js":
/*!*****************************************************!*\
  !*** ./node_modules/convex/dist/esm/vendor/long.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Long: function() { return /* binding */ Long; }\n/* harmony export */ });\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nclass Long {\n    static isLong(obj) {\n        return (obj && obj.__isUnsignedLong__) === true;\n    }\n    // prettier-ignore\n    static fromBytesLE(bytes) {\n        return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24);\n    }\n    // prettier-ignore\n    toBytesLE() {\n        const hi = this.high;\n        const lo = this.low;\n        return [\n            lo & 255,\n            lo >>> 8 & 255,\n            lo >>> 16 & 255,\n            lo >>> 24,\n            hi & 255,\n            hi >>> 8 & 255,\n            hi >>> 16 & 255,\n            hi >>> 24\n        ];\n    }\n    static fromNumber(value) {\n        if (isNaN(value)) return UZERO;\n        if (value < 0) return UZERO;\n        if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n        return new Long(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0);\n    }\n    toString() {\n        return (BigInt(this.high) * BigInt(TWO_PWR_32_DBL) + BigInt(this.low)).toString();\n    }\n    equals(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        if (this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n        return this.high === other.high && this.low === other.low;\n    }\n    notEquals(other) {\n        return !this.equals(other);\n    }\n    comp(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        if (this.equals(other)) return 0;\n        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n    }\n    lessThanOrEqual(other) {\n        return this.comp(/* validates */ other) <= 0;\n    }\n    static fromValue(val) {\n        if (typeof val === \"number\") return Long.fromNumber(val);\n        return new Long(val.low, val.high);\n    }\n    constructor(low, high){\n        __publicField(this, \"low\");\n        __publicField(this, \"high\");\n        __publicField(this, \"__isUnsignedLong__\");\n        this.low = low | 0;\n        this.high = high | 0;\n        this.__isUnsignedLong__ = true;\n    }\n}\nconst UZERO = new Long(0, 0);\nconst TWO_PWR_16_DBL = 1 << 16;\nconst TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nconst TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nconst MAX_UNSIGNED_VALUE = new Long(4294967295 | 0, 4294967295 | 0); //# sourceMappingURL=long.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmVuZG9yL2xvbmcuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxrQkFBa0IsQ0FBQ0MsS0FBS0MsS0FBS0MsUUFBVUQsT0FBT0QsTUFBTUosVUFBVUksS0FBS0MsS0FBSztRQUFFRSxZQUFZO1FBQU1DLGNBQWM7UUFBTUMsVUFBVTtRQUFNSDtJQUFNLEtBQUtGLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztBQUMxSixJQUFJSSxnQkFBZ0IsQ0FBQ04sS0FBS0MsS0FBS0MsUUFBVUgsZ0JBQWdCQyxLQUFLLE9BQU9DLFFBQVEsV0FBV0EsTUFBTSxLQUFLQSxLQUFLQztBQUNqRyxNQUFNSztJQVNYLE9BQU9DLE9BQU9SLEdBQUcsRUFBRTtRQUNqQixPQUFPLENBQUNBLE9BQU9BLElBQUlTLGtCQUFrQixNQUFNO0lBQzdDO0lBQ0Esa0JBQWtCO0lBQ2xCLE9BQU9DLFlBQVlDLEtBQUssRUFBRTtRQUN4QixPQUFPLElBQUlKLEtBQ1RJLEtBQUssQ0FBQyxFQUFFLEdBQUdBLEtBQUssQ0FBQyxFQUFFLElBQUksSUFBSUEsS0FBSyxDQUFDLEVBQUUsSUFBSSxLQUFLQSxLQUFLLENBQUMsRUFBRSxJQUFJLElBQ3hEQSxLQUFLLENBQUMsRUFBRSxHQUFHQSxLQUFLLENBQUMsRUFBRSxJQUFJLElBQUlBLEtBQUssQ0FBQyxFQUFFLElBQUksS0FBS0EsS0FBSyxDQUFDLEVBQUUsSUFBSTtJQUU1RDtJQUNBLGtCQUFrQjtJQUNsQkMsWUFBWTtRQUNWLE1BQU1DLEtBQUssSUFBSSxDQUFDQyxJQUFJO1FBQ3BCLE1BQU1DLEtBQUssSUFBSSxDQUFDQyxHQUFHO1FBQ25CLE9BQU87WUFDTEQsS0FBSztZQUNMQSxPQUFPLElBQUk7WUFDWEEsT0FBTyxLQUFLO1lBQ1pBLE9BQU87WUFDUEYsS0FBSztZQUNMQSxPQUFPLElBQUk7WUFDWEEsT0FBTyxLQUFLO1lBQ1pBLE9BQU87U0FDUjtJQUNIO0lBQ0EsT0FBT0ksV0FBV2YsS0FBSyxFQUFFO1FBQ3ZCLElBQUlnQixNQUFNaEIsUUFBUSxPQUFPaUI7UUFDekIsSUFBSWpCLFFBQVEsR0FBRyxPQUFPaUI7UUFDdEIsSUFBSWpCLFNBQVNrQixnQkFBZ0IsT0FBT0M7UUFDcEMsT0FBTyxJQUFJZCxLQUFLTCxRQUFRb0IsaUJBQWlCLEdBQUdwQixRQUFRb0IsaUJBQWlCO0lBQ3ZFO0lBQ0FDLFdBQVc7UUFDVCxPQUFPLENBQUNDLE9BQU8sSUFBSSxDQUFDVixJQUFJLElBQUlVLE9BQU9GLGtCQUFrQkUsT0FBTyxJQUFJLENBQUNSLEdBQUcsR0FBR08sUUFBUTtJQUNqRjtJQUNBRSxPQUFPQyxLQUFLLEVBQUU7UUFDWixJQUFJLENBQUNuQixLQUFLQyxNQUFNLENBQUNrQixRQUFRQSxRQUFRbkIsS0FBS29CLFNBQVMsQ0FBQ0Q7UUFDaEQsSUFBSSxJQUFJLENBQUNaLElBQUksS0FBSyxPQUFPLEtBQUtZLE1BQU1aLElBQUksS0FBSyxPQUFPLEdBQUcsT0FBTztRQUM5RCxPQUFPLElBQUksQ0FBQ0EsSUFBSSxLQUFLWSxNQUFNWixJQUFJLElBQUksSUFBSSxDQUFDRSxHQUFHLEtBQUtVLE1BQU1WLEdBQUc7SUFDM0Q7SUFDQVksVUFBVUYsS0FBSyxFQUFFO1FBQ2YsT0FBTyxDQUFDLElBQUksQ0FBQ0QsTUFBTSxDQUFDQztJQUN0QjtJQUNBRyxLQUFLSCxLQUFLLEVBQUU7UUFDVixJQUFJLENBQUNuQixLQUFLQyxNQUFNLENBQUNrQixRQUFRQSxRQUFRbkIsS0FBS29CLFNBQVMsQ0FBQ0Q7UUFDaEQsSUFBSSxJQUFJLENBQUNELE1BQU0sQ0FBQ0MsUUFBUSxPQUFPO1FBQy9CLE9BQU9BLE1BQU1aLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQ0EsSUFBSSxLQUFLLEtBQUtZLE1BQU1aLElBQUksS0FBSyxJQUFJLENBQUNBLElBQUksSUFBSVksTUFBTVYsR0FBRyxLQUFLLElBQUksSUFBSSxDQUFDQSxHQUFHLEtBQUssSUFBSSxDQUFDLElBQUk7SUFDbkg7SUFDQWMsZ0JBQWdCSixLQUFLLEVBQUU7UUFDckIsT0FBTyxJQUFJLENBQUNHLElBQUksQ0FDZCxhQUFhLEdBQ2JILFVBQ0c7SUFDUDtJQUNBLE9BQU9DLFVBQVVJLEdBQUcsRUFBRTtRQUNwQixJQUFJLE9BQU9BLFFBQVEsVUFBVSxPQUFPeEIsS0FBS1UsVUFBVSxDQUFDYztRQUNwRCxPQUFPLElBQUl4QixLQUFLd0IsSUFBSWYsR0FBRyxFQUFFZSxJQUFJakIsSUFBSTtJQUNuQztJQWhFQWtCLFlBQVloQixHQUFHLEVBQUVGLElBQUksQ0FBRTtRQUNyQlIsY0FBYyxJQUFJLEVBQUU7UUFDcEJBLGNBQWMsSUFBSSxFQUFFO1FBQ3BCQSxjQUFjLElBQUksRUFBRTtRQUNwQixJQUFJLENBQUNVLEdBQUcsR0FBR0EsTUFBTTtRQUNqQixJQUFJLENBQUNGLElBQUksR0FBR0EsT0FBTztRQUNuQixJQUFJLENBQUNMLGtCQUFrQixHQUFHO0lBQzVCO0FBMERGO0FBQ0EsTUFBTVUsUUFBUSxJQUFJWixLQUFLLEdBQUc7QUFDMUIsTUFBTTBCLGlCQUFpQixLQUFLO0FBQzVCLE1BQU1YLGlCQUFpQlcsaUJBQWlCQTtBQUN4QyxNQUFNYixpQkFBaUJFLGlCQUFpQkE7QUFDeEMsTUFBTUQscUJBQXFCLElBQUlkLEtBQUssYUFBYSxHQUFHLGFBQWEsSUFDakUsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmVuZG9yL2xvbmcuanM/NWQ0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5leHBvcnQgY2xhc3MgTG9uZyB7XG4gIGNvbnN0cnVjdG9yKGxvdywgaGlnaCkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsb3dcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImhpZ2hcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9faXNVbnNpZ25lZExvbmdfX1wiKTtcbiAgICB0aGlzLmxvdyA9IGxvdyB8IDA7XG4gICAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XG4gICAgdGhpcy5fX2lzVW5zaWduZWRMb25nX18gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0xvbmcob2JqKSB7XG4gICAgcmV0dXJuIChvYmogJiYgb2JqLl9faXNVbnNpZ25lZExvbmdfXykgPT09IHRydWU7XG4gIH1cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHN0YXRpYyBmcm9tQnl0ZXNMRShieXRlcykge1xuICAgIHJldHVybiBuZXcgTG9uZyhcbiAgICAgIGJ5dGVzWzBdIHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbM10gPDwgMjQsXG4gICAgICBieXRlc1s0XSB8IGJ5dGVzWzVdIDw8IDggfCBieXRlc1s2XSA8PCAxNiB8IGJ5dGVzWzddIDw8IDI0XG4gICAgKTtcbiAgfVxuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgdG9CeXRlc0xFKCkge1xuICAgIGNvbnN0IGhpID0gdGhpcy5oaWdoO1xuICAgIGNvbnN0IGxvID0gdGhpcy5sb3c7XG4gICAgcmV0dXJuIFtcbiAgICAgIGxvICYgMjU1LFxuICAgICAgbG8gPj4+IDggJiAyNTUsXG4gICAgICBsbyA+Pj4gMTYgJiAyNTUsXG4gICAgICBsbyA+Pj4gMjQsXG4gICAgICBoaSAmIDI1NSxcbiAgICAgIGhpID4+PiA4ICYgMjU1LFxuICAgICAgaGkgPj4+IDE2ICYgMjU1LFxuICAgICAgaGkgPj4+IDI0XG4gICAgXTtcbiAgfVxuICBzdGF0aWMgZnJvbU51bWJlcih2YWx1ZSkge1xuICAgIGlmIChpc05hTih2YWx1ZSkpIHJldHVybiBVWkVSTztcbiAgICBpZiAodmFsdWUgPCAwKSByZXR1cm4gVVpFUk87XG4gICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKSByZXR1cm4gTUFYX1VOU0lHTkVEX1ZBTFVFO1xuICAgIHJldHVybiBuZXcgTG9uZyh2YWx1ZSAlIFRXT19QV1JfMzJfREJMIHwgMCwgdmFsdWUgLyBUV09fUFdSXzMyX0RCTCB8IDApO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAoQmlnSW50KHRoaXMuaGlnaCkgKiBCaWdJbnQoVFdPX1BXUl8zMl9EQkwpICsgQmlnSW50KHRoaXMubG93KSkudG9TdHJpbmcoKTtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAoIUxvbmcuaXNMb25nKG90aGVyKSkgb3RoZXIgPSBMb25nLmZyb21WYWx1ZShvdGhlcik7XG4gICAgaWYgKHRoaXMuaGlnaCA+Pj4gMzEgPT09IDEgJiYgb3RoZXIuaGlnaCA+Pj4gMzEgPT09IDEpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XG4gIH1cbiAgbm90RXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuICF0aGlzLmVxdWFscyhvdGhlcik7XG4gIH1cbiAgY29tcChvdGhlcikge1xuICAgIGlmICghTG9uZy5pc0xvbmcob3RoZXIpKSBvdGhlciA9IExvbmcuZnJvbVZhbHVlKG90aGVyKTtcbiAgICBpZiAodGhpcy5lcXVhbHMob3RoZXIpKSByZXR1cm4gMDtcbiAgICByZXR1cm4gb3RoZXIuaGlnaCA+Pj4gMCA+IHRoaXMuaGlnaCA+Pj4gMCB8fCBvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgb3RoZXIubG93ID4+PiAwID4gdGhpcy5sb3cgPj4+IDAgPyAtMSA6IDE7XG4gIH1cbiAgbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcChcbiAgICAgIC8qIHZhbGlkYXRlcyAqL1xuICAgICAgb3RoZXJcbiAgICApIDw9IDA7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZSh2YWwpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIExvbmcuZnJvbU51bWJlcih2YWwpO1xuICAgIHJldHVybiBuZXcgTG9uZyh2YWwubG93LCB2YWwuaGlnaCk7XG4gIH1cbn1cbmNvbnN0IFVaRVJPID0gbmV3IExvbmcoMCwgMCk7XG5jb25zdCBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XG5jb25zdCBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XG5jb25zdCBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XG5jb25zdCBNQVhfVU5TSUdORURfVkFMVUUgPSBuZXcgTG9uZyg0Mjk0OTY3Mjk1IHwgMCwgNDI5NDk2NzI5NSB8IDApO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9uZy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX19wdWJsaWNGaWVsZCIsIkxvbmciLCJpc0xvbmciLCJfX2lzVW5zaWduZWRMb25nX18iLCJmcm9tQnl0ZXNMRSIsImJ5dGVzIiwidG9CeXRlc0xFIiwiaGkiLCJoaWdoIiwibG8iLCJsb3ciLCJmcm9tTnVtYmVyIiwiaXNOYU4iLCJVWkVSTyIsIlRXT19QV1JfNjRfREJMIiwiTUFYX1VOU0lHTkVEX1ZBTFVFIiwiVFdPX1BXUl8zMl9EQkwiLCJ0b1N0cmluZyIsIkJpZ0ludCIsImVxdWFscyIsIm90aGVyIiwiZnJvbVZhbHVlIiwibm90RXF1YWxzIiwiY29tcCIsImxlc3NUaGFuT3JFcXVhbCIsInZhbCIsImNvbnN0cnVjdG9yIiwiVFdPX1BXUl8xNl9EQkwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/convex/dist/esm/vendor/long.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fqaneahmed%2FPregLife%2Fpreglife%2Fbaby-name-deathmatch%2Fapp%2Fglobals.css&modules=%2FUsers%2Fqaneahmed%2FPregLife%2Fpreglife%2Fbaby-name-deathmatch%2Fcomponents%2FConvexClientProvider.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);